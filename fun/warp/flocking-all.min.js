/*! Flocking 1.0.0, Copyright 2018 Colin Clark | flockingjs.org */


!function(e, t) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
        if (!e.document) throw new Error("jQuery requires a window with a document");
        return t(e);
    } : t(e);
}("undefined" != typeof window ? window : this, function(w, e) {
    "use strict";
    var t = [], C = w.document, r = Object.getPrototypeOf, u = t.slice, g = t.concat, l = t.push, o = t.indexOf, n = {}, a = n.toString, h = n.hasOwnProperty, i = h.toString, s = i.call(Object), v = {}, y = function(e) {
        return "function" == typeof e && "number" != typeof e.nodeType;
    }, k = function(e) {
        return null != e && e === e.window;
    }, c = {
        type: !0,
        src: !0,
        noModule: !0
    };
    function b(e, t, n) {
        var r, o = (t = t || C).createElement("script");
        if (o.text = e, n) for (r in c) n[r] && (o[r] = n[r]);
        t.head.appendChild(o).parentNode.removeChild(o);
    }
    function x(e) {
        return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[a.call(e)] || "object" : typeof e;
    }
    var f = "3.3.1", A = function(e, t) {
        return new A.fn.init(e, t);
    }, d = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    function p(e) {
        var t = !!e && "length" in e && e.length, n = x(e);
        return !y(e) && !k(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e);
    }
    A.fn = A.prototype = {
        jquery: f,
        constructor: A,
        length: 0,
        toArray: function() {
            return u.call(this);
        },
        get: function(e) {
            return null == e ? u.call(this) : e < 0 ? this[e + this.length] : this[e];
        },
        pushStack: function(e) {
            var t = A.merge(this.constructor(), e);
            return t.prevObject = this, t;
        },
        each: function(e) {
            return A.each(this, e);
        },
        map: function(n) {
            return this.pushStack(A.map(this, function(e, t) {
                return n.call(e, t, e);
            }));
        },
        slice: function() {
            return this.pushStack(u.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(e) {
            var t = this.length, n = +e + (e < 0 ? t : 0);
            return this.pushStack(0 <= n && n < t ? [ this[n] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: l,
        sort: t.sort,
        splice: t.splice
    }, A.extend = A.fn.extend = function() {
        var e, t, n, r, o, a, i = arguments[0] || {}, u = 1, l = arguments.length, s = !1;
        for ("boolean" == typeof i && (s = i, i = arguments[u] || {}, u++), "object" == typeof i || y(i) || (i = {}), 
        u === l && (i = this, u--); u < l; u++) if (null != (e = arguments[u])) for (t in e) n = i[t], 
        i !== (r = e[t]) && (s && r && (A.isPlainObject(r) || (o = Array.isArray(r))) ? (o ? (o = !1, 
        a = n && Array.isArray(n) ? n : []) : a = n && A.isPlainObject(n) ? n : {}, i[t] = A.extend(s, a, r)) : void 0 !== r && (i[t] = r));
        return i;
    }, A.extend({
        expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(e) {
            throw new Error(e);
        },
        noop: function() {},
        isPlainObject: function(e) {
            var t, n;
            return !(!e || "[object Object]" !== a.call(e)) && (!(t = r(e)) || "function" == typeof (n = h.call(t, "constructor") && t.constructor) && i.call(n) === s);
        },
        isEmptyObject: function(e) {
            var t;
            for (t in e) return !1;
            return !0;
        },
        globalEval: function(e) {
            b(e);
        },
        each: function(e, t) {
            var n, r = 0;
            if (p(e)) for (n = e.length; r < n && !1 !== t.call(e[r], r, e[r]); r++) ; else for (r in e) if (!1 === t.call(e[r], r, e[r])) break;
            return e;
        },
        trim: function(e) {
            return null == e ? "" : (e + "").replace(d, "");
        },
        makeArray: function(e, t) {
            var n = t || [];
            return null != e && (p(Object(e)) ? A.merge(n, "string" == typeof e ? [ e ] : e) : l.call(n, e)), 
            n;
        },
        inArray: function(e, t, n) {
            return null == t ? -1 : o.call(t, e, n);
        },
        merge: function(e, t) {
            for (var n = +t.length, r = 0, o = e.length; r < n; r++) e[o++] = t[r];
            return e.length = o, e;
        },
        grep: function(e, t, n) {
            for (var r = [], o = 0, a = e.length, i = !n; o < a; o++) !t(e[o], o) !== i && r.push(e[o]);
            return r;
        },
        map: function(e, t, n) {
            var r, o, a = 0, i = [];
            if (p(e)) for (r = e.length; a < r; a++) null != (o = t(e[a], a, n)) && i.push(o); else for (a in e) null != (o = t(e[a], a, n)) && i.push(o);
            return g.apply([], i);
        },
        guid: 1,
        support: v
    }), "function" == typeof Symbol && (A.fn[Symbol.iterator] = t[Symbol.iterator]), 
    A.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
        n["[object " + t + "]"] = t.toLowerCase();
    });
    var m = function(n) {
        var e, p, b, a, o, m, f, g, x, l, s, S, w, i, C, h, u, c, v, A = "sizzle" + 1 * new Date(), y = n.document, N = 0, r = 0, d = ie(), k = ie(), T = ie(), I = function(e, t) {
            return e === t && (s = !0), 0;
        }, M = {}.hasOwnProperty, t = [], P = t.pop, O = t.push, D = t.push, L = t.slice, E = function(e, t) {
            for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
            return -1;
        }, R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", V = "[\\x20\\t\\r\\n\\f]", F = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", B = "\\[" + V + "*(" + F + ")(?:" + V + "*([*^$|!~]?=)" + V + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + F + "))|)" + V + "*\\]", q = ":(" + F + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + B + ")*)|.*)\\)|)", _ = new RegExp(V + "+", "g"), G = new RegExp("^" + V + "+|((?:^|[^\\\\])(?:\\\\.)*)" + V + "+$", "g"), j = new RegExp("^" + V + "*," + V + "*"), U = new RegExp("^" + V + "*([>+~]|" + V + ")" + V + "*"), H = new RegExp("=" + V + "*([^\\]'\"]*?)" + V + "*\\]", "g"), W = new RegExp(q), z = new RegExp("^" + F + "$"), $ = {
            ID: new RegExp("^#(" + F + ")"),
            CLASS: new RegExp("^\\.(" + F + ")"),
            TAG: new RegExp("^(" + F + "|[*])"),
            ATTR: new RegExp("^" + B),
            PSEUDO: new RegExp("^" + q),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + V + "*(even|odd|(([+-]|)(\\d*)n|)" + V + "*(?:([+-]|)" + V + "*(\\d+)|))" + V + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + R + ")$", "i"),
            needsContext: new RegExp("^" + V + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + V + "*((?:-\\d)?\\d*)" + V + "*\\)|)(?=[^-]|$)", "i")
        }, K = /^(?:input|select|textarea|button)$/i, J = /^h\d$/i, X = /^[^{]+\{\s*\[native \w/, Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, Y = /[+~]/, Z = new RegExp("\\\\([\\da-f]{1,6}" + V + "?|(" + V + ")|.)", "ig"), ee = function(e, t, n) {
            var r = "0x" + t - 65536;
            return r != r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320);
        }, te = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ne = function(e, t) {
            return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e;
        }, re = function() {
            S();
        }, oe = ye(function(e) {
            return !0 === e.disabled && ("form" in e || "label" in e);
        }, {
            dir: "parentNode",
            next: "legend"
        });
        try {
            D.apply(t = L.call(y.childNodes), y.childNodes), t[y.childNodes.length].nodeType;
        } catch (e) {
            D = {
                apply: t.length ? function(e, t) {
                    O.apply(e, L.call(t));
                } : function(e, t) {
                    for (var n = e.length, r = 0; e[n++] = t[r++]; ) ;
                    e.length = n - 1;
                }
            };
        }
        function ae(e, t, n, r) {
            var o, a, i, u, l, s, c, f = t && t.ownerDocument, d = t ? t.nodeType : 9;
            if (n = n || [], "string" != typeof e || !e || 1 !== d && 9 !== d && 11 !== d) return n;
            if (!r && ((t ? t.ownerDocument || t : y) !== w && S(t), t = t || w, C)) {
                if (11 !== d && (l = Q.exec(e))) if (o = l[1]) {
                    if (9 === d) {
                        if (!(i = t.getElementById(o))) return n;
                        if (i.id === o) return n.push(i), n;
                    } else if (f && (i = f.getElementById(o)) && v(t, i) && i.id === o) return n.push(i), 
                    n;
                } else {
                    if (l[2]) return D.apply(n, t.getElementsByTagName(e)), n;
                    if ((o = l[3]) && p.getElementsByClassName && t.getElementsByClassName) return D.apply(n, t.getElementsByClassName(o)), 
                    n;
                }
                if (p.qsa && !T[e + " "] && (!h || !h.test(e))) {
                    if (1 !== d) f = t, c = e; else if ("object" !== t.nodeName.toLowerCase()) {
                        for ((u = t.getAttribute("id")) ? u = u.replace(te, ne) : t.setAttribute("id", u = A), 
                        a = (s = m(e)).length; a--; ) s[a] = "#" + u + " " + ve(s[a]);
                        c = s.join(","), f = Y.test(e) && ge(t.parentNode) || t;
                    }
                    if (c) try {
                        return D.apply(n, f.querySelectorAll(c)), n;
                    } catch (e) {} finally {
                        u === A && t.removeAttribute("id");
                    }
                }
            }
            return g(e.replace(G, "$1"), t, n, r);
        }
        function ie() {
            var r = [];
            return function e(t, n) {
                return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n;
            };
        }
        function ue(e) {
            return e[A] = !0, e;
        }
        function le(e) {
            var t = w.createElement("fieldset");
            try {
                return !!e(t);
            } catch (e) {
                return !1;
            } finally {
                t.parentNode && t.parentNode.removeChild(t), t = null;
            }
        }
        function se(e, t) {
            for (var n = e.split("|"), r = n.length; r--; ) b.attrHandle[n[r]] = t;
        }
        function ce(e, t) {
            var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
            if (r) return r;
            if (n) for (;n = n.nextSibling; ) if (n === t) return -1;
            return e ? 1 : -1;
        }
        function fe(t) {
            return function(e) {
                return "input" === e.nodeName.toLowerCase() && e.type === t;
            };
        }
        function de(n) {
            return function(e) {
                var t = e.nodeName.toLowerCase();
                return ("input" === t || "button" === t) && e.type === n;
            };
        }
        function pe(t) {
            return function(e) {
                return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && oe(e) === t : e.disabled === t : "label" in e && e.disabled === t;
            };
        }
        function me(i) {
            return ue(function(a) {
                return a = +a, ue(function(e, t) {
                    for (var n, r = i([], e.length, a), o = r.length; o--; ) e[n = r[o]] && (e[n] = !(t[n] = e[n]));
                });
            });
        }
        function ge(e) {
            return e && void 0 !== e.getElementsByTagName && e;
        }
        for (e in p = ae.support = {}, o = ae.isXML = function(e) {
            var t = e && (e.ownerDocument || e).documentElement;
            return !!t && "HTML" !== t.nodeName;
        }, S = ae.setDocument = function(e) {
            var t, n, r = e ? e.ownerDocument || e : y;
            return r !== w && 9 === r.nodeType && r.documentElement && (i = (w = r).documentElement, 
            C = !o(w), y !== w && (n = w.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", re, !1) : n.attachEvent && n.attachEvent("onunload", re)), 
            p.attributes = le(function(e) {
                return e.className = "i", !e.getAttribute("className");
            }), p.getElementsByTagName = le(function(e) {
                return e.appendChild(w.createComment("")), !e.getElementsByTagName("*").length;
            }), p.getElementsByClassName = X.test(w.getElementsByClassName), p.getById = le(function(e) {
                return i.appendChild(e).id = A, !w.getElementsByName || !w.getElementsByName(A).length;
            }), p.getById ? (b.filter.ID = function(e) {
                var t = e.replace(Z, ee);
                return function(e) {
                    return e.getAttribute("id") === t;
                };
            }, b.find.ID = function(e, t) {
                if (void 0 !== t.getElementById && C) {
                    var n = t.getElementById(e);
                    return n ? [ n ] : [];
                }
            }) : (b.filter.ID = function(e) {
                var n = e.replace(Z, ee);
                return function(e) {
                    var t = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
                    return t && t.value === n;
                };
            }, b.find.ID = function(e, t) {
                if (void 0 !== t.getElementById && C) {
                    var n, r, o, a = t.getElementById(e);
                    if (a) {
                        if ((n = a.getAttributeNode("id")) && n.value === e) return [ a ];
                        for (o = t.getElementsByName(e), r = 0; a = o[r++]; ) if ((n = a.getAttributeNode("id")) && n.value === e) return [ a ];
                    }
                    return [];
                }
            }), b.find.TAG = p.getElementsByTagName ? function(e, t) {
                return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : p.qsa ? t.querySelectorAll(e) : void 0;
            } : function(e, t) {
                var n, r = [], o = 0, a = t.getElementsByTagName(e);
                if ("*" === e) {
                    for (;n = a[o++]; ) 1 === n.nodeType && r.push(n);
                    return r;
                }
                return a;
            }, b.find.CLASS = p.getElementsByClassName && function(e, t) {
                if (void 0 !== t.getElementsByClassName && C) return t.getElementsByClassName(e);
            }, u = [], h = [], (p.qsa = X.test(w.querySelectorAll)) && (le(function(e) {
                i.appendChild(e).innerHTML = "<a id='" + A + "'></a><select id='" + A + "-\r\\' msallowcapture=''><option selected=''></option></select>", 
                e.querySelectorAll("[msallowcapture^='']").length && h.push("[*^$]=" + V + "*(?:''|\"\")"), 
                e.querySelectorAll("[selected]").length || h.push("\\[" + V + "*(?:value|" + R + ")"), 
                e.querySelectorAll("[id~=" + A + "-]").length || h.push("~="), e.querySelectorAll(":checked").length || h.push(":checked"), 
                e.querySelectorAll("a#" + A + "+*").length || h.push(".#.+[+~]");
            }), le(function(e) {
                e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var t = w.createElement("input");
                t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && h.push("name" + V + "*[*^$|!~]?="), 
                2 !== e.querySelectorAll(":enabled").length && h.push(":enabled", ":disabled"), 
                i.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && h.push(":enabled", ":disabled"), 
                e.querySelectorAll("*,:x"), h.push(",.*:");
            })), (p.matchesSelector = X.test(c = i.matches || i.webkitMatchesSelector || i.mozMatchesSelector || i.oMatchesSelector || i.msMatchesSelector)) && le(function(e) {
                p.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), u.push("!=", q);
            }), h = h.length && new RegExp(h.join("|")), u = u.length && new RegExp(u.join("|")), 
            t = X.test(i.compareDocumentPosition), v = t || X.test(i.contains) ? function(e, t) {
                var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode;
                return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
            } : function(e, t) {
                if (t) for (;t = t.parentNode; ) if (t === e) return !0;
                return !1;
            }, I = t ? function(e, t) {
                if (e === t) return s = !0, 0;
                var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !p.sortDetached && t.compareDocumentPosition(e) === n ? e === w || e.ownerDocument === y && v(y, e) ? -1 : t === w || t.ownerDocument === y && v(y, t) ? 1 : l ? E(l, e) - E(l, t) : 0 : 4 & n ? -1 : 1);
            } : function(e, t) {
                if (e === t) return s = !0, 0;
                var n, r = 0, o = e.parentNode, a = t.parentNode, i = [ e ], u = [ t ];
                if (!o || !a) return e === w ? -1 : t === w ? 1 : o ? -1 : a ? 1 : l ? E(l, e) - E(l, t) : 0;
                if (o === a) return ce(e, t);
                for (n = e; n = n.parentNode; ) i.unshift(n);
                for (n = t; n = n.parentNode; ) u.unshift(n);
                for (;i[r] === u[r]; ) r++;
                return r ? ce(i[r], u[r]) : i[r] === y ? -1 : u[r] === y ? 1 : 0;
            }), w;
        }, ae.matches = function(e, t) {
            return ae(e, null, null, t);
        }, ae.matchesSelector = function(e, t) {
            if ((e.ownerDocument || e) !== w && S(e), t = t.replace(H, "='$1']"), p.matchesSelector && C && !T[t + " "] && (!u || !u.test(t)) && (!h || !h.test(t))) try {
                var n = c.call(e, t);
                if (n || p.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n;
            } catch (e) {}
            return 0 < ae(t, w, null, [ e ]).length;
        }, ae.contains = function(e, t) {
            return (e.ownerDocument || e) !== w && S(e), v(e, t);
        }, ae.attr = function(e, t) {
            (e.ownerDocument || e) !== w && S(e);
            var n = b.attrHandle[t.toLowerCase()], r = n && M.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !C) : void 0;
            return void 0 !== r ? r : p.attributes || !C ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
        }, ae.escape = function(e) {
            return (e + "").replace(te, ne);
        }, ae.error = function(e) {
            throw new Error("Syntax error, unrecognized expression: " + e);
        }, ae.uniqueSort = function(e) {
            var t, n = [], r = 0, o = 0;
            if (s = !p.detectDuplicates, l = !p.sortStable && e.slice(0), e.sort(I), s) {
                for (;t = e[o++]; ) t === e[o] && (r = n.push(o));
                for (;r--; ) e.splice(n[r], 1);
            }
            return l = null, e;
        }, a = ae.getText = function(e) {
            var t, n = "", r = 0, o = e.nodeType;
            if (o) {
                if (1 === o || 9 === o || 11 === o) {
                    if ("string" == typeof e.textContent) return e.textContent;
                    for (e = e.firstChild; e; e = e.nextSibling) n += a(e);
                } else if (3 === o || 4 === o) return e.nodeValue;
            } else for (;t = e[r++]; ) n += a(t);
            return n;
        }, (b = ae.selectors = {
            cacheLength: 50,
            createPseudo: ue,
            match: $,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(e) {
                    return e[1] = e[1].replace(Z, ee), e[3] = (e[3] || e[4] || e[5] || "").replace(Z, ee), 
                    "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
                },
                CHILD: function(e) {
                    return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || ae.error(e[0]), 
                    e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && ae.error(e[0]), 
                    e;
                },
                PSEUDO: function(e) {
                    var t, n = !e[6] && e[2];
                    return $.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && W.test(n) && (t = m(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), 
                    e[2] = n.slice(0, t)), e.slice(0, 3));
                }
            },
            filter: {
                TAG: function(e) {
                    var t = e.replace(Z, ee).toLowerCase();
                    return "*" === e ? function() {
                        return !0;
                    } : function(e) {
                        return e.nodeName && e.nodeName.toLowerCase() === t;
                    };
                },
                CLASS: function(e) {
                    var t = d[e + " "];
                    return t || (t = new RegExp("(^|" + V + ")" + e + "(" + V + "|$)")) && d(e, function(e) {
                        return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "");
                    });
                },
                ATTR: function(n, r, o) {
                    return function(e) {
                        var t = ae.attr(e, n);
                        return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === o : "!=" === r ? t !== o : "^=" === r ? o && 0 === t.indexOf(o) : "*=" === r ? o && -1 < t.indexOf(o) : "$=" === r ? o && t.slice(-o.length) === o : "~=" === r ? -1 < (" " + t.replace(_, " ") + " ").indexOf(o) : "|=" === r && (t === o || t.slice(0, o.length + 1) === o + "-"));
                    };
                },
                CHILD: function(m, e, t, g, h) {
                    var v = "nth" !== m.slice(0, 3), y = "last" !== m.slice(-4), k = "of-type" === e;
                    return 1 === g && 0 === h ? function(e) {
                        return !!e.parentNode;
                    } : function(e, t, n) {
                        var r, o, a, i, u, l, s = v !== y ? "nextSibling" : "previousSibling", c = e.parentNode, f = k && e.nodeName.toLowerCase(), d = !n && !k, p = !1;
                        if (c) {
                            if (v) {
                                for (;s; ) {
                                    for (i = e; i = i[s]; ) if (k ? i.nodeName.toLowerCase() === f : 1 === i.nodeType) return !1;
                                    l = s = "only" === m && !l && "nextSibling";
                                }
                                return !0;
                            }
                            if (l = [ y ? c.firstChild : c.lastChild ], y && d) {
                                for (p = (u = (r = (o = (a = (i = c)[A] || (i[A] = {}))[i.uniqueID] || (a[i.uniqueID] = {}))[m] || [])[0] === N && r[1]) && r[2], 
                                i = u && c.childNodes[u]; i = ++u && i && i[s] || (p = u = 0) || l.pop(); ) if (1 === i.nodeType && ++p && i === e) {
                                    o[m] = [ N, u, p ];
                                    break;
                                }
                            } else if (d && (p = u = (r = (o = (a = (i = e)[A] || (i[A] = {}))[i.uniqueID] || (a[i.uniqueID] = {}))[m] || [])[0] === N && r[1]), 
                            !1 === p) for (;(i = ++u && i && i[s] || (p = u = 0) || l.pop()) && ((k ? i.nodeName.toLowerCase() !== f : 1 !== i.nodeType) || !++p || (d && ((o = (a = i[A] || (i[A] = {}))[i.uniqueID] || (a[i.uniqueID] = {}))[m] = [ N, p ]), 
                            i !== e)); ) ;
                            return (p -= h) === g || p % g == 0 && 0 <= p / g;
                        }
                    };
                },
                PSEUDO: function(e, a) {
                    var t, i = b.pseudos[e] || b.setFilters[e.toLowerCase()] || ae.error("unsupported pseudo: " + e);
                    return i[A] ? i(a) : 1 < i.length ? (t = [ e, e, "", a ], b.setFilters.hasOwnProperty(e.toLowerCase()) ? ue(function(e, t) {
                        for (var n, r = i(e, a), o = r.length; o--; ) e[n = E(e, r[o])] = !(t[n] = r[o]);
                    }) : function(e) {
                        return i(e, 0, t);
                    }) : i;
                }
            },
            pseudos: {
                not: ue(function(e) {
                    var r = [], o = [], u = f(e.replace(G, "$1"));
                    return u[A] ? ue(function(e, t, n, r) {
                        for (var o, a = u(e, null, r, []), i = e.length; i--; ) (o = a[i]) && (e[i] = !(t[i] = o));
                    }) : function(e, t, n) {
                        return r[0] = e, u(r, null, n, o), r[0] = null, !o.pop();
                    };
                }),
                has: ue(function(t) {
                    return function(e) {
                        return 0 < ae(t, e).length;
                    };
                }),
                contains: ue(function(t) {
                    return t = t.replace(Z, ee), function(e) {
                        return -1 < (e.textContent || e.innerText || a(e)).indexOf(t);
                    };
                }),
                lang: ue(function(n) {
                    return z.test(n || "") || ae.error("unsupported lang: " + n), n = n.replace(Z, ee).toLowerCase(), 
                    function(e) {
                        var t;
                        do {
                            if (t = C ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-");
                        } while ((e = e.parentNode) && 1 === e.nodeType);
                        return !1;
                    };
                }),
                target: function(e) {
                    var t = n.location && n.location.hash;
                    return t && t.slice(1) === e.id;
                },
                root: function(e) {
                    return e === i;
                },
                focus: function(e) {
                    return e === w.activeElement && (!w.hasFocus || w.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
                },
                enabled: pe(!1),
                disabled: pe(!0),
                checked: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && !!e.checked || "option" === t && !!e.selected;
                },
                selected: function(e) {
                    return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
                },
                empty: function(e) {
                    for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(e) {
                    return !b.pseudos.empty(e);
                },
                header: function(e) {
                    return J.test(e.nodeName);
                },
                input: function(e) {
                    return K.test(e.nodeName);
                },
                button: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && "button" === e.type || "button" === t;
                },
                text: function(e) {
                    var t;
                    return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
                },
                first: me(function() {
                    return [ 0 ];
                }),
                last: me(function(e, t) {
                    return [ t - 1 ];
                }),
                eq: me(function(e, t, n) {
                    return [ n < 0 ? n + t : n ];
                }),
                even: me(function(e, t) {
                    for (var n = 0; n < t; n += 2) e.push(n);
                    return e;
                }),
                odd: me(function(e, t) {
                    for (var n = 1; n < t; n += 2) e.push(n);
                    return e;
                }),
                lt: me(function(e, t, n) {
                    for (var r = n < 0 ? n + t : n; 0 <= --r; ) e.push(r);
                    return e;
                }),
                gt: me(function(e, t, n) {
                    for (var r = n < 0 ? n + t : n; ++r < t; ) e.push(r);
                    return e;
                })
            }
        }).pseudos.nth = b.pseudos.eq, {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) b.pseudos[e] = fe(e);
        for (e in {
            submit: !0,
            reset: !0
        }) b.pseudos[e] = de(e);
        function he() {}
        function ve(e) {
            for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
            return r;
        }
        function ye(u, e, t) {
            var l = e.dir, s = e.next, c = s || l, f = t && "parentNode" === c, d = r++;
            return e.first ? function(e, t, n) {
                for (;e = e[l]; ) if (1 === e.nodeType || f) return u(e, t, n);
                return !1;
            } : function(e, t, n) {
                var r, o, a, i = [ N, d ];
                if (n) {
                    for (;e = e[l]; ) if ((1 === e.nodeType || f) && u(e, t, n)) return !0;
                } else for (;e = e[l]; ) if (1 === e.nodeType || f) if (o = (a = e[A] || (e[A] = {}))[e.uniqueID] || (a[e.uniqueID] = {}), 
                s && s === e.nodeName.toLowerCase()) e = e[l] || e; else {
                    if ((r = o[c]) && r[0] === N && r[1] === d) return i[2] = r[2];
                    if ((o[c] = i)[2] = u(e, t, n)) return !0;
                }
                return !1;
            };
        }
        function ke(o) {
            return 1 < o.length ? function(e, t, n) {
                for (var r = o.length; r--; ) if (!o[r](e, t, n)) return !1;
                return !0;
            } : o[0];
        }
        function be(e, t, n, r, o) {
            for (var a, i = [], u = 0, l = e.length, s = null != t; u < l; u++) (a = e[u]) && (n && !n(a, r, o) || (i.push(a), 
            s && t.push(u)));
            return i;
        }
        function xe(p, m, g, h, v, e) {
            return h && !h[A] && (h = xe(h)), v && !v[A] && (v = xe(v, e)), ue(function(e, t, n, r) {
                var o, a, i, u = [], l = [], s = t.length, c = e || function(e, t, n) {
                    for (var r = 0, o = t.length; r < o; r++) ae(e, t[r], n);
                    return n;
                }(m || "*", n.nodeType ? [ n ] : n, []), f = !p || !e && m ? c : be(c, u, p, n, r), d = g ? v || (e ? p : s || h) ? [] : t : f;
                if (g && g(f, d, n, r), h) for (o = be(d, l), h(o, [], n, r), a = o.length; a--; ) (i = o[a]) && (d[l[a]] = !(f[l[a]] = i));
                if (e) {
                    if (v || p) {
                        if (v) {
                            for (o = [], a = d.length; a--; ) (i = d[a]) && o.push(f[a] = i);
                            v(null, d = [], o, r);
                        }
                        for (a = d.length; a--; ) (i = d[a]) && -1 < (o = v ? E(e, i) : u[a]) && (e[o] = !(t[o] = i));
                    }
                } else d = be(d === t ? d.splice(s, d.length) : d), v ? v(null, t, d, r) : D.apply(t, d);
            });
        }
        function Se(e) {
            for (var o, t, n, r = e.length, a = b.relative[e[0].type], i = a || b.relative[" "], u = a ? 1 : 0, l = ye(function(e) {
                return e === o;
            }, i, !0), s = ye(function(e) {
                return -1 < E(o, e);
            }, i, !0), c = [ function(e, t, n) {
                var r = !a && (n || t !== x) || ((o = t).nodeType ? l(e, t, n) : s(e, t, n));
                return o = null, r;
            } ]; u < r; u++) if (t = b.relative[e[u].type]) c = [ ye(ke(c), t) ]; else {
                if ((t = b.filter[e[u].type].apply(null, e[u].matches))[A]) {
                    for (n = ++u; n < r && !b.relative[e[n].type]; n++) ;
                    return xe(1 < u && ke(c), 1 < u && ve(e.slice(0, u - 1).concat({
                        value: " " === e[u - 2].type ? "*" : ""
                    })).replace(G, "$1"), t, u < n && Se(e.slice(u, n)), n < r && Se(e = e.slice(n)), n < r && ve(e));
                }
                c.push(t);
            }
            return ke(c);
        }
        return he.prototype = b.filters = b.pseudos, b.setFilters = new he(), m = ae.tokenize = function(e, t) {
            var n, r, o, a, i, u, l, s = k[e + " "];
            if (s) return t ? 0 : s.slice(0);
            for (i = e, u = [], l = b.preFilter; i; ) {
                for (a in n && !(r = j.exec(i)) || (r && (i = i.slice(r[0].length) || i), u.push(o = [])), 
                n = !1, (r = U.exec(i)) && (n = r.shift(), o.push({
                    value: n,
                    type: r[0].replace(G, " ")
                }), i = i.slice(n.length)), b.filter) !(r = $[a].exec(i)) || l[a] && !(r = l[a](r)) || (n = r.shift(), 
                o.push({
                    value: n,
                    type: a,
                    matches: r
                }), i = i.slice(n.length));
                if (!n) break;
            }
            return t ? i.length : i ? ae.error(e) : k(e, u).slice(0);
        }, f = ae.compile = function(e, t) {
            var n, h, v, y, k, r, o = [], a = [], i = T[e + " "];
            if (!i) {
                for (t || (t = m(e)), n = t.length; n--; ) (i = Se(t[n]))[A] ? o.push(i) : a.push(i);
                (i = T(e, (h = a, y = 0 < (v = o).length, k = 0 < h.length, r = function(e, t, n, r, o) {
                    var a, i, u, l = 0, s = "0", c = e && [], f = [], d = x, p = e || k && b.find.TAG("*", o), m = N += null == d ? 1 : Math.random() || .1, g = p.length;
                    for (o && (x = t === w || t || o); s !== g && null != (a = p[s]); s++) {
                        if (k && a) {
                            for (i = 0, t || a.ownerDocument === w || (S(a), n = !C); u = h[i++]; ) if (u(a, t || w, n)) {
                                r.push(a);
                                break;
                            }
                            o && (N = m);
                        }
                        y && ((a = !u && a) && l--, e && c.push(a));
                    }
                    if (l += s, y && s !== l) {
                        for (i = 0; u = v[i++]; ) u(c, f, t, n);
                        if (e) {
                            if (0 < l) for (;s--; ) c[s] || f[s] || (f[s] = P.call(r));
                            f = be(f);
                        }
                        D.apply(r, f), o && !e && 0 < f.length && 1 < l + v.length && ae.uniqueSort(r);
                    }
                    return o && (N = m, x = d), c;
                }, y ? ue(r) : r))).selector = e;
            }
            return i;
        }, g = ae.select = function(e, t, n, r) {
            var o, a, i, u, l, s = "function" == typeof e && e, c = !r && m(e = s.selector || e);
            if (n = n || [], 1 === c.length) {
                if (2 < (a = c[0] = c[0].slice(0)).length && "ID" === (i = a[0]).type && 9 === t.nodeType && C && b.relative[a[1].type]) {
                    if (!(t = (b.find.ID(i.matches[0].replace(Z, ee), t) || [])[0])) return n;
                    s && (t = t.parentNode), e = e.slice(a.shift().value.length);
                }
                for (o = $.needsContext.test(e) ? 0 : a.length; o-- && (i = a[o], !b.relative[u = i.type]); ) if ((l = b.find[u]) && (r = l(i.matches[0].replace(Z, ee), Y.test(a[0].type) && ge(t.parentNode) || t))) {
                    if (a.splice(o, 1), !(e = r.length && ve(a))) return D.apply(n, r), n;
                    break;
                }
            }
            return (s || f(e, c))(r, t, !C, n, !t || Y.test(e) && ge(t.parentNode) || t), n;
        }, p.sortStable = A.split("").sort(I).join("") === A, p.detectDuplicates = !!s, 
        S(), p.sortDetached = le(function(e) {
            return 1 & e.compareDocumentPosition(w.createElement("fieldset"));
        }), le(function(e) {
            return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href");
        }) || se("type|href|height|width", function(e, t, n) {
            if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
        }), p.attributes && le(function(e) {
            return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");
        }) || se("value", function(e, t, n) {
            if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
        }), le(function(e) {
            return null == e.getAttribute("disabled");
        }) || se(R, function(e, t, n) {
            var r;
            if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
        }), ae;
    }(w);
    A.find = m, A.expr = m.selectors, A.expr[":"] = A.expr.pseudos, A.uniqueSort = A.unique = m.uniqueSort, 
    A.text = m.getText, A.isXMLDoc = m.isXML, A.contains = m.contains, A.escapeSelector = m.escape;
    var S = function(e, t, n) {
        for (var r = [], o = void 0 !== n; (e = e[t]) && 9 !== e.nodeType; ) if (1 === e.nodeType) {
            if (o && A(e).is(n)) break;
            r.push(e);
        }
        return r;
    }, N = function(e, t) {
        for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
        return n;
    }, T = A.expr.match.needsContext;
    function I(e, t) {
        return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
    }
    var M = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function P(e, n, r) {
        return y(n) ? A.grep(e, function(e, t) {
            return !!n.call(e, t, e) !== r;
        }) : n.nodeType ? A.grep(e, function(e) {
            return e === n !== r;
        }) : "string" != typeof n ? A.grep(e, function(e) {
            return -1 < o.call(n, e) !== r;
        }) : A.filter(n, e, r);
    }
    A.filter = function(e, t, n) {
        var r = t[0];
        return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? A.find.matchesSelector(r, e) ? [ r ] : [] : A.find.matches(e, A.grep(t, function(e) {
            return 1 === e.nodeType;
        }));
    }, A.fn.extend({
        find: function(e) {
            var t, n, r = this.length, o = this;
            if ("string" != typeof e) return this.pushStack(A(e).filter(function() {
                for (t = 0; t < r; t++) if (A.contains(o[t], this)) return !0;
            }));
            for (n = this.pushStack([]), t = 0; t < r; t++) A.find(e, o[t], n);
            return 1 < r ? A.uniqueSort(n) : n;
        },
        filter: function(e) {
            return this.pushStack(P(this, e || [], !1));
        },
        not: function(e) {
            return this.pushStack(P(this, e || [], !0));
        },
        is: function(e) {
            return !!P(this, "string" == typeof e && T.test(e) ? A(e) : e || [], !1).length;
        }
    });
    var O, D = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (A.fn.init = function(e, t, n) {
        var r, o;
        if (!e) return this;
        if (n = n || O, "string" == typeof e) {
            if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [ null, e, null ] : D.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
            if (r[1]) {
                if (t = t instanceof A ? t[0] : t, A.merge(this, A.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : C, !0)), 
                M.test(r[1]) && A.isPlainObject(t)) for (r in t) y(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
                return this;
            }
            return (o = C.getElementById(r[2])) && (this[0] = o, this.length = 1), this;
        }
        return e.nodeType ? (this[0] = e, this.length = 1, this) : y(e) ? void 0 !== n.ready ? n.ready(e) : e(A) : A.makeArray(e, this);
    }).prototype = A.fn, O = A(C);
    var L = /^(?:parents|prev(?:Until|All))/, E = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    function R(e, t) {
        for (;(e = e[t]) && 1 !== e.nodeType; ) ;
        return e;
    }
    A.fn.extend({
        has: function(e) {
            var t = A(e, this), n = t.length;
            return this.filter(function() {
                for (var e = 0; e < n; e++) if (A.contains(this, t[e])) return !0;
            });
        },
        closest: function(e, t) {
            var n, r = 0, o = this.length, a = [], i = "string" != typeof e && A(e);
            if (!T.test(e)) for (;r < o; r++) for (n = this[r]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (i ? -1 < i.index(n) : 1 === n.nodeType && A.find.matchesSelector(n, e))) {
                a.push(n);
                break;
            }
            return this.pushStack(1 < a.length ? A.uniqueSort(a) : a);
        },
        index: function(e) {
            return e ? "string" == typeof e ? o.call(A(e), this[0]) : o.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(e, t) {
            return this.pushStack(A.uniqueSort(A.merge(this.get(), A(e, t))));
        },
        addBack: function(e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
        }
    }), A.each({
        parent: function(e) {
            var t = e.parentNode;
            return t && 11 !== t.nodeType ? t : null;
        },
        parents: function(e) {
            return S(e, "parentNode");
        },
        parentsUntil: function(e, t, n) {
            return S(e, "parentNode", n);
        },
        next: function(e) {
            return R(e, "nextSibling");
        },
        prev: function(e) {
            return R(e, "previousSibling");
        },
        nextAll: function(e) {
            return S(e, "nextSibling");
        },
        prevAll: function(e) {
            return S(e, "previousSibling");
        },
        nextUntil: function(e, t, n) {
            return S(e, "nextSibling", n);
        },
        prevUntil: function(e, t, n) {
            return S(e, "previousSibling", n);
        },
        siblings: function(e) {
            return N((e.parentNode || {}).firstChild, e);
        },
        children: function(e) {
            return N(e.firstChild);
        },
        contents: function(e) {
            return I(e, "iframe") ? e.contentDocument : (I(e, "template") && (e = e.content || e), 
            A.merge([], e.childNodes));
        }
    }, function(r, o) {
        A.fn[r] = function(e, t) {
            var n = A.map(this, o, e);
            return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = A.filter(t, n)), 
            1 < this.length && (E[r] || A.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n);
        };
    });
    var V = /[^\x20\t\r\n\f]+/g;
    function F(e) {
        return e;
    }
    function B(e) {
        throw e;
    }
    function q(e, t, n, r) {
        var o;
        try {
            e && y(o = e.promise) ? o.call(e).done(t).fail(n) : e && y(o = e.then) ? o.call(e, t, n) : t.apply(void 0, [ e ].slice(r));
        } catch (e) {
            n.apply(void 0, [ e ]);
        }
    }
    A.Callbacks = function(r) {
        var e, n;
        r = "string" == typeof r ? (e = r, n = {}, A.each(e.match(V) || [], function(e, t) {
            n[t] = !0;
        }), n) : A.extend({}, r);
        var o, t, a, i, u = [], l = [], s = -1, c = function() {
            for (i = i || r.once, a = o = !0; l.length; s = -1) for (t = l.shift(); ++s < u.length; ) !1 === u[s].apply(t[0], t[1]) && r.stopOnFalse && (s = u.length, 
            t = !1);
            r.memory || (t = !1), o = !1, i && (u = t ? [] : "");
        }, f = {
            add: function() {
                return u && (t && !o && (s = u.length - 1, l.push(t)), function n(e) {
                    A.each(e, function(e, t) {
                        y(t) ? r.unique && f.has(t) || u.push(t) : t && t.length && "string" !== x(t) && n(t);
                    });
                }(arguments), t && !o && c()), this;
            },
            remove: function() {
                return A.each(arguments, function(e, t) {
                    for (var n; -1 < (n = A.inArray(t, u, n)); ) u.splice(n, 1), n <= s && s--;
                }), this;
            },
            has: function(e) {
                return e ? -1 < A.inArray(e, u) : 0 < u.length;
            },
            empty: function() {
                return u && (u = []), this;
            },
            disable: function() {
                return i = l = [], u = t = "", this;
            },
            disabled: function() {
                return !u;
            },
            lock: function() {
                return i = l = [], t || o || (u = t = ""), this;
            },
            locked: function() {
                return !!i;
            },
            fireWith: function(e, t) {
                return i || (t = [ e, (t = t || []).slice ? t.slice() : t ], l.push(t), o || c()), 
                this;
            },
            fire: function() {
                return f.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!a;
            }
        };
        return f;
    }, A.extend({
        Deferred: function(e) {
            var a = [ [ "notify", "progress", A.Callbacks("memory"), A.Callbacks("memory"), 2 ], [ "resolve", "done", A.Callbacks("once memory"), A.Callbacks("once memory"), 0, "resolved" ], [ "reject", "fail", A.Callbacks("once memory"), A.Callbacks("once memory"), 1, "rejected" ] ], o = "pending", i = {
                state: function() {
                    return o;
                },
                always: function() {
                    return u.done(arguments).fail(arguments), this;
                },
                catch: function(e) {
                    return i.then(null, e);
                },
                pipe: function() {
                    var o = arguments;
                    return A.Deferred(function(r) {
                        A.each(a, function(e, t) {
                            var n = y(o[t[4]]) && o[t[4]];
                            u[t[1]](function() {
                                var e = n && n.apply(this, arguments);
                                e && y(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [ e ] : arguments);
                            });
                        }), o = null;
                    }).promise();
                },
                then: function(t, n, r) {
                    var l = 0;
                    function s(o, a, i, u) {
                        return function() {
                            var n = this, r = arguments, e = function() {
                                var e, t;
                                if (!(o < l)) {
                                    if ((e = i.apply(n, r)) === a.promise()) throw new TypeError("Thenable self-resolution");
                                    t = e && ("object" == typeof e || "function" == typeof e) && e.then, y(t) ? u ? t.call(e, s(l, a, F, u), s(l, a, B, u)) : (l++, 
                                    t.call(e, s(l, a, F, u), s(l, a, B, u), s(l, a, F, a.notifyWith))) : (i !== F && (n = void 0, 
                                    r = [ e ]), (u || a.resolveWith)(n, r));
                                }
                            }, t = u ? e : function() {
                                try {
                                    e();
                                } catch (e) {
                                    A.Deferred.exceptionHook && A.Deferred.exceptionHook(e, t.stackTrace), l <= o + 1 && (i !== B && (n = void 0, 
                                    r = [ e ]), a.rejectWith(n, r));
                                }
                            };
                            o ? t() : (A.Deferred.getStackHook && (t.stackTrace = A.Deferred.getStackHook()), 
                            w.setTimeout(t));
                        };
                    }
                    return A.Deferred(function(e) {
                        a[0][3].add(s(0, e, y(r) ? r : F, e.notifyWith)), a[1][3].add(s(0, e, y(t) ? t : F)), 
                        a[2][3].add(s(0, e, y(n) ? n : B));
                    }).promise();
                },
                promise: function(e) {
                    return null != e ? A.extend(e, i) : i;
                }
            }, u = {};
            return A.each(a, function(e, t) {
                var n = t[2], r = t[5];
                i[t[1]] = n.add, r && n.add(function() {
                    o = r;
                }, a[3 - e][2].disable, a[3 - e][3].disable, a[0][2].lock, a[0][3].lock), n.add(t[3].fire), 
                u[t[0]] = function() {
                    return u[t[0] + "With"](this === u ? void 0 : this, arguments), this;
                }, u[t[0] + "With"] = n.fireWith;
            }), i.promise(u), e && e.call(u, u), u;
        },
        when: function(e) {
            var n = arguments.length, t = n, r = Array(t), o = u.call(arguments), a = A.Deferred(), i = function(t) {
                return function(e) {
                    r[t] = this, o[t] = 1 < arguments.length ? u.call(arguments) : e, --n || a.resolveWith(r, o);
                };
            };
            if (n <= 1 && (q(e, a.done(i(t)).resolve, a.reject, !n), "pending" === a.state() || y(o[t] && o[t].then))) return a.then();
            for (;t--; ) q(o[t], i(t), a.reject);
            return a.promise();
        }
    });
    var _ = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    A.Deferred.exceptionHook = function(e, t) {
        w.console && w.console.warn && e && _.test(e.name) && w.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t);
    }, A.readyException = function(e) {
        w.setTimeout(function() {
            throw e;
        });
    };
    var G = A.Deferred();
    function j() {
        C.removeEventListener("DOMContentLoaded", j), w.removeEventListener("load", j), 
        A.ready();
    }
    A.fn.ready = function(e) {
        return G.then(e).catch(function(e) {
            A.readyException(e);
        }), this;
    }, A.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(e) {
            (!0 === e ? --A.readyWait : A.isReady) || (A.isReady = !0) !== e && 0 < --A.readyWait || G.resolveWith(C, [ A ]);
        }
    }), A.ready.then = G.then, "complete" === C.readyState || "loading" !== C.readyState && !C.documentElement.doScroll ? w.setTimeout(A.ready) : (C.addEventListener("DOMContentLoaded", j), 
    w.addEventListener("load", j));
    var U = function(e, t, n, r, o, a, i) {
        var u = 0, l = e.length, s = null == n;
        if ("object" === x(n)) for (u in o = !0, n) U(e, t, u, n[u], !0, a, i); else if (void 0 !== r && (o = !0, 
        y(r) || (i = !0), s && (i ? (t.call(e, r), t = null) : (s = t, t = function(e, t, n) {
            return s.call(A(e), n);
        })), t)) for (;u < l; u++) t(e[u], n, i ? r : r.call(e[u], u, t(e[u], n)));
        return o ? e : s ? t.call(e) : l ? t(e[0], n) : a;
    }, H = /^-ms-/, W = /-([a-z])/g;
    function z(e, t) {
        return t.toUpperCase();
    }
    function $(e) {
        return e.replace(H, "ms-").replace(W, z);
    }
    var K = function(e) {
        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
    };
    function J() {
        this.expando = A.expando + J.uid++;
    }
    J.uid = 1, J.prototype = {
        cache: function(e) {
            var t = e[this.expando];
            return t || (t = {}, K(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                value: t,
                configurable: !0
            }))), t;
        },
        set: function(e, t, n) {
            var r, o = this.cache(e);
            if ("string" == typeof t) o[$(t)] = n; else for (r in t) o[$(r)] = t[r];
            return o;
        },
        get: function(e, t) {
            return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][$(t)];
        },
        access: function(e, t, n) {
            return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), 
            void 0 !== n ? n : t);
        },
        remove: function(e, t) {
            var n, r = e[this.expando];
            if (void 0 !== r) {
                if (void 0 !== t) {
                    n = (t = Array.isArray(t) ? t.map($) : (t = $(t)) in r ? [ t ] : t.match(V) || []).length;
                    for (;n--; ) delete r[t[n]];
                }
                (void 0 === t || A.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]);
            }
        },
        hasData: function(e) {
            var t = e[this.expando];
            return void 0 !== t && !A.isEmptyObject(t);
        }
    };
    var X = new J(), Q = new J(), Y = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Z = /[A-Z]/g;
    function ee(e, t, n) {
        var r, o;
        if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(Z, "-$&").toLowerCase(), 
        "string" == typeof (n = e.getAttribute(r))) {
            try {
                n = "true" === (o = n) || "false" !== o && ("null" === o ? null : o === +o + "" ? +o : Y.test(o) ? JSON.parse(o) : o);
            } catch (e) {}
            Q.set(e, t, n);
        } else n = void 0;
        return n;
    }
    A.extend({
        hasData: function(e) {
            return Q.hasData(e) || X.hasData(e);
        },
        data: function(e, t, n) {
            return Q.access(e, t, n);
        },
        removeData: function(e, t) {
            Q.remove(e, t);
        },
        _data: function(e, t, n) {
            return X.access(e, t, n);
        },
        _removeData: function(e, t) {
            X.remove(e, t);
        }
    }), A.fn.extend({
        data: function(n, e) {
            var t, r, o, a = this[0], i = a && a.attributes;
            if (void 0 === n) {
                if (this.length && (o = Q.get(a), 1 === a.nodeType && !X.get(a, "hasDataAttrs"))) {
                    for (t = i.length; t--; ) i[t] && 0 === (r = i[t].name).indexOf("data-") && (r = $(r.slice(5)), 
                    ee(a, r, o[r]));
                    X.set(a, "hasDataAttrs", !0);
                }
                return o;
            }
            return "object" == typeof n ? this.each(function() {
                Q.set(this, n);
            }) : U(this, function(e) {
                var t;
                if (a && void 0 === e) return void 0 !== (t = Q.get(a, n)) ? t : void 0 !== (t = ee(a, n)) ? t : void 0;
                this.each(function() {
                    Q.set(this, n, e);
                });
            }, null, e, 1 < arguments.length, null, !0);
        },
        removeData: function(e) {
            return this.each(function() {
                Q.remove(this, e);
            });
        }
    }), A.extend({
        queue: function(e, t, n) {
            var r;
            if (e) return t = (t || "fx") + "queue", r = X.get(e, t), n && (!r || Array.isArray(n) ? r = X.access(e, t, A.makeArray(n)) : r.push(n)), 
            r || [];
        },
        dequeue: function(e, t) {
            t = t || "fx";
            var n = A.queue(e, t), r = n.length, o = n.shift(), a = A._queueHooks(e, t);
            "inprogress" === o && (o = n.shift(), r--), o && ("fx" === t && n.unshift("inprogress"), 
            delete a.stop, o.call(e, function() {
                A.dequeue(e, t);
            }, a)), !r && a && a.empty.fire();
        },
        _queueHooks: function(e, t) {
            var n = t + "queueHooks";
            return X.get(e, n) || X.access(e, n, {
                empty: A.Callbacks("once memory").add(function() {
                    X.remove(e, [ t + "queue", n ]);
                })
            });
        }
    }), A.fn.extend({
        queue: function(t, n) {
            var e = 2;
            return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? A.queue(this[0], t) : void 0 === n ? this : this.each(function() {
                var e = A.queue(this, t, n);
                A._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && A.dequeue(this, t);
            });
        },
        dequeue: function(e) {
            return this.each(function() {
                A.dequeue(this, e);
            });
        },
        clearQueue: function(e) {
            return this.queue(e || "fx", []);
        },
        promise: function(e, t) {
            var n, r = 1, o = A.Deferred(), a = this, i = this.length, u = function() {
                --r || o.resolveWith(a, [ a ]);
            };
            for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; i--; ) (n = X.get(a[i], e + "queueHooks")) && n.empty && (r++, 
            n.empty.add(u));
            return u(), o.promise(t);
        }
    });
    var te = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, ne = new RegExp("^(?:([+-])=|)(" + te + ")([a-z%]*)$", "i"), re = [ "Top", "Right", "Bottom", "Left" ], oe = function(e, t) {
        return "none" === (e = t || e).style.display || "" === e.style.display && A.contains(e.ownerDocument, e) && "none" === A.css(e, "display");
    }, ae = function(e, t, n, r) {
        var o, a, i = {};
        for (a in t) i[a] = e.style[a], e.style[a] = t[a];
        for (a in o = n.apply(e, r || []), t) e.style[a] = i[a];
        return o;
    };
    function ie(e, t, n, r) {
        var o, a, i = 20, u = r ? function() {
            return r.cur();
        } : function() {
            return A.css(e, t, "");
        }, l = u(), s = n && n[3] || (A.cssNumber[t] ? "" : "px"), c = (A.cssNumber[t] || "px" !== s && +l) && ne.exec(A.css(e, t));
        if (c && c[3] !== s) {
            for (l /= 2, s = s || c[3], c = +l || 1; i--; ) A.style(e, t, c + s), (1 - a) * (1 - (a = u() / l || .5)) <= 0 && (i = 0), 
            c /= a;
            c *= 2, A.style(e, t, c + s), n = n || [];
        }
        return n && (c = +c || +l || 0, o = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = s, 
        r.start = c, r.end = o)), o;
    }
    var ue = {};
    function le(e, t) {
        for (var n, r, o, a, i, u, l, s = [], c = 0, f = e.length; c < f; c++) (r = e[c]).style && (n = r.style.display, 
        t ? ("none" === n && (s[c] = X.get(r, "display") || null, s[c] || (r.style.display = "")), 
        "" === r.style.display && oe(r) && (s[c] = (l = i = a = void 0, i = (o = r).ownerDocument, 
        u = o.nodeName, (l = ue[u]) || (a = i.body.appendChild(i.createElement(u)), l = A.css(a, "display"), 
        a.parentNode.removeChild(a), "none" === l && (l = "block"), ue[u] = l)))) : "none" !== n && (s[c] = "none", 
        X.set(r, "display", n)));
        for (c = 0; c < f; c++) null != s[c] && (e[c].style.display = s[c]);
        return e;
    }
    A.fn.extend({
        show: function() {
            return le(this, !0);
        },
        hide: function() {
            return le(this);
        },
        toggle: function(e) {
            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                oe(this) ? A(this).show() : A(this).hide();
            });
        }
    });
    var se = /^(?:checkbox|radio)$/i, ce = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, fe = /^$|^module$|\/(?:java|ecma)script/i, de = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    function pe(e, t) {
        var n;
        return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], 
        void 0 === t || t && I(e, t) ? A.merge([ e ], n) : n;
    }
    function me(e, t) {
        for (var n = 0, r = e.length; n < r; n++) X.set(e[n], "globalEval", !t || X.get(t[n], "globalEval"));
    }
    de.optgroup = de.option, de.tbody = de.tfoot = de.colgroup = de.caption = de.thead, 
    de.th = de.td;
    var ge, he, ve = /<|&#?\w+;/;
    function ye(e, t, n, r, o) {
        for (var a, i, u, l, s, c, f = t.createDocumentFragment(), d = [], p = 0, m = e.length; p < m; p++) if ((a = e[p]) || 0 === a) if ("object" === x(a)) A.merge(d, a.nodeType ? [ a ] : a); else if (ve.test(a)) {
            for (i = i || f.appendChild(t.createElement("div")), u = (ce.exec(a) || [ "", "" ])[1].toLowerCase(), 
            l = de[u] || de._default, i.innerHTML = l[1] + A.htmlPrefilter(a) + l[2], c = l[0]; c--; ) i = i.lastChild;
            A.merge(d, i.childNodes), (i = f.firstChild).textContent = "";
        } else d.push(t.createTextNode(a));
        for (f.textContent = "", p = 0; a = d[p++]; ) if (r && -1 < A.inArray(a, r)) o && o.push(a); else if (s = A.contains(a.ownerDocument, a), 
        i = pe(f.appendChild(a), "script"), s && me(i), n) for (c = 0; a = i[c++]; ) fe.test(a.type || "") && n.push(a);
        return f;
    }
    ge = C.createDocumentFragment().appendChild(C.createElement("div")), (he = C.createElement("input")).setAttribute("type", "radio"), 
    he.setAttribute("checked", "checked"), he.setAttribute("name", "t"), ge.appendChild(he), 
    v.checkClone = ge.cloneNode(!0).cloneNode(!0).lastChild.checked, ge.innerHTML = "<textarea>x</textarea>", 
    v.noCloneChecked = !!ge.cloneNode(!0).lastChild.defaultValue;
    var ke = C.documentElement, be = /^key/, xe = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Se = /^([^.]*)(?:\.(.+)|)/;
    function we() {
        return !0;
    }
    function Ce() {
        return !1;
    }
    function Ae() {
        try {
            return C.activeElement;
        } catch (e) {}
    }
    function Ne(e, t, n, r, o, a) {
        var i, u;
        if ("object" == typeof t) {
            for (u in "string" != typeof n && (r = r || n, n = void 0), t) Ne(e, u, n, r, t[u], a);
            return e;
        }
        if (null == r && null == o ? (o = n, r = n = void 0) : null == o && ("string" == typeof n ? (o = r, 
        r = void 0) : (o = r, r = n, n = void 0)), !1 === o) o = Ce; else if (!o) return e;
        return 1 === a && (i = o, (o = function(e) {
            return A().off(e), i.apply(this, arguments);
        }).guid = i.guid || (i.guid = A.guid++)), e.each(function() {
            A.event.add(this, t, o, r, n);
        });
    }
    A.event = {
        global: {},
        add: function(t, e, n, r, o) {
            var a, i, u, l, s, c, f, d, p, m, g, h = X.get(t);
            if (h) for (n.handler && (n = (a = n).handler, o = a.selector), o && A.find.matchesSelector(ke, o), 
            n.guid || (n.guid = A.guid++), (l = h.events) || (l = h.events = {}), (i = h.handle) || (i = h.handle = function(e) {
                return void 0 !== A && A.event.triggered !== e.type ? A.event.dispatch.apply(t, arguments) : void 0;
            }), s = (e = (e || "").match(V) || [ "" ]).length; s--; ) p = g = (u = Se.exec(e[s]) || [])[1], 
            m = (u[2] || "").split(".").sort(), p && (f = A.event.special[p] || {}, p = (o ? f.delegateType : f.bindType) || p, 
            f = A.event.special[p] || {}, c = A.extend({
                type: p,
                origType: g,
                data: r,
                handler: n,
                guid: n.guid,
                selector: o,
                needsContext: o && A.expr.match.needsContext.test(o),
                namespace: m.join(".")
            }, a), (d = l[p]) || ((d = l[p] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, m, i) || t.addEventListener && t.addEventListener(p, i)), 
            f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), o ? d.splice(d.delegateCount++, 0, c) : d.push(c), 
            A.event.global[p] = !0);
        },
        remove: function(e, t, n, r, o) {
            var a, i, u, l, s, c, f, d, p, m, g, h = X.hasData(e) && X.get(e);
            if (h && (l = h.events)) {
                for (s = (t = (t || "").match(V) || [ "" ]).length; s--; ) if (p = g = (u = Se.exec(t[s]) || [])[1], 
                m = (u[2] || "").split(".").sort(), p) {
                    for (f = A.event.special[p] || {}, d = l[p = (r ? f.delegateType : f.bindType) || p] || [], 
                    u = u[2] && new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = a = d.length; a--; ) c = d[a], 
                    !o && g !== c.origType || n && n.guid !== c.guid || u && !u.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (d.splice(a, 1), 
                    c.selector && d.delegateCount--, f.remove && f.remove.call(e, c));
                    i && !d.length && (f.teardown && !1 !== f.teardown.call(e, m, h.handle) || A.removeEvent(e, p, h.handle), 
                    delete l[p]);
                } else for (p in l) A.event.remove(e, p + t[s], n, r, !0);
                A.isEmptyObject(l) && X.remove(e, "handle events");
            }
        },
        dispatch: function(e) {
            var t, n, r, o, a, i, u = A.event.fix(e), l = new Array(arguments.length), s = (X.get(this, "events") || {})[u.type] || [], c = A.event.special[u.type] || {};
            for (l[0] = u, t = 1; t < arguments.length; t++) l[t] = arguments[t];
            if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) {
                for (i = A.event.handlers.call(this, u, s), t = 0; (o = i[t++]) && !u.isPropagationStopped(); ) for (u.currentTarget = o.elem, 
                n = 0; (a = o.handlers[n++]) && !u.isImmediatePropagationStopped(); ) u.rnamespace && !u.rnamespace.test(a.namespace) || (u.handleObj = a, 
                u.data = a.data, void 0 !== (r = ((A.event.special[a.origType] || {}).handle || a.handler).apply(o.elem, l)) && !1 === (u.result = r) && (u.preventDefault(), 
                u.stopPropagation()));
                return c.postDispatch && c.postDispatch.call(this, u), u.result;
            }
        },
        handlers: function(e, t) {
            var n, r, o, a, i, u = [], l = t.delegateCount, s = e.target;
            if (l && s.nodeType && !("click" === e.type && 1 <= e.button)) for (;s !== this; s = s.parentNode || this) if (1 === s.nodeType && ("click" !== e.type || !0 !== s.disabled)) {
                for (a = [], i = {}, n = 0; n < l; n++) void 0 === i[o = (r = t[n]).selector + " "] && (i[o] = r.needsContext ? -1 < A(o, this).index(s) : A.find(o, this, null, [ s ]).length), 
                i[o] && a.push(r);
                a.length && u.push({
                    elem: s,
                    handlers: a
                });
            }
            return s = this, l < t.length && u.push({
                elem: s,
                handlers: t.slice(l)
            }), u;
        },
        addProp: function(t, e) {
            Object.defineProperty(A.Event.prototype, t, {
                enumerable: !0,
                configurable: !0,
                get: y(e) ? function() {
                    if (this.originalEvent) return e(this.originalEvent);
                } : function() {
                    if (this.originalEvent) return this.originalEvent[t];
                },
                set: function(e) {
                    Object.defineProperty(this, t, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: e
                    });
                }
            });
        },
        fix: function(e) {
            return e[A.expando] ? e : new A.Event(e);
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== Ae() && this.focus) return this.focus(), !1;
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === Ae() && this.blur) return this.blur(), !1;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if ("checkbox" === this.type && this.click && I(this, "input")) return this.click(), 
                    !1;
                },
                _default: function(e) {
                    return I(e.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(e) {
                    void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);
                }
            }
        }
    }, A.removeEvent = function(e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n);
    }, A.Event = function(e, t) {
        if (!(this instanceof A.Event)) return new A.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Ce, 
        this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, 
        this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, 
        t && A.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[A.expando] = !0;
    }, A.Event.prototype = {
        constructor: A.Event,
        isDefaultPrevented: Ce,
        isPropagationStopped: Ce,
        isImmediatePropagationStopped: Ce,
        isSimulated: !1,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, A.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function(e) {
            var t = e.button;
            return null == e.which && be.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && xe.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which;
        }
    }, A.event.addProp), A.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(e, o) {
        A.event.special[e] = {
            delegateType: o,
            bindType: o,
            handle: function(e) {
                var t, n = e.relatedTarget, r = e.handleObj;
                return n && (n === this || A.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), 
                e.type = o), t;
            }
        };
    }), A.fn.extend({
        on: function(e, t, n, r) {
            return Ne(this, e, t, n, r);
        },
        one: function(e, t, n, r) {
            return Ne(this, e, t, n, r, 1);
        },
        off: function(e, t, n) {
            var r, o;
            if (e && e.preventDefault && e.handleObj) return r = e.handleObj, A(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), 
            this;
            if ("object" == typeof e) {
                for (o in e) this.off(o, t, e[o]);
                return this;
            }
            return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Ce), 
            this.each(function() {
                A.event.remove(this, e, n, t);
            });
        }
    });
    var Te = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, Ie = /<script|<style|<link/i, Me = /checked\s*(?:[^=]|=\s*.checked.)/i, Pe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function Oe(e, t) {
        return I(e, "table") && I(11 !== t.nodeType ? t : t.firstChild, "tr") && A(e).children("tbody")[0] || e;
    }
    function De(e) {
        return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e;
    }
    function Le(e) {
        return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), 
        e;
    }
    function Ee(e, t) {
        var n, r, o, a, i, u, l, s;
        if (1 === t.nodeType) {
            if (X.hasData(e) && (a = X.access(e), i = X.set(t, a), s = a.events)) for (o in delete i.handle, 
            i.events = {}, s) for (n = 0, r = s[o].length; n < r; n++) A.event.add(t, o, s[o][n]);
            Q.hasData(e) && (u = Q.access(e), l = A.extend({}, u), Q.set(t, l));
        }
    }
    function Re(n, r, o, a) {
        r = g.apply([], r);
        var e, t, i, u, l, s, c = 0, f = n.length, d = f - 1, p = r[0], m = y(p);
        if (m || 1 < f && "string" == typeof p && !v.checkClone && Me.test(p)) return n.each(function(e) {
            var t = n.eq(e);
            m && (r[0] = p.call(this, e, t.html())), Re(t, r, o, a);
        });
        if (f && (t = (e = ye(r, n[0].ownerDocument, !1, n, a)).firstChild, 1 === e.childNodes.length && (e = t), 
        t || a)) {
            for (u = (i = A.map(pe(e, "script"), De)).length; c < f; c++) l = e, c !== d && (l = A.clone(l, !0, !0), 
            u && A.merge(i, pe(l, "script"))), o.call(n[c], l, c);
            if (u) for (s = i[i.length - 1].ownerDocument, A.map(i, Le), c = 0; c < u; c++) l = i[c], 
            fe.test(l.type || "") && !X.access(l, "globalEval") && A.contains(s, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? A._evalUrl && A._evalUrl(l.src) : b(l.textContent.replace(Pe, ""), s, l));
        }
        return n;
    }
    function Ve(e, t, n) {
        for (var r, o = t ? A.filter(t, e) : e, a = 0; null != (r = o[a]); a++) n || 1 !== r.nodeType || A.cleanData(pe(r)), 
        r.parentNode && (n && A.contains(r.ownerDocument, r) && me(pe(r, "script")), r.parentNode.removeChild(r));
        return e;
    }
    A.extend({
        htmlPrefilter: function(e) {
            return e.replace(Te, "<$1></$2>");
        },
        clone: function(e, t, n) {
            var r, o, a, i, u, l, s, c = e.cloneNode(!0), f = A.contains(e.ownerDocument, e);
            if (!(v.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || A.isXMLDoc(e))) for (i = pe(c), 
            r = 0, o = (a = pe(e)).length; r < o; r++) u = a[r], l = i[r], void 0, "input" === (s = l.nodeName.toLowerCase()) && se.test(u.type) ? l.checked = u.checked : "input" !== s && "textarea" !== s || (l.defaultValue = u.defaultValue);
            if (t) if (n) for (a = a || pe(e), i = i || pe(c), r = 0, o = a.length; r < o; r++) Ee(a[r], i[r]); else Ee(e, c);
            return 0 < (i = pe(c, "script")).length && me(i, !f && pe(e, "script")), c;
        },
        cleanData: function(e) {
            for (var t, n, r, o = A.event.special, a = 0; void 0 !== (n = e[a]); a++) if (K(n)) {
                if (t = n[X.expando]) {
                    if (t.events) for (r in t.events) o[r] ? A.event.remove(n, r) : A.removeEvent(n, r, t.handle);
                    n[X.expando] = void 0;
                }
                n[Q.expando] && (n[Q.expando] = void 0);
            }
        }
    }), A.fn.extend({
        detach: function(e) {
            return Ve(this, e, !0);
        },
        remove: function(e) {
            return Ve(this, e);
        },
        text: function(e) {
            return U(this, function(e) {
                return void 0 === e ? A.text(this) : this.empty().each(function() {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e);
                });
            }, null, e, arguments.length);
        },
        append: function() {
            return Re(this, arguments, function(e) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Oe(this, e).appendChild(e);
            });
        },
        prepend: function() {
            return Re(this, arguments, function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = Oe(this, e);
                    t.insertBefore(e, t.firstChild);
                }
            });
        },
        before: function() {
            return Re(this, arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this);
            });
        },
        after: function() {
            return Re(this, arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
            });
        },
        empty: function() {
            for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (A.cleanData(pe(e, !1)), 
            e.textContent = "");
            return this;
        },
        clone: function(e, t) {
            return e = null != e && e, t = null == t ? e : t, this.map(function() {
                return A.clone(this, e, t);
            });
        },
        html: function(e) {
            return U(this, function(e) {
                var t = this[0] || {}, n = 0, r = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e && !Ie.test(e) && !de[(ce.exec(e) || [ "", "" ])[1].toLowerCase()]) {
                    e = A.htmlPrefilter(e);
                    try {
                        for (;n < r; n++) 1 === (t = this[n] || {}).nodeType && (A.cleanData(pe(t, !1)), 
                        t.innerHTML = e);
                        t = 0;
                    } catch (e) {}
                }
                t && this.empty().append(e);
            }, null, e, arguments.length);
        },
        replaceWith: function() {
            var n = [];
            return Re(this, arguments, function(e) {
                var t = this.parentNode;
                A.inArray(this, n) < 0 && (A.cleanData(pe(this)), t && t.replaceChild(e, this));
            }, n);
        }
    }), A.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(e, i) {
        A.fn[e] = function(e) {
            for (var t, n = [], r = A(e), o = r.length - 1, a = 0; a <= o; a++) t = a === o ? this : this.clone(!0), 
            A(r[a])[i](t), l.apply(n, t.get());
            return this.pushStack(n);
        };
    });
    var Fe = new RegExp("^(" + te + ")(?!px)[a-z%]+$", "i"), Be = function(e) {
        var t = e.ownerDocument.defaultView;
        return t && t.opener || (t = w), t.getComputedStyle(e);
    }, qe = new RegExp(re.join("|"), "i");
    function _e(e, t, n) {
        var r, o, a, i, u = e.style;
        return (n = n || Be(e)) && ("" !== (i = n.getPropertyValue(t) || n[t]) || A.contains(e.ownerDocument, e) || (i = A.style(e, t)), 
        !v.pixelBoxStyles() && Fe.test(i) && qe.test(t) && (r = u.width, o = u.minWidth, 
        a = u.maxWidth, u.minWidth = u.maxWidth = u.width = i, i = n.width, u.width = r, 
        u.minWidth = o, u.maxWidth = a)), void 0 !== i ? i + "" : i;
    }
    function Ge(e, t) {
        return {
            get: function() {
                if (!e()) return (this.get = t).apply(this, arguments);
                delete this.get;
            }
        };
    }
    !function() {
        function e() {
            if (l) {
                u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", 
                l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", 
                ke.appendChild(u).appendChild(l);
                var e = w.getComputedStyle(l);
                n = "1%" !== e.top, i = 12 === t(e.marginLeft), l.style.right = "60%", a = 36 === t(e.right), 
                r = 36 === t(e.width), l.style.position = "absolute", o = 36 === l.offsetWidth || "absolute", 
                ke.removeChild(u), l = null;
            }
        }
        function t(e) {
            return Math.round(parseFloat(e));
        }
        var n, r, o, a, i, u = C.createElement("div"), l = C.createElement("div");
        l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", 
        v.clearCloneStyle = "content-box" === l.style.backgroundClip, A.extend(v, {
            boxSizingReliable: function() {
                return e(), r;
            },
            pixelBoxStyles: function() {
                return e(), a;
            },
            pixelPosition: function() {
                return e(), n;
            },
            reliableMarginLeft: function() {
                return e(), i;
            },
            scrollboxSize: function() {
                return e(), o;
            }
        }));
    }();
    var je = /^(none|table(?!-c[ea]).+)/, Ue = /^--/, He = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, We = {
        letterSpacing: "0",
        fontWeight: "400"
    }, ze = [ "Webkit", "Moz", "ms" ], $e = C.createElement("div").style;
    function Ke(e) {
        var t = A.cssProps[e];
        return t || (t = A.cssProps[e] = function(e) {
            if (e in $e) return e;
            for (var t = e[0].toUpperCase() + e.slice(1), n = ze.length; n--; ) if ((e = ze[n] + t) in $e) return e;
        }(e) || e), t;
    }
    function Je(e, t, n) {
        var r = ne.exec(t);
        return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t;
    }
    function Xe(e, t, n, r, o, a) {
        var i = "width" === t ? 1 : 0, u = 0, l = 0;
        if (n === (r ? "border" : "content")) return 0;
        for (;i < 4; i += 2) "margin" === n && (l += A.css(e, n + re[i], !0, o)), r ? ("content" === n && (l -= A.css(e, "padding" + re[i], !0, o)), 
        "margin" !== n && (l -= A.css(e, "border" + re[i] + "Width", !0, o))) : (l += A.css(e, "padding" + re[i], !0, o), 
        "padding" !== n ? l += A.css(e, "border" + re[i] + "Width", !0, o) : u += A.css(e, "border" + re[i] + "Width", !0, o));
        return !r && 0 <= a && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - a - l - u - .5))), 
        l;
    }
    function Qe(e, t, n) {
        var r = Be(e), o = _e(e, t, r), a = "border-box" === A.css(e, "boxSizing", !1, r), i = a;
        if (Fe.test(o)) {
            if (!n) return o;
            o = "auto";
        }
        return i = i && (v.boxSizingReliable() || o === e.style[t]), ("auto" === o || !parseFloat(o) && "inline" === A.css(e, "display", !1, r)) && (o = e["offset" + t[0].toUpperCase() + t.slice(1)], 
        i = !0), (o = parseFloat(o) || 0) + Xe(e, t, n || (a ? "border" : "content"), i, r, o) + "px";
    }
    function Ye(e, t, n, r, o) {
        return new Ye.prototype.init(e, t, n, r, o);
    }
    A.extend({
        cssHooks: {
            opacity: {
                get: function(e, t) {
                    if (t) {
                        var n = _e(e, "opacity");
                        return "" === n ? "1" : n;
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {},
        style: function(e, t, n, r) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var o, a, i, u = $(t), l = Ue.test(t), s = e.style;
                if (l || (t = Ke(u)), i = A.cssHooks[t] || A.cssHooks[u], void 0 === n) return i && "get" in i && void 0 !== (o = i.get(e, !1, r)) ? o : s[t];
                "string" === (a = typeof n) && (o = ne.exec(n)) && o[1] && (n = ie(e, t, o), a = "number"), 
                null != n && n == n && ("number" === a && (n += o && o[3] || (A.cssNumber[u] ? "" : "px")), 
                v.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (s[t] = "inherit"), 
                i && "set" in i && void 0 === (n = i.set(e, n, r)) || (l ? s.setProperty(t, n) : s[t] = n));
            }
        },
        css: function(e, t, n, r) {
            var o, a, i, u = $(t);
            return Ue.test(t) || (t = Ke(u)), (i = A.cssHooks[t] || A.cssHooks[u]) && "get" in i && (o = i.get(e, !0, n)), 
            void 0 === o && (o = _e(e, t, r)), "normal" === o && t in We && (o = We[t]), "" === n || n ? (a = parseFloat(o), 
            !0 === n || isFinite(a) ? a || 0 : o) : o;
        }
    }), A.each([ "height", "width" ], function(e, u) {
        A.cssHooks[u] = {
            get: function(e, t, n) {
                if (t) return !je.test(A.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Qe(e, u, n) : ae(e, He, function() {
                    return Qe(e, u, n);
                });
            },
            set: function(e, t, n) {
                var r, o = Be(e), a = "border-box" === A.css(e, "boxSizing", !1, o), i = n && Xe(e, u, n, a, o);
                return a && v.scrollboxSize() === o.position && (i -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(o[u]) - Xe(e, u, "border", !1, o) - .5)), 
                i && (r = ne.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = A.css(e, u)), 
                Je(0, t, i);
            }
        };
    }), A.cssHooks.marginLeft = Ge(v.reliableMarginLeft, function(e, t) {
        if (t) return (parseFloat(_e(e, "marginLeft")) || e.getBoundingClientRect().left - ae(e, {
            marginLeft: 0
        }, function() {
            return e.getBoundingClientRect().left;
        })) + "px";
    }), A.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(o, a) {
        A.cssHooks[o + a] = {
            expand: function(e) {
                for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [ e ]; t < 4; t++) n[o + re[t] + a] = r[t] || r[t - 2] || r[0];
                return n;
            }
        }, "margin" !== o && (A.cssHooks[o + a].set = Je);
    }), A.fn.extend({
        css: function(e, t) {
            return U(this, function(e, t, n) {
                var r, o, a = {}, i = 0;
                if (Array.isArray(t)) {
                    for (r = Be(e), o = t.length; i < o; i++) a[t[i]] = A.css(e, t[i], !1, r);
                    return a;
                }
                return void 0 !== n ? A.style(e, t, n) : A.css(e, t);
            }, e, t, 1 < arguments.length);
        }
    }), ((A.Tween = Ye).prototype = {
        constructor: Ye,
        init: function(e, t, n, r, o, a) {
            this.elem = e, this.prop = n, this.easing = o || A.easing._default, this.options = t, 
            this.start = this.now = this.cur(), this.end = r, this.unit = a || (A.cssNumber[n] ? "" : "px");
        },
        cur: function() {
            var e = Ye.propHooks[this.prop];
            return e && e.get ? e.get(this) : Ye.propHooks._default.get(this);
        },
        run: function(e) {
            var t, n = Ye.propHooks[this.prop];
            return this.options.duration ? this.pos = t = A.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, 
            this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            n && n.set ? n.set(this) : Ye.propHooks._default.set(this), this;
        }
    }).init.prototype = Ye.prototype, (Ye.propHooks = {
        _default: {
            get: function(e) {
                var t;
                return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = A.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0;
            },
            set: function(e) {
                A.fx.step[e.prop] ? A.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[A.cssProps[e.prop]] && !A.cssHooks[e.prop] ? e.elem[e.prop] = e.now : A.style(e.elem, e.prop, e.now + e.unit);
            }
        }
    }).scrollTop = Ye.propHooks.scrollLeft = {
        set: function(e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
        }
    }, A.easing = {
        linear: function(e) {
            return e;
        },
        swing: function(e) {
            return .5 - Math.cos(e * Math.PI) / 2;
        },
        _default: "swing"
    }, A.fx = Ye.prototype.init, A.fx.step = {};
    var Ze, et, tt, nt, rt = /^(?:toggle|show|hide)$/, ot = /queueHooks$/;
    function at() {
        et && (!1 === C.hidden && w.requestAnimationFrame ? w.requestAnimationFrame(at) : w.setTimeout(at, A.fx.interval), 
        A.fx.tick());
    }
    function it() {
        return w.setTimeout(function() {
            Ze = void 0;
        }), Ze = Date.now();
    }
    function ut(e, t) {
        var n, r = 0, o = {
            height: e
        };
        for (t = t ? 1 : 0; r < 4; r += 2 - t) o["margin" + (n = re[r])] = o["padding" + n] = e;
        return t && (o.opacity = o.width = e), o;
    }
    function lt(e, t, n) {
        for (var r, o = (st.tweeners[t] || []).concat(st.tweeners["*"]), a = 0, i = o.length; a < i; a++) if (r = o[a].call(n, t, e)) return r;
    }
    function st(a, e, t) {
        var n, i, r = 0, o = st.prefilters.length, u = A.Deferred().always(function() {
            delete l.elem;
        }), l = function() {
            if (i) return !1;
            for (var e = Ze || it(), t = Math.max(0, s.startTime + s.duration - e), n = 1 - (t / s.duration || 0), r = 0, o = s.tweens.length; r < o; r++) s.tweens[r].run(n);
            return u.notifyWith(a, [ s, n, t ]), n < 1 && o ? t : (o || u.notifyWith(a, [ s, 1, 0 ]), 
            u.resolveWith(a, [ s ]), !1);
        }, s = u.promise({
            elem: a,
            props: A.extend({}, e),
            opts: A.extend(!0, {
                specialEasing: {},
                easing: A.easing._default
            }, t),
            originalProperties: e,
            originalOptions: t,
            startTime: Ze || it(),
            duration: t.duration,
            tweens: [],
            createTween: function(e, t) {
                var n = A.Tween(a, s.opts, e, t, s.opts.specialEasing[e] || s.opts.easing);
                return s.tweens.push(n), n;
            },
            stop: function(e) {
                var t = 0, n = e ? s.tweens.length : 0;
                if (i) return this;
                for (i = !0; t < n; t++) s.tweens[t].run(1);
                return e ? (u.notifyWith(a, [ s, 1, 0 ]), u.resolveWith(a, [ s, e ])) : u.rejectWith(a, [ s, e ]), 
                this;
            }
        }), c = s.props;
        for (!function(e, t) {
            var n, r, o, a, i;
            for (n in e) if (o = t[r = $(n)], a = e[n], Array.isArray(a) && (o = a[1], a = e[n] = a[0]), 
            n !== r && (e[r] = a, delete e[n]), (i = A.cssHooks[r]) && "expand" in i) for (n in a = i.expand(a), 
            delete e[r], a) n in e || (e[n] = a[n], t[n] = o); else t[r] = o;
        }(c, s.opts.specialEasing); r < o; r++) if (n = st.prefilters[r].call(s, a, c, s.opts)) return y(n.stop) && (A._queueHooks(s.elem, s.opts.queue).stop = n.stop.bind(n)), 
        n;
        return A.map(c, lt, s), y(s.opts.start) && s.opts.start.call(a, s), s.progress(s.opts.progress).done(s.opts.done, s.opts.complete).fail(s.opts.fail).always(s.opts.always), 
        A.fx.timer(A.extend(l, {
            elem: a,
            anim: s,
            queue: s.opts.queue
        })), s;
    }
    A.Animation = A.extend(st, {
        tweeners: {
            "*": [ function(e, t) {
                var n = this.createTween(e, t);
                return ie(n.elem, e, ne.exec(t), n), n;
            } ]
        },
        tweener: function(e, t) {
            y(e) ? (t = e, e = [ "*" ]) : e = e.match(V);
            for (var n, r = 0, o = e.length; r < o; r++) n = e[r], st.tweeners[n] = st.tweeners[n] || [], 
            st.tweeners[n].unshift(t);
        },
        prefilters: [ function(e, t, n) {
            var r, o, a, i, u, l, s, c, f = "width" in t || "height" in t, d = this, p = {}, m = e.style, g = e.nodeType && oe(e), h = X.get(e, "fxshow");
            for (r in n.queue || (null == (i = A._queueHooks(e, "fx")).unqueued && (i.unqueued = 0, 
            u = i.empty.fire, i.empty.fire = function() {
                i.unqueued || u();
            }), i.unqueued++, d.always(function() {
                d.always(function() {
                    i.unqueued--, A.queue(e, "fx").length || i.empty.fire();
                });
            })), t) if (o = t[r], rt.test(o)) {
                if (delete t[r], a = a || "toggle" === o, o === (g ? "hide" : "show")) {
                    if ("show" !== o || !h || void 0 === h[r]) continue;
                    g = !0;
                }
                p[r] = h && h[r] || A.style(e, r);
            }
            if ((l = !A.isEmptyObject(t)) || !A.isEmptyObject(p)) for (r in f && 1 === e.nodeType && (n.overflow = [ m.overflow, m.overflowX, m.overflowY ], 
            null == (s = h && h.display) && (s = X.get(e, "display")), "none" === (c = A.css(e, "display")) && (s ? c = s : (le([ e ], !0), 
            s = e.style.display || s, c = A.css(e, "display"), le([ e ]))), ("inline" === c || "inline-block" === c && null != s) && "none" === A.css(e, "float") && (l || (d.done(function() {
                m.display = s;
            }), null == s && (c = m.display, s = "none" === c ? "" : c)), m.display = "inline-block")), 
            n.overflow && (m.overflow = "hidden", d.always(function() {
                m.overflow = n.overflow[0], m.overflowX = n.overflow[1], m.overflowY = n.overflow[2];
            })), l = !1, p) l || (h ? "hidden" in h && (g = h.hidden) : h = X.access(e, "fxshow", {
                display: s
            }), a && (h.hidden = !g), g && le([ e ], !0), d.done(function() {
                for (r in g || le([ e ]), X.remove(e, "fxshow"), p) A.style(e, r, p[r]);
            })), l = lt(g ? h[r] : 0, r, d), r in h || (h[r] = l.start, g && (l.end = l.start, 
            l.start = 0));
        } ],
        prefilter: function(e, t) {
            t ? st.prefilters.unshift(e) : st.prefilters.push(e);
        }
    }), A.speed = function(e, t, n) {
        var r = e && "object" == typeof e ? A.extend({}, e) : {
            complete: n || !n && t || y(e) && e,
            duration: e,
            easing: n && t || t && !y(t) && t
        };
        return A.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in A.fx.speeds ? r.duration = A.fx.speeds[r.duration] : r.duration = A.fx.speeds._default), 
        null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
            y(r.old) && r.old.call(this), r.queue && A.dequeue(this, r.queue);
        }, r;
    }, A.fn.extend({
        fadeTo: function(e, t, n, r) {
            return this.filter(oe).css("opacity", 0).show().end().animate({
                opacity: t
            }, e, n, r);
        },
        animate: function(t, e, n, r) {
            var o = A.isEmptyObject(t), a = A.speed(e, n, r), i = function() {
                var e = st(this, A.extend({}, t), a);
                (o || X.get(this, "finish")) && e.stop(!0);
            };
            return i.finish = i, o || !1 === a.queue ? this.each(i) : this.queue(a.queue, i);
        },
        stop: function(o, e, a) {
            var i = function(e) {
                var t = e.stop;
                delete e.stop, t(a);
            };
            return "string" != typeof o && (a = e, e = o, o = void 0), e && !1 !== o && this.queue(o || "fx", []), 
            this.each(function() {
                var e = !0, t = null != o && o + "queueHooks", n = A.timers, r = X.get(this);
                if (t) r[t] && r[t].stop && i(r[t]); else for (t in r) r[t] && r[t].stop && ot.test(t) && i(r[t]);
                for (t = n.length; t--; ) n[t].elem !== this || null != o && n[t].queue !== o || (n[t].anim.stop(a), 
                e = !1, n.splice(t, 1));
                !e && a || A.dequeue(this, o);
            });
        },
        finish: function(i) {
            return !1 !== i && (i = i || "fx"), this.each(function() {
                var e, t = X.get(this), n = t[i + "queue"], r = t[i + "queueHooks"], o = A.timers, a = n ? n.length : 0;
                for (t.finish = !0, A.queue(this, i, []), r && r.stop && r.stop.call(this, !0), 
                e = o.length; e--; ) o[e].elem === this && o[e].queue === i && (o[e].anim.stop(!0), 
                o.splice(e, 1));
                for (e = 0; e < a; e++) n[e] && n[e].finish && n[e].finish.call(this);
                delete t.finish;
            });
        }
    }), A.each([ "toggle", "show", "hide" ], function(e, r) {
        var o = A.fn[r];
        A.fn[r] = function(e, t, n) {
            return null == e || "boolean" == typeof e ? o.apply(this, arguments) : this.animate(ut(r, !0), e, t, n);
        };
    }), A.each({
        slideDown: ut("show"),
        slideUp: ut("hide"),
        slideToggle: ut("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(e, r) {
        A.fn[e] = function(e, t, n) {
            return this.animate(r, e, t, n);
        };
    }), A.timers = [], A.fx.tick = function() {
        var e, t = 0, n = A.timers;
        for (Ze = Date.now(); t < n.length; t++) (e = n[t])() || n[t] !== e || n.splice(t--, 1);
        n.length || A.fx.stop(), Ze = void 0;
    }, A.fx.timer = function(e) {
        A.timers.push(e), A.fx.start();
    }, A.fx.interval = 13, A.fx.start = function() {
        et || (et = !0, at());
    }, A.fx.stop = function() {
        et = null;
    }, A.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, A.fn.delay = function(r, e) {
        return r = A.fx && A.fx.speeds[r] || r, e = e || "fx", this.queue(e, function(e, t) {
            var n = w.setTimeout(e, r);
            t.stop = function() {
                w.clearTimeout(n);
            };
        });
    }, tt = C.createElement("input"), nt = C.createElement("select").appendChild(C.createElement("option")), 
    tt.type = "checkbox", v.checkOn = "" !== tt.value, v.optSelected = nt.selected, 
    (tt = C.createElement("input")).value = "t", tt.type = "radio", v.radioValue = "t" === tt.value;
    var ct, ft = A.expr.attrHandle;
    A.fn.extend({
        attr: function(e, t) {
            return U(this, A.attr, e, t, 1 < arguments.length);
        },
        removeAttr: function(e) {
            return this.each(function() {
                A.removeAttr(this, e);
            });
        }
    }), A.extend({
        attr: function(e, t, n) {
            var r, o, a = e.nodeType;
            if (3 !== a && 8 !== a && 2 !== a) return void 0 === e.getAttribute ? A.prop(e, t, n) : (1 === a && A.isXMLDoc(e) || (o = A.attrHooks[t.toLowerCase()] || (A.expr.match.bool.test(t) ? ct : void 0)), 
            void 0 !== n ? null === n ? void A.removeAttr(e, t) : o && "set" in o && void 0 !== (r = o.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), 
            n) : o && "get" in o && null !== (r = o.get(e, t)) ? r : null == (r = A.find.attr(e, t)) ? void 0 : r);
        },
        attrHooks: {
            type: {
                set: function(e, t) {
                    if (!v.radioValue && "radio" === t && I(e, "input")) {
                        var n = e.value;
                        return e.setAttribute("type", t), n && (e.value = n), t;
                    }
                }
            }
        },
        removeAttr: function(e, t) {
            var n, r = 0, o = t && t.match(V);
            if (o && 1 === e.nodeType) for (;n = o[r++]; ) e.removeAttribute(n);
        }
    }), ct = {
        set: function(e, t, n) {
            return !1 === t ? A.removeAttr(e, n) : e.setAttribute(n, n), n;
        }
    }, A.each(A.expr.match.bool.source.match(/\w+/g), function(e, t) {
        var i = ft[t] || A.find.attr;
        ft[t] = function(e, t, n) {
            var r, o, a = t.toLowerCase();
            return n || (o = ft[a], ft[a] = r, r = null != i(e, t, n) ? a : null, ft[a] = o), 
            r;
        };
    });
    var dt = /^(?:input|select|textarea|button)$/i, pt = /^(?:a|area)$/i;
    function mt(e) {
        return (e.match(V) || []).join(" ");
    }
    function gt(e) {
        return e.getAttribute && e.getAttribute("class") || "";
    }
    function ht(e) {
        return Array.isArray(e) ? e : "string" == typeof e && e.match(V) || [];
    }
    A.fn.extend({
        prop: function(e, t) {
            return U(this, A.prop, e, t, 1 < arguments.length);
        },
        removeProp: function(e) {
            return this.each(function() {
                delete this[A.propFix[e] || e];
            });
        }
    }), A.extend({
        prop: function(e, t, n) {
            var r, o, a = e.nodeType;
            if (3 !== a && 8 !== a && 2 !== a) return 1 === a && A.isXMLDoc(e) || (t = A.propFix[t] || t, 
            o = A.propHooks[t]), void 0 !== n ? o && "set" in o && void 0 !== (r = o.set(e, n, t)) ? r : e[t] = n : o && "get" in o && null !== (r = o.get(e, t)) ? r : e[t];
        },
        propHooks: {
            tabIndex: {
                get: function(e) {
                    var t = A.find.attr(e, "tabindex");
                    return t ? parseInt(t, 10) : dt.test(e.nodeName) || pt.test(e.nodeName) && e.href ? 0 : -1;
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    }), v.optSelected || (A.propHooks.selected = {
        get: function(e) {
            var t = e.parentNode;
            return t && t.parentNode && t.parentNode.selectedIndex, null;
        },
        set: function(e) {
            var t = e.parentNode;
            t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
        }
    }), A.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        A.propFix[this.toLowerCase()] = this;
    }), A.fn.extend({
        addClass: function(t) {
            var e, n, r, o, a, i, u, l = 0;
            if (y(t)) return this.each(function(e) {
                A(this).addClass(t.call(this, e, gt(this)));
            });
            if ((e = ht(t)).length) for (;n = this[l++]; ) if (o = gt(n), r = 1 === n.nodeType && " " + mt(o) + " ") {
                for (i = 0; a = e[i++]; ) r.indexOf(" " + a + " ") < 0 && (r += a + " ");
                o !== (u = mt(r)) && n.setAttribute("class", u);
            }
            return this;
        },
        removeClass: function(t) {
            var e, n, r, o, a, i, u, l = 0;
            if (y(t)) return this.each(function(e) {
                A(this).removeClass(t.call(this, e, gt(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            if ((e = ht(t)).length) for (;n = this[l++]; ) if (o = gt(n), r = 1 === n.nodeType && " " + mt(o) + " ") {
                for (i = 0; a = e[i++]; ) for (;-1 < r.indexOf(" " + a + " "); ) r = r.replace(" " + a + " ", " ");
                o !== (u = mt(r)) && n.setAttribute("class", u);
            }
            return this;
        },
        toggleClass: function(o, t) {
            var a = typeof o, i = "string" === a || Array.isArray(o);
            return "boolean" == typeof t && i ? t ? this.addClass(o) : this.removeClass(o) : y(o) ? this.each(function(e) {
                A(this).toggleClass(o.call(this, e, gt(this), t), t);
            }) : this.each(function() {
                var e, t, n, r;
                if (i) for (t = 0, n = A(this), r = ht(o); e = r[t++]; ) n.hasClass(e) ? n.removeClass(e) : n.addClass(e); else void 0 !== o && "boolean" !== a || ((e = gt(this)) && X.set(this, "__className__", e), 
                this.setAttribute && this.setAttribute("class", e || !1 === o ? "" : X.get(this, "__className__") || ""));
            });
        },
        hasClass: function(e) {
            var t, n, r = 0;
            for (t = " " + e + " "; n = this[r++]; ) if (1 === n.nodeType && -1 < (" " + mt(gt(n)) + " ").indexOf(t)) return !0;
            return !1;
        }
    });
    var vt = /\r/g;
    A.fn.extend({
        val: function(n) {
            var r, e, o, t = this[0];
            return arguments.length ? (o = y(n), this.each(function(e) {
                var t;
                1 === this.nodeType && (null == (t = o ? n.call(this, e, A(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = A.map(t, function(e) {
                    return null == e ? "" : e + "";
                })), (r = A.valHooks[this.type] || A.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t));
            })) : t ? (r = A.valHooks[t.type] || A.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(vt, "") : null == e ? "" : e : void 0;
        }
    }), A.extend({
        valHooks: {
            option: {
                get: function(e) {
                    var t = A.find.attr(e, "value");
                    return null != t ? t : mt(A.text(e));
                }
            },
            select: {
                get: function(e) {
                    var t, n, r, o = e.options, a = e.selectedIndex, i = "select-one" === e.type, u = i ? null : [], l = i ? a + 1 : o.length;
                    for (r = a < 0 ? l : i ? a : 0; r < l; r++) if (((n = o[r]).selected || r === a) && !n.disabled && (!n.parentNode.disabled || !I(n.parentNode, "optgroup"))) {
                        if (t = A(n).val(), i) return t;
                        u.push(t);
                    }
                    return u;
                },
                set: function(e, t) {
                    for (var n, r, o = e.options, a = A.makeArray(t), i = o.length; i--; ) ((r = o[i]).selected = -1 < A.inArray(A.valHooks.option.get(r), a)) && (n = !0);
                    return n || (e.selectedIndex = -1), a;
                }
            }
        }
    }), A.each([ "radio", "checkbox" ], function() {
        A.valHooks[this] = {
            set: function(e, t) {
                if (Array.isArray(t)) return e.checked = -1 < A.inArray(A(e).val(), t);
            }
        }, v.checkOn || (A.valHooks[this].get = function(e) {
            return null === e.getAttribute("value") ? "on" : e.value;
        });
    }), v.focusin = "onfocusin" in w;
    var yt = /^(?:focusinfocus|focusoutblur)$/, kt = function(e) {
        e.stopPropagation();
    };
    A.extend(A.event, {
        trigger: function(e, t, n, r) {
            var o, a, i, u, l, s, c, f, d = [ n || C ], p = h.call(e, "type") ? e.type : e, m = h.call(e, "namespace") ? e.namespace.split(".") : [];
            if (a = f = i = n = n || C, 3 !== n.nodeType && 8 !== n.nodeType && !yt.test(p + A.event.triggered) && (-1 < p.indexOf(".") && (p = (m = p.split(".")).shift(), 
            m.sort()), l = p.indexOf(":") < 0 && "on" + p, (e = e[A.expando] ? e : new A.Event(p, "object" == typeof e && e)).isTrigger = r ? 2 : 3, 
            e.namespace = m.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            e.result = void 0, e.target || (e.target = n), t = null == t ? [ e ] : A.makeArray(t, [ e ]), 
            c = A.event.special[p] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
                if (!r && !c.noBubble && !k(n)) {
                    for (u = c.delegateType || p, yt.test(u + p) || (a = a.parentNode); a; a = a.parentNode) d.push(a), 
                    i = a;
                    i === (n.ownerDocument || C) && d.push(i.defaultView || i.parentWindow || w);
                }
                for (o = 0; (a = d[o++]) && !e.isPropagationStopped(); ) f = a, e.type = 1 < o ? u : c.bindType || p, 
                (s = (X.get(a, "events") || {})[e.type] && X.get(a, "handle")) && s.apply(a, t), 
                (s = l && a[l]) && s.apply && K(a) && (e.result = s.apply(a, t), !1 === e.result && e.preventDefault());
                return e.type = p, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(d.pop(), t) || !K(n) || l && y(n[p]) && !k(n) && ((i = n[l]) && (n[l] = null), 
                A.event.triggered = p, e.isPropagationStopped() && f.addEventListener(p, kt), n[p](), 
                e.isPropagationStopped() && f.removeEventListener(p, kt), A.event.triggered = void 0, 
                i && (n[l] = i)), e.result;
            }
        },
        simulate: function(e, t, n) {
            var r = A.extend(new A.Event(), n, {
                type: e,
                isSimulated: !0
            });
            A.event.trigger(r, null, t);
        }
    }), A.fn.extend({
        trigger: function(e, t) {
            return this.each(function() {
                A.event.trigger(e, t, this);
            });
        },
        triggerHandler: function(e, t) {
            var n = this[0];
            if (n) return A.event.trigger(e, t, n, !0);
        }
    }), v.focusin || A.each({
        focus: "focusin",
        blur: "focusout"
    }, function(n, r) {
        var o = function(e) {
            A.event.simulate(r, e.target, A.event.fix(e));
        };
        A.event.special[r] = {
            setup: function() {
                var e = this.ownerDocument || this, t = X.access(e, r);
                t || e.addEventListener(n, o, !0), X.access(e, r, (t || 0) + 1);
            },
            teardown: function() {
                var e = this.ownerDocument || this, t = X.access(e, r) - 1;
                t ? X.access(e, r, t) : (e.removeEventListener(n, o, !0), X.remove(e, r));
            }
        };
    });
    var bt = w.location, xt = Date.now(), St = /\?/;
    A.parseXML = function(e) {
        var t;
        if (!e || "string" != typeof e) return null;
        try {
            t = new w.DOMParser().parseFromString(e, "text/xml");
        } catch (e) {
            t = void 0;
        }
        return t && !t.getElementsByTagName("parsererror").length || A.error("Invalid XML: " + e), 
        t;
    };
    var wt = /\[\]$/, Ct = /\r?\n/g, At = /^(?:submit|button|image|reset|file)$/i, Nt = /^(?:input|select|textarea|keygen)/i;
    function Tt(n, e, r, o) {
        var t;
        if (Array.isArray(e)) A.each(e, function(e, t) {
            r || wt.test(n) ? o(n, t) : Tt(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, o);
        }); else if (r || "object" !== x(e)) o(n, e); else for (t in e) Tt(n + "[" + t + "]", e[t], r, o);
    }
    A.param = function(e, t) {
        var n, r = [], o = function(e, t) {
            var n = y(t) ? t() : t;
            r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
        };
        if (Array.isArray(e) || e.jquery && !A.isPlainObject(e)) A.each(e, function() {
            o(this.name, this.value);
        }); else for (n in e) Tt(n, e[n], t, o);
        return r.join("&");
    }, A.fn.extend({
        serialize: function() {
            return A.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var e = A.prop(this, "elements");
                return e ? A.makeArray(e) : this;
            }).filter(function() {
                var e = this.type;
                return this.name && !A(this).is(":disabled") && Nt.test(this.nodeName) && !At.test(e) && (this.checked || !se.test(e));
            }).map(function(e, t) {
                var n = A(this).val();
                return null == n ? null : Array.isArray(n) ? A.map(n, function(e) {
                    return {
                        name: t.name,
                        value: e.replace(Ct, "\r\n")
                    };
                }) : {
                    name: t.name,
                    value: n.replace(Ct, "\r\n")
                };
            }).get();
        }
    });
    var It = /%20/g, Mt = /#.*$/, Pt = /([?&])_=[^&]*/, Ot = /^(.*?):[ \t]*([^\r\n]*)$/gm, Dt = /^(?:GET|HEAD)$/, Lt = /^\/\//, Et = {}, Rt = {}, Vt = "*/".concat("*"), Ft = C.createElement("a");
    function Bt(a) {
        return function(e, t) {
            "string" != typeof e && (t = e, e = "*");
            var n, r = 0, o = e.toLowerCase().match(V) || [];
            if (y(t)) for (;n = o[r++]; ) "+" === n[0] ? (n = n.slice(1) || "*", (a[n] = a[n] || []).unshift(t)) : (a[n] = a[n] || []).push(t);
        };
    }
    function qt(t, o, a, i) {
        var u = {}, l = t === Rt;
        function s(e) {
            var r;
            return u[e] = !0, A.each(t[e] || [], function(e, t) {
                var n = t(o, a, i);
                return "string" != typeof n || l || u[n] ? l ? !(r = n) : void 0 : (o.dataTypes.unshift(n), 
                s(n), !1);
            }), r;
        }
        return s(o.dataTypes[0]) || !u["*"] && s("*");
    }
    function _t(e, t) {
        var n, r, o = A.ajaxSettings.flatOptions || {};
        for (n in t) void 0 !== t[n] && ((o[n] ? e : r || (r = {}))[n] = t[n]);
        return r && A.extend(!0, e, r), e;
    }
    Ft.href = bt.href, A.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: bt.href,
            type: "GET",
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Vt,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": A.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(e, t) {
            return t ? _t(_t(e, A.ajaxSettings), t) : _t(A.ajaxSettings, e);
        },
        ajaxPrefilter: Bt(Et),
        ajaxTransport: Bt(Rt),
        ajax: function(e, t) {
            "object" == typeof e && (t = e, e = void 0), t = t || {};
            var c, f, d, n, p, r, m, g, o, a, h = A.ajaxSetup({}, t), v = h.context || h, y = h.context && (v.nodeType || v.jquery) ? A(v) : A.event, k = A.Deferred(), b = A.Callbacks("once memory"), x = h.statusCode || {}, i = {}, u = {}, l = "canceled", S = {
                readyState: 0,
                getResponseHeader: function(e) {
                    var t;
                    if (m) {
                        if (!n) for (n = {}; t = Ot.exec(d); ) n[t[1].toLowerCase()] = t[2];
                        t = n[e.toLowerCase()];
                    }
                    return null == t ? null : t;
                },
                getAllResponseHeaders: function() {
                    return m ? d : null;
                },
                setRequestHeader: function(e, t) {
                    return null == m && (e = u[e.toLowerCase()] = u[e.toLowerCase()] || e, i[e] = t), 
                    this;
                },
                overrideMimeType: function(e) {
                    return null == m && (h.mimeType = e), this;
                },
                statusCode: function(e) {
                    var t;
                    if (e) if (m) S.always(e[S.status]); else for (t in e) x[t] = [ x[t], e[t] ];
                    return this;
                },
                abort: function(e) {
                    var t = e || l;
                    return c && c.abort(t), s(0, t), this;
                }
            };
            if (k.promise(S), h.url = ((e || h.url || bt.href) + "").replace(Lt, bt.protocol + "//"), 
            h.type = t.method || t.type || h.method || h.type, h.dataTypes = (h.dataType || "*").toLowerCase().match(V) || [ "" ], 
            null == h.crossDomain) {
                r = C.createElement("a");
                try {
                    r.href = h.url, r.href = r.href, h.crossDomain = Ft.protocol + "//" + Ft.host != r.protocol + "//" + r.host;
                } catch (e) {
                    h.crossDomain = !0;
                }
            }
            if (h.data && h.processData && "string" != typeof h.data && (h.data = A.param(h.data, h.traditional)), 
            qt(Et, h, t, S), m) return S;
            for (o in (g = A.event && h.global) && 0 == A.active++ && A.event.trigger("ajaxStart"), 
            h.type = h.type.toUpperCase(), h.hasContent = !Dt.test(h.type), f = h.url.replace(Mt, ""), 
            h.hasContent ? h.data && h.processData && 0 === (h.contentType || "").indexOf("application/x-www-form-urlencoded") && (h.data = h.data.replace(It, "+")) : (a = h.url.slice(f.length), 
            h.data && (h.processData || "string" == typeof h.data) && (f += (St.test(f) ? "&" : "?") + h.data, 
            delete h.data), !1 === h.cache && (f = f.replace(Pt, "$1"), a = (St.test(f) ? "&" : "?") + "_=" + xt++ + a), 
            h.url = f + a), h.ifModified && (A.lastModified[f] && S.setRequestHeader("If-Modified-Since", A.lastModified[f]), 
            A.etag[f] && S.setRequestHeader("If-None-Match", A.etag[f])), (h.data && h.hasContent && !1 !== h.contentType || t.contentType) && S.setRequestHeader("Content-Type", h.contentType), 
            S.setRequestHeader("Accept", h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + ("*" !== h.dataTypes[0] ? ", " + Vt + "; q=0.01" : "") : h.accepts["*"]), 
            h.headers) S.setRequestHeader(o, h.headers[o]);
            if (h.beforeSend && (!1 === h.beforeSend.call(v, S, h) || m)) return S.abort();
            if (l = "abort", b.add(h.complete), S.done(h.success), S.fail(h.error), c = qt(Rt, h, t, S)) {
                if (S.readyState = 1, g && y.trigger("ajaxSend", [ S, h ]), m) return S;
                h.async && 0 < h.timeout && (p = w.setTimeout(function() {
                    S.abort("timeout");
                }, h.timeout));
                try {
                    m = !1, c.send(i, s);
                } catch (e) {
                    if (m) throw e;
                    s(-1, e);
                }
            } else s(-1, "No Transport");
            function s(e, t, n, r) {
                var o, a, i, u, l, s = t;
                m || (m = !0, p && w.clearTimeout(p), c = void 0, d = r || "", S.readyState = 0 < e ? 4 : 0, 
                o = 200 <= e && e < 300 || 304 === e, n && (u = function(e, t, n) {
                    for (var r, o, a, i, u = e.contents, l = e.dataTypes; "*" === l[0]; ) l.shift(), 
                    void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
                    if (r) for (o in u) if (u[o] && u[o].test(r)) {
                        l.unshift(o);
                        break;
                    }
                    if (l[0] in n) a = l[0]; else {
                        for (o in n) {
                            if (!l[0] || e.converters[o + " " + l[0]]) {
                                a = o;
                                break;
                            }
                            i || (i = o);
                        }
                        a = a || i;
                    }
                    if (a) return a !== l[0] && l.unshift(a), n[a];
                }(h, S, n)), u = function(e, t, n, r) {
                    var o, a, i, u, l, s = {}, c = e.dataTypes.slice();
                    if (c[1]) for (i in e.converters) s[i.toLowerCase()] = e.converters[i];
                    for (a = c.shift(); a; ) if (e.responseFields[a] && (n[e.responseFields[a]] = t), 
                    !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = a, a = c.shift()) if ("*" === a) a = l; else if ("*" !== l && l !== a) {
                        if (!(i = s[l + " " + a] || s["* " + a])) for (o in s) if ((u = o.split(" "))[1] === a && (i = s[l + " " + u[0]] || s["* " + u[0]])) {
                            !0 === i ? i = s[o] : !0 !== s[o] && (a = u[0], c.unshift(u[1]));
                            break;
                        }
                        if (!0 !== i) if (i && e.throws) t = i(t); else try {
                            t = i(t);
                        } catch (e) {
                            return {
                                state: "parsererror",
                                error: i ? e : "No conversion from " + l + " to " + a
                            };
                        }
                    }
                    return {
                        state: "success",
                        data: t
                    };
                }(h, u, S, o), o ? (h.ifModified && ((l = S.getResponseHeader("Last-Modified")) && (A.lastModified[f] = l), 
                (l = S.getResponseHeader("etag")) && (A.etag[f] = l)), 204 === e || "HEAD" === h.type ? s = "nocontent" : 304 === e ? s = "notmodified" : (s = u.state, 
                a = u.data, o = !(i = u.error))) : (i = s, !e && s || (s = "error", e < 0 && (e = 0))), 
                S.status = e, S.statusText = (t || s) + "", o ? k.resolveWith(v, [ a, s, S ]) : k.rejectWith(v, [ S, s, i ]), 
                S.statusCode(x), x = void 0, g && y.trigger(o ? "ajaxSuccess" : "ajaxError", [ S, h, o ? a : i ]), 
                b.fireWith(v, [ S, s ]), g && (y.trigger("ajaxComplete", [ S, h ]), --A.active || A.event.trigger("ajaxStop")));
            }
            return S;
        },
        getJSON: function(e, t, n) {
            return A.get(e, t, n, "json");
        },
        getScript: function(e, t) {
            return A.get(e, void 0, t, "script");
        }
    }), A.each([ "get", "post" ], function(e, o) {
        A[o] = function(e, t, n, r) {
            return y(t) && (r = r || n, n = t, t = void 0), A.ajax(A.extend({
                url: e,
                type: o,
                dataType: r,
                data: t,
                success: n
            }, A.isPlainObject(e) && e));
        };
    }), A._evalUrl = function(e) {
        return A.ajax({
            url: e,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            throws: !0
        });
    }, A.fn.extend({
        wrapAll: function(e) {
            var t;
            return this[0] && (y(e) && (e = e.call(this[0])), t = A(e, this[0].ownerDocument).eq(0).clone(!0), 
            this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                for (var e = this; e.firstElementChild; ) e = e.firstElementChild;
                return e;
            }).append(this)), this;
        },
        wrapInner: function(n) {
            return y(n) ? this.each(function(e) {
                A(this).wrapInner(n.call(this, e));
            }) : this.each(function() {
                var e = A(this), t = e.contents();
                t.length ? t.wrapAll(n) : e.append(n);
            });
        },
        wrap: function(t) {
            var n = y(t);
            return this.each(function(e) {
                A(this).wrapAll(n ? t.call(this, e) : t);
            });
        },
        unwrap: function(e) {
            return this.parent(e).not("body").each(function() {
                A(this).replaceWith(this.childNodes);
            }), this;
        }
    }), A.expr.pseudos.hidden = function(e) {
        return !A.expr.pseudos.visible(e);
    }, A.expr.pseudos.visible = function(e) {
        return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
    }, A.ajaxSettings.xhr = function() {
        try {
            return new w.XMLHttpRequest();
        } catch (e) {}
    };
    var Gt = {
        0: 200,
        1223: 204
    }, jt = A.ajaxSettings.xhr();
    v.cors = !!jt && "withCredentials" in jt, v.ajax = jt = !!jt, A.ajaxTransport(function(o) {
        var a, i;
        if (v.cors || jt && !o.crossDomain) return {
            send: function(e, t) {
                var n, r = o.xhr();
                if (r.open(o.type, o.url, o.async, o.username, o.password), o.xhrFields) for (n in o.xhrFields) r[n] = o.xhrFields[n];
                for (n in o.mimeType && r.overrideMimeType && r.overrideMimeType(o.mimeType), o.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), 
                e) r.setRequestHeader(n, e[n]);
                a = function(e) {
                    return function() {
                        a && (a = i = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, 
                        "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Gt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
                            binary: r.response
                        } : {
                            text: r.responseText
                        }, r.getAllResponseHeaders()));
                    };
                }, r.onload = a(), i = r.onerror = r.ontimeout = a("error"), void 0 !== r.onabort ? r.onabort = i : r.onreadystatechange = function() {
                    4 === r.readyState && w.setTimeout(function() {
                        a && i();
                    });
                }, a = a("abort");
                try {
                    r.send(o.hasContent && o.data || null);
                } catch (e) {
                    if (a) throw e;
                }
            },
            abort: function() {
                a && a();
            }
        };
    }), A.ajaxPrefilter(function(e) {
        e.crossDomain && (e.contents.script = !1);
    }), A.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(e) {
                return A.globalEval(e), e;
            }
        }
    }), A.ajaxPrefilter("script", function(e) {
        void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");
    }), A.ajaxTransport("script", function(n) {
        var r, o;
        if (n.crossDomain) return {
            send: function(e, t) {
                r = A("<script>").prop({
                    charset: n.scriptCharset,
                    src: n.url
                }).on("load error", o = function(e) {
                    r.remove(), o = null, e && t("error" === e.type ? 404 : 200, e.type);
                }), C.head.appendChild(r[0]);
            },
            abort: function() {
                o && o();
            }
        };
    });
    var Ut, Ht = [], Wt = /(=)\?(?=&|$)|\?\?/;
    A.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var e = Ht.pop() || A.expando + "_" + xt++;
            return this[e] = !0, e;
        }
    }), A.ajaxPrefilter("json jsonp", function(e, t, n) {
        var r, o, a, i = !1 !== e.jsonp && (Wt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Wt.test(e.data) && "data");
        if (i || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = y(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, 
        i ? e[i] = e[i].replace(Wt, "$1" + r) : !1 !== e.jsonp && (e.url += (St.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), 
        e.converters["script json"] = function() {
            return a || A.error(r + " was not called"), a[0];
        }, e.dataTypes[0] = "json", o = w[r], w[r] = function() {
            a = arguments;
        }, n.always(function() {
            void 0 === o ? A(w).removeProp(r) : w[r] = o, e[r] && (e.jsonpCallback = t.jsonpCallback, 
            Ht.push(r)), a && y(o) && o(a[0]), a = o = void 0;
        }), "script";
    }), v.createHTMLDocument = ((Ut = C.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 
    2 === Ut.childNodes.length), A.parseHTML = function(e, t, n) {
        return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (v.createHTMLDocument ? ((r = (t = C.implementation.createHTMLDocument("")).createElement("base")).href = C.location.href, 
        t.head.appendChild(r)) : t = C), a = !n && [], (o = M.exec(e)) ? [ t.createElement(o[1]) ] : (o = ye([ e ], t, a), 
        a && a.length && A(a).remove(), A.merge([], o.childNodes)));
        var r, o, a;
    }, A.fn.load = function(e, t, n) {
        var r, o, a, i = this, u = e.indexOf(" ");
        return -1 < u && (r = mt(e.slice(u)), e = e.slice(0, u)), y(t) ? (n = t, t = void 0) : t && "object" == typeof t && (o = "POST"), 
        0 < i.length && A.ajax({
            url: e,
            type: o || "GET",
            dataType: "html",
            data: t
        }).done(function(e) {
            a = arguments, i.html(r ? A("<div>").append(A.parseHTML(e)).find(r) : e);
        }).always(n && function(e, t) {
            i.each(function() {
                n.apply(this, a || [ e.responseText, t, e ]);
            });
        }), this;
    }, A.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(e, t) {
        A.fn[t] = function(e) {
            return this.on(t, e);
        };
    }), A.expr.pseudos.animated = function(t) {
        return A.grep(A.timers, function(e) {
            return t === e.elem;
        }).length;
    }, A.offset = {
        setOffset: function(e, t, n) {
            var r, o, a, i, u, l, s = A.css(e, "position"), c = A(e), f = {};
            "static" === s && (e.style.position = "relative"), u = c.offset(), a = A.css(e, "top"), 
            l = A.css(e, "left"), ("absolute" === s || "fixed" === s) && -1 < (a + l).indexOf("auto") ? (i = (r = c.position()).top, 
            o = r.left) : (i = parseFloat(a) || 0, o = parseFloat(l) || 0), y(t) && (t = t.call(e, n, A.extend({}, u))), 
            null != t.top && (f.top = t.top - u.top + i), null != t.left && (f.left = t.left - u.left + o), 
            "using" in t ? t.using.call(e, f) : c.css(f);
        }
    }, A.fn.extend({
        offset: function(t) {
            if (arguments.length) return void 0 === t ? this : this.each(function(e) {
                A.offset.setOffset(this, t, e);
            });
            var e, n, r = this[0];
            return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, 
            {
                top: e.top + n.pageYOffset,
                left: e.left + n.pageXOffset
            }) : {
                top: 0,
                left: 0
            } : void 0;
        },
        position: function() {
            if (this[0]) {
                var e, t, n, r = this[0], o = {
                    top: 0,
                    left: 0
                };
                if ("fixed" === A.css(r, "position")) t = r.getBoundingClientRect(); else {
                    for (t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === A.css(e, "position"); ) e = e.parentNode;
                    e && e !== r && 1 === e.nodeType && ((o = A(e).offset()).top += A.css(e, "borderTopWidth", !0), 
                    o.left += A.css(e, "borderLeftWidth", !0));
                }
                return {
                    top: t.top - o.top - A.css(r, "marginTop", !0),
                    left: t.left - o.left - A.css(r, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var e = this.offsetParent; e && "static" === A.css(e, "position"); ) e = e.offsetParent;
                return e || ke;
            });
        }
    }), A.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(t, o) {
        var a = "pageYOffset" === o;
        A.fn[t] = function(e) {
            return U(this, function(e, t, n) {
                var r;
                if (k(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[o] : e[t];
                r ? r.scrollTo(a ? r.pageXOffset : n, a ? n : r.pageYOffset) : e[t] = n;
            }, t, e, arguments.length);
        };
    }), A.each([ "top", "left" ], function(e, n) {
        A.cssHooks[n] = Ge(v.pixelPosition, function(e, t) {
            if (t) return t = _e(e, n), Fe.test(t) ? A(e).position()[n] + "px" : t;
        });
    }), A.each({
        Height: "height",
        Width: "width"
    }, function(i, u) {
        A.each({
            padding: "inner" + i,
            content: u,
            "": "outer" + i
        }, function(r, a) {
            A.fn[a] = function(e, t) {
                var n = arguments.length && (r || "boolean" != typeof e), o = r || (!0 === e || !0 === t ? "margin" : "border");
                return U(this, function(e, t, n) {
                    var r;
                    return k(e) ? 0 === a.indexOf("outer") ? e["inner" + i] : e.document.documentElement["client" + i] : 9 === e.nodeType ? (r = e.documentElement, 
                    Math.max(e.body["scroll" + i], r["scroll" + i], e.body["offset" + i], r["offset" + i], r["client" + i])) : void 0 === n ? A.css(e, t, o) : A.style(e, t, n, o);
                }, u, n ? e : void 0, n);
            };
        });
    }), A.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, n) {
        A.fn[n] = function(e, t) {
            return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n);
        };
    }), A.fn.extend({
        hover: function(e, t) {
            return this.mouseenter(e).mouseleave(t || e);
        }
    }), A.fn.extend({
        bind: function(e, t, n) {
            return this.on(e, null, t, n);
        },
        unbind: function(e, t) {
            return this.off(e, null, t);
        },
        delegate: function(e, t, n, r) {
            return this.on(t, e, n, r);
        },
        undelegate: function(e, t, n) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
        }
    }), A.proxy = function(e, t) {
        var n, r, o;
        if ("string" == typeof t && (n = e[t], t = e, e = n), y(e)) return r = u.call(arguments, 2), 
        (o = function() {
            return e.apply(t || this, r.concat(u.call(arguments)));
        }).guid = e.guid = e.guid || A.guid++, o;
    }, A.holdReady = function(e) {
        e ? A.readyWait++ : A.ready(!0);
    }, A.isArray = Array.isArray, A.parseJSON = JSON.parse, A.nodeName = I, A.isFunction = y, 
    A.isWindow = k, A.camelCase = $, A.type = x, A.now = Date.now, A.isNumeric = function(e) {
        var t = A.type(e);
        return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
    }, "function" == typeof define && define.amd && define("jquery", [], function() {
        return A;
    });
    var zt = w.jQuery, $t = w.$;
    return A.noConflict = function(e) {
        return w.$ === A && (w.$ = $t), e && w.jQuery === A && (w.jQuery = zt), A;
    }, e || (w.jQuery = w.$ = A), A;
});

var fluid_3_0_0 = fluid_3_0_0 || {}, fluid = fluid || fluid_3_0_0;

!function(y, k) {
    "use strict";
    k.version = "Infusion 3.0.0", k.Error = Error, k.environment = {
        fluid: k
    }, k.global = k.global || "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}, 
    k.invokeLater = function(e) {
        return setTimeout(e, 1);
    }, k.defeatLogging = !0, k.activityTracing = !1, k.activityTrace = [];
    var u = /(%\w+)/g;
    function o(e, t, n, r) {
        for (var o = e[n], a = 0; a < r.length - 1; ++a) o = r[a + 1](o, n);
        t[n] = o;
    }
    k.renderOneActivity = function(e, t) {
        for (var n = !0 === t ? [] : [ "    while " ], r = e.message, o = u.lastIndex = 0; ;) {
            var a = u.exec(r);
            if (!a) break;
            var i = a[1].substring(1);
            n.push(r.substring(o, a.index)), n.push(e.args[i]), o = u.lastIndex;
        }
        return o < r.length && n.push(r.substring(o)), n;
    }, k.renderActivity = function(e, t) {
        return t = t || k.renderOneActivity, k.transform(e, t);
    }, k.singleThreadLocal = function(e) {
        var t = e();
        return function(e) {
            return void 0 === e ? t : t = e;
        };
    }, k.threadLocal = k.singleThreadLocal, k.globalThreadLocal = k.threadLocal(function() {
        return {};
    }), k.getActivityStack = function() {
        var e = k.globalThreadLocal();
        return e.activityStack || (e.activityStack = []), e.activityStack;
    }, k.describeActivity = k.getActivityStack, k.logActivity = function(e) {
        e = e || k.describeActivity();
        var t = k.renderActivity(e).reverse();
        k.log("Current activity: "), k.each(t, function(e) {
            k.doLog(e);
        });
    }, k.pushActivity = function(e, t, n) {
        var r = {
            type: e,
            message: t,
            args: n,
            time: new Date().getTime()
        };
        k.activityTracing && k.activityTrace.push(r), k.passLogLevel(k.logLevel.TRACE) && k.doLog(k.renderOneActivity(r, !0)), 
        k.getActivityStack().push(r);
    }, k.popActivity = function(e) {
        e = e || 1, k.activityTracing && k.activityTrace.push({
            pop: e
        });
        var t = k.getActivityStack(), n = t.length - e;
        t.length = n < 0 ? 0 : n;
    }, k.FluidError = function() {
        var e = Error.apply(this, arguments);
        this.message = e.message;
        try {
            throw e;
        } catch (e) {
            this.stack = e.stack;
        }
        return this;
    }, k.FluidError.prototype = Object.create(Error.prototype), k.logFailure = function(e, t) {
        k.log.apply(null, [ k.logLevel.FAIL, "ASSERTION FAILED: " ].concat(e)), k.logActivity(t);
    }, k.renderLoggingArg = function(e) {
        return void 0 === e ? "undefined" : k.isPrimitive(e) || !k.isPlainObject(e) ? e : JSON.stringify(e);
    }, k.builtinFail = function(e) {
        var t = k.transform(e, k.renderLoggingArg).join("");
        throw new k.FluidError("Assertion failure - check console for more details: " + t);
    }, k.fail = function() {
        var e = k.makeArray(arguments), t = k.makeArray(k.describeActivity());
        k.popActivity(t.length), k.failureEvent ? k.failureEvent.fire(e, t) : (k.logFailure(e, t), 
        k.builtinFail(e, t));
    }, k.expect = function(t, n, e) {
        k.transform(k.makeArray(e), function(e) {
            void 0 === n[e] && k.fail(t + " missing required parameter " + e);
        });
    }, k.isLogging = function() {
        return n[0].priority > k.logLevel.IMPORTANT.priority;
    }, k.isLogLevel = function(e) {
        return k.isMarker(e) && void 0 !== e.priority;
    }, k.passLogLevel = function(e) {
        return e.priority <= n[0].priority;
    }, k.setLogging = function(e) {
        var t;
        "boolean" == typeof e ? t = k.logLevel[e ? "INFO" : "IMPORTANT"] : k.isLogLevel(e) ? t = e : k.fail("Unrecognised fluid logging level ", e), 
        n.unshift(t), k.defeatLogging = !k.isLogging();
    }, k.setLogLevel = k.setLogging, k.popLogging = function() {
        var e = 1 === n.length ? n[0] : n.shift();
        return k.defeatLogging = !k.isLogging(), e;
    }, k.doLog = function(e) {
        "undefined" != typeof console && (console.debug ? console.debug.apply(console, e) : "function" == typeof console.log && console.log.apply(console, e));
    }, k.log = function() {
        var e = k.makeArray(arguments), t = k.logLevel.INFO;
        if (k.isLogLevel(e[0]) && (t = e.shift()), k.passLogLevel(t)) {
            var n = [ k.renderTimestamp(new Date()) + ":  " ].concat(e);
            k.doLog(n);
        }
    }, k.isValue = function(e) {
        return null != e;
    }, k.isPrimitive = function(e) {
        var t = typeof e;
        return !e || "string" === t || "boolean" === t || "number" === t || "function" === t;
    }, k.isArrayable = function(e) {
        return e && (e.jquery || "[object Array]" === Object.prototype.toString.call(e));
    }, k.isPlainObject = function(e, t) {
        var n = Object.prototype.toString.call(e);
        return "[object Array]" === n ? !t : "[object Object]" === n && (!e.constructor || !e.constructor.prototype || Object.prototype.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf"));
    }, k.typeCode = function(e) {
        return k.isPrimitive(e) || !k.isPlainObject(e) ? "primitive" : k.isArrayable(e) ? "array" : "object";
    }, k.isIoCReference = function(e) {
        return "string" == typeof e && "{" === e.charAt(0) && 0 < e.indexOf("}");
    }, k.isDOMNode = function(e) {
        return e && "number" == typeof e.nodeType;
    }, k.isComponent = function(e) {
        return e && e.constructor === k.componentConstructor;
    }, k.isUncopyable = function(e) {
        return k.isPrimitive(e) || !k.isPlainObject(e);
    }, k.isApplicable = function(e) {
        return e.apply && "function" == typeof e.apply;
    }, k.identity = function(e) {
        return e;
    }, k.notImplemented = function() {
        k.fail("This operation is not implemented");
    }, k.firstDefined = function(e, t) {
        return void 0 === e ? t : e;
    }, k.freshContainer = function(e) {
        return k.isArrayable(e) ? [] : {};
    }, k.copyRecurse = function(e, r) {
        return r.length > k.strategyRecursionBailout && k.fail("Runaway recursion encountered in fluid.copy - reached path depth of " + k.strategyRecursionBailout + " via path of " + r.join(".") + "this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout"), 
        k.isUncopyable(e) ? e : k.transform(e, function(e, t) {
            r.push(t);
            var n = k.copyRecurse(e, r);
            return r.pop(), n;
        });
    }, k.copy = function(e) {
        return k.copyRecurse(e, []);
    }, k.extend = y.extend, k.makeArray = function(e) {
        var t = [];
        if (null != e) if (k.isPrimitive(e) || k.isPlainObject(e, !0) || "number" != typeof e.length) t.push(e); else for (var n = 0; n < e.length; ++n) t[n] = e[n];
        return t;
    }, k.pushArray = function(e, t, n) {
        var r = e[t] ? e[t] : e[t] = [];
        k.isArrayable(n) ? r.push.apply(r, n) : r.push(n);
    }, k.transform = function(e) {
        if (k.isPrimitive(e)) return e;
        var t = k.freshContainer(e);
        if (k.isArrayable(e)) for (var n = 0; n < e.length; ++n) o(e, t, n, arguments); else for (var r in e) o(e, t, r, arguments);
        return t;
    }, k.each = function(e, t) {
        if (k.isArrayable(e)) for (var n = 0; n < e.length; ++n) t(e[n], n); else for (var r in e) t(e[r], r);
    }, k.make_find = function(i) {
        var u = !i && void 0;
        return function(e, t, n) {
            var r;
            if (k.isArrayable(e)) {
                for (var o = 0; o < e.length; ++o) if ((r = t(e[o], o)) !== u) return i ? e[o] : r;
            } else for (var a in e) if ((r = t(e[a], a)) !== u) return i ? e[a] : r;
            return n;
        };
    }, k.find = k.make_find(!1), k.find_if = k.make_find(!0), k.accumulate = function(e, t, n) {
        for (var r = 0; r < e.length; ++r) n = t(e[r], n, r);
        return n;
    }, k.add = function(e, t) {
        return e + t;
    }, k.remove_if = function(e, t, n) {
        if (k.isArrayable(e)) for (var r = e.length - 1; 0 <= r; --r) t(e[r], r) && (n && n.unshift(e[r]), 
        e.splice(r, 1)); else for (var o in e) t(e[o], o) && (n && (n[o] = e[o]), delete e[o]);
        return n || e;
    }, k.generate = function(e, t, n) {
        for (var r = [], o = 0; o < e; ++o) r[o] = n ? t(o) : t;
        return r;
    }, k.iota = function(e, t) {
        t = t || 0;
        for (var n = [], r = 0; r < e; ++r) n[n.length] = t++;
        return n;
    }, k.getMembers = function(e, t) {
        return k.transform(e, function(e) {
            return k.get(e, t);
        });
    }, k.filterKeys = function(e, n, r) {
        return k.remove_if(y.extend({}, e), function(e, t) {
            return r ^ -1 === n.indexOf(t);
        });
    }, k.censorKeys = function(e, t) {
        return k.filterKeys(e, t, !0);
    }, k.keys = function(e) {
        var t = [];
        for (var n in e) t.push(n);
        return t;
    }, k.values = function(e) {
        var t = [];
        for (var n in e) t.push(e[n]);
        return t;
    }, k.contains = function(e, t) {
        return e ? k.isArrayable(e) ? -1 !== e.indexOf(t) : k.find(e, function(e) {
            if (t === e) return !0;
        }) : void 0;
    }, k.keyForValue = function(e, n) {
        return k.find(e, function(e, t) {
            if (n === e) return t;
        });
    }, k.arrayToHash = function(e) {
        var t = {};
        return k.each(e, function(e) {
            t[e] = !0;
        }), t;
    }, k.stableSort = function(e, t) {
        for (var n = 0; n < e.length; n++) {
            var r, o = e[n];
            for (r = n; 0 < r && t(o, e[r - 1]) < 0; r--) e[r] = e[r - 1];
            e[r] = o;
        }
    }, k.hashToArray = function(e, r, o) {
        var a = [];
        return k.each(e, function(e, t) {
            var n = {};
            n[r] = t, o ? n = o(n, e, t) || n : y.extend(!0, n, e), a.push(n);
        }), a;
    }, k.flatten = function(e) {
        var t = [];
        return k.each(e, function(e) {
            k.isArrayable(e) ? t = t.concat(e) : t.push(e);
        }), t;
    }, k.clear = function(e) {
        if (k.isArrayable(e)) e.length = 0; else for (var t in e) delete e[t];
    }, k.compareStringLength = function(e) {
        return e ? function(e, t) {
            return e.length - t.length;
        } : function(e, t) {
            return t.length - e.length;
        };
    }, k.parseInteger = function(e) {
        return isFinite(e) && e % 1 == 0 ? Number(e) : NaN;
    }, k.roundToDecimal = function(e, t, n) {
        return t = t && 0 <= t ? Math.round(t) : 0, "ceil" === n || "floor" === n ? Number(Math[n](e + "e" + t) + "e-" + t) : Number((0 <= e ? 1 : -1) * (Math.round(Math.abs(e) + "e" + t) + "e-" + t));
    }, k.debounce = function(r, o, a) {
        var i, u;
        return function() {
            var e = this, t = arguments, n = a && !i;
            return clearTimeout(i), i = setTimeout(function() {
                i = null, a || (u = r.apply(e, t));
            }, o), n && (u = r.apply(e, t)), u;
        };
    }, k.freezeRecursive = function(e) {
        return k.isPlainObject(e) ? (k.each(e, function(e) {
            k.freezeRecursive(e);
        }), Object.freeze(e)) : e;
    }, k.marker = function() {}, k.makeMarker = function(e, t) {
        var n = Object.create(k.marker.prototype);
        return n.value = e, y.extend(n, t), Object.freeze(n);
    }, k.VALUE = k.makeMarker("VALUE"), k.NO_VALUE = k.makeMarker("NO_VALUE"), k.EXPAND = k.makeMarker("EXPAND"), 
    k.isMarker = function(e, t) {
        return e instanceof k.marker && (!t || e.value === t.value);
    }, k.logLevelsSpec = {
        FATAL: 0,
        FAIL: 5,
        WARN: 10,
        IMPORTANT: 12,
        INFO: 15,
        TRACE: 20
    }, k.logLevel = k.transform(k.logLevelsSpec, function(e, t) {
        return k.makeMarker(t, {
            priority: e
        });
    });
    var n = [ k.logLevel.IMPORTANT ];
    k.model = {}, k.model.copyModel = function(e, t) {
        k.clear(e), y.extend(!0, e, t);
    }, k.model.parseEL = function(e) {
        return "" === e ? [] : String(e).split(".");
    }, k.model.composePath = function(e, t) {
        return "" === e ? t : "" === t ? e : e + "." + t;
    }, k.model.composeSegments = function() {
        return k.makeArray(arguments).join(".");
    }, k.lastDotIndex = function(e) {
        return e.lastIndexOf(".");
    }, k.model.getToTailPath = function(e) {
        var t = k.lastDotIndex(e);
        return -1 === t ? "" : e.substring(0, t);
    }, k.model.getTailPath = function(e) {
        var t = k.lastDotIndex(e);
        return e.substring(t + 1);
    }, k.path = k.model.composeSegments, k.composePath = k.model.composePath, k.requireDataBinding = function() {
        k.fail("Please include DataBinding.js in order to operate complex model accessor configuration");
    }, k.model.setWithStrategy = k.model.getWithStrategy = k.requireDataBinding, k.model.resolvePathSegment = function(e, t, n, r) {
        if (!r && e.resolvePathSegment) {
            var o = e.resolvePathSegment(t);
            if (void 0 !== o) return o;
        }
        return n && void 0 === e[t] ? e[t] = {} : e[t];
    }, k.model.parseToSegments = function(e, t, n) {
        return "number" == typeof e || "string" == typeof e ? t(e) : n ? k.makeArray(e) : e;
    }, k.model.pathToSegments = function(e, t) {
        var n = t && t.parser ? t.parser.parse : k.model.parseEL;
        return k.model.parseToSegments(e, n);
    }, k.model.accessImpl = function(e, t, n, r, o, a, i) {
        var u = k.model.pathToSegments(t, r), l = 0;
        if (o && (l = o.length, u = o.concat(u)), e = i(e, u, l, r, n === k.NO_VALUE ? 0 : 1), 
        n === k.NO_VALUE || n === k.VALUE) return a ? {
            root: e,
            segs: u
        } : e;
        e[u[u.length - 1]] = n;
    }, k.model.accessSimple = function(e, t, n, r, o, a) {
        return k.model.accessImpl(e, t, n, r, o, a, k.model.traverseSimple);
    }, k.model.traverseSimple = function(e, t, n, r, o) {
        for (var a = r, i = t.length - o, u = 0; u < i; ++u) {
            if (!e) return;
            var l = t[u];
            e = r && r[l] ? r[l] : k.model.resolvePathSegment(e, l, 1 === o, a), r = null;
        }
        return e;
    }, k.model.setSimple = function(e, t, n, r, o) {
        k.model.accessSimple(e, t, n, r, o, !1);
    }, k.model.getSimple = function(e, t, n, r) {
        return null == t || 0 === t.length ? e : k.model.accessSimple(e, t, k.NO_VALUE, n, r, !1);
    }, k.getImmediate = function(e, t, n) {
        for (var r = void 0 === n ? t.length : n + 1, o = 0; o < r; ++o) e = e ? e[t[o]] : void 0;
        return e;
    }, k.decodeAccessorArg = function(e) {
        return e && e !== k.model.defaultGetConfig && e !== k.model.defaultSetConfig ? "environment" === e.type ? e.value : void 0 : null;
    }, k.set = function(e, t, n, r, o) {
        var a = k.decodeAccessorArg(r);
        void 0 === a ? k.model.setWithStrategy(e, t, n, r, o) : k.model.setSimple(e, t, n, a, o);
    }, k.get = function(e, t, n, r) {
        var o = k.decodeAccessorArg(n);
        return void 0 === o ? k.model.getWithStrategy(e, t, n, r) : k.model.accessImpl(e, t, k.NO_VALUE, o, null, !1, k.model.traverseSimple);
    }, k.getGlobalValue = function(e, t) {
        if (e) return t = t || k.environment, k.get(k.global, e, {
            type: "environment",
            value: t
        });
    }, k.bind = function(e, t, n) {
        return e[t].apply(e, k.makeArray(n));
    }, k.invokeGlobalFunction = function(e, t, n) {
        var r = k.getGlobalValue(e, n);
        if (r) return r.apply(null, k.isArrayable(t) ? t : k.makeArray(t));
        k.fail("Error invoking global function: " + e + " could not be located");
    }, k.registerGlobalFunction = function(e, t, n) {
        n = n || k.environment, k.set(k.global, e, t, {
            type: "environment",
            value: n
        });
    }, k.setGlobalValue = k.registerGlobalFunction, k.registerNamespace = function(e, t) {
        t = t || k.environment;
        var n = k.getGlobalValue(e, t);
        return n || (n = {}, k.setGlobalValue(e, n, t)), n;
    }, k.dumpEl = k.identity, k.renderTimestamp = k.identity, k.generateUniquePrefix = function() {
        return Math.floor(1e12 * Math.random()).toString(36) + "-";
    };
    var e = k.generateUniquePrefix();
    k.fluidInstance = e;
    var t = 1;
    k.allocateGuid = function() {
        return e + t++;
    }, k.registerNamespace("fluid.event"), k.extremePriority = 4e9, k.priorityTypes = {
        first: -1,
        last: 1,
        before: 0,
        after: 0
    }, k.extremalPriorities = {
        none: 0,
        testing: 10,
        authoring: 20
    }, k.parsePriorityConstraint = function(e, t, n) {
        var r = e.split(":"), o = r[0], a = k.priorityTypes[o];
        return void 0 === a && k.fail("Invalid constraint type in priority field " + e + ": the only supported values are " + k.keys(k.priorityTypes).join(", ") + " or numeric"), 
        t && 0 === a && k.fail("Constraint type in priority field " + e + " is not supported in a " + n + " record - you must use either a numeric value or first, last"), 
        {
            type: r[0],
            target: r[1]
        };
    }, k.parsePriority = function(e, t, n, r) {
        var o = {
            count: t || 0,
            fixed: null,
            constraint: null,
            site: r
        };
        "number" == typeof (e = e || 0) ? o.fixed = -e : o.constraint = k.parsePriorityConstraint(e, n, r);
        var a = o.constraint ? k.priorityTypes[o.constraint.type] : 0;
        if (0 !== a) {
            var i = o.constraint.target || "none", u = k.extremalPriorities[i];
            void 0 === u && k.fail("Unrecognised extremal priority target " + i + ": the currently supported values are " + k.keys(k.extremalPriorities).join(", ") + ": register your value in fluid.extremalPriorities"), 
            o.fixed = a * (k.extremePriority + u);
        }
        return null !== o.fixed && (o.fixed += o.count / 1024), o;
    }, k.renderPriority = function(e) {
        return e.constraint ? e.constraint.target ? e.constraint.type + ":" + e.constraint.target : e.constraint.type : Math.floor(e.fixed);
    }, k.compareByPriority = function(e, t) {
        return null !== e.priority.fixed && null !== t.priority.fixed ? e.priority.fixed - t.priority.fixed : (null === e.priority.fixed) - (null === t.priority.fixed);
    }, k.honourConstraint = function(e, t, n) {
        var r = e[n].priority.constraint, o = k.find(e, function(e, t) {
            return e.namespace === r.target ? t : void 0;
        }, -1);
        if (-1 === o) return !0;
        if (t <= o) return !1;
        for (var a = o + ("after" === r.type ? 1 : 0), i = e[n], u = n; a <= u; --u) e[u] = e[u - 1];
        return e[a] = i, !0;
    }, k.sortByPriority = function(e) {
        k.stableSort(e, k.compareByPriority);
        for (var t = k.find(e, function(e, t) {
            return e.priority.constraint && 0 === k.priorityTypes[e.priority.constraint.type] ? t : void 0;
        }, e.length); ;) {
            if (t === e.length) return e;
            for (var n = t, r = t; r < e.length; ++r) {
                k.honourConstraint(e, t, r) && ++t;
            }
            if (t === n) {
                var o = e.slice(t);
                k.fail("Could not find targets for any constraints in " + o[0].priority.site + " ", o, ": none of the targets (" + k.getMembers(o, "priority.constraint.target").join(", ") + ") matched any namespaces of the elements in (", e.slice(0, t), ") - this is caused by either an invalid or circular reference");
            }
        }
    }, k.parsePriorityRecords = function(e, r) {
        var t = k.hashToArray(e, "namespace", function(e, t, n) {
            y.extend(e, t), e.priority = k.parsePriority(t.priority, n, !1, r);
        });
        return k.sortByPriority(t), t;
    }, k.event.identifyListener = function(e, t) {
        return "string" == typeof e || e.$$fluid_guid || t || (e.$$fluid_guid = k.allocateGuid()), 
        e.$$fluid_guid;
    }, k.event.impersonateListener = function(e, t) {
        k.event.identifyListener(e), t.$$fluid_guid = e.$$fluid_guid;
    }, k.event.sortListeners = function(e) {
        var o = [];
        return k.each(e, function(e) {
            for (var t, n = 0; n < e.length; ++n) {
                var r = e[n];
                r.softNamespace || t || (t = r);
            }
            t ? o.push(t) : o = o.concat(e);
        }), k.sortByPriority(o);
    }, k.event.resolveListener = function(e) {
        var t = e.globalName || ("string" == typeof e ? e : null);
        if (t) {
            var n = k.getGlobalValue(t);
            n ? e = n : k.fail("Unable to look up name " + t + " as a global function");
        }
        return e;
    }, k.nameComponent = function(e) {
        return e ? "component with typename " + e.typeName + " and id " + e.id : "[unknown component]";
    }, k.event.nameEvent = function(e, t) {
        return t + " of " + k.nameComponent(e);
    }, k.makeEventFirer = function(a) {
        var u, i = (a = a || {}).name || "<anonymous>";
        return u = {
            eventId: k.allocateGuid(),
            name: i,
            ownerId: a.ownerId,
            typeName: "fluid.event.firer",
            destroy: function() {
                u.destroyed = !0;
            },
            addListener: function() {
                (function() {
                    u.listeners = {}, u.byId = {}, u.sortedListeners = [], u.addListener = function(e, t, n, r, o) {
                        var a;
                        if (u.destroyed && k.fail("Cannot add listener to destroyed event firer " + u.name), 
                        e) {
                            k.isPlainObject(e, !0) && !k.isApplicable(e) && (e = (a = e).listener, t = a.namespace, 
                            n = a.priority, r = a.softNamespace, o = a.listenerId), "string" == typeof e && (e = {
                                globalName: e
                            });
                            var i = o || k.event.identifyListener(e);
                            t = t || i, a = y.extend(a || {}, {
                                namespace: t,
                                listener: e,
                                softNamespace: r,
                                listenerId: o,
                                priority: k.parsePriority(n, u.sortedListeners.length, !1, "listeners")
                            }), u.byId[i] = a, (u.listeners[t] = k.makeArray(u.listeners[t]))[r ? "push" : "unshift"](a), 
                            u.sortedListeners = k.event.sortListeners(u.listeners);
                        }
                    }, u.addListener.apply(null, arguments);
                }).apply(null, arguments);
            },
            removeListener: function(e) {
                if (u.listeners) {
                    var t, n, r;
                    "string" == typeof e ? (t = e, (r = u.listeners[t]) || (n = t, t = null)) : "function" == typeof e && ((n = k.event.identifyListener(e, !0)) || k.fail("Cannot remove unregistered listener function ", e, " from event " + u.name));
                    var o = u.byId[n], a = o && o.softNamespace;
                    t = t || o && o.namespace || n, delete u.byId[n], (r = u.listeners[t]) && (a ? k.remove_if(r, function(e) {
                        return e.listener.$$fluid_guid === n || e.listenerId === n;
                    }) : r.shift(), 0 === r.length && delete u.listeners[t]), u.sortedListeners = k.event.sortListeners(u.listeners);
                }
            },
            fire: function() {
                var e = u.sortedListeners;
                if (e && !u.destroyed) {
                    k.passLogLevel(k.logLevel.TRACE) && k.log(k.logLevel.TRACE, "Firing event " + i + " to list of " + e.length + " listeners");
                    for (var t = 0; t < e.length; ++t) {
                        var n = e[t];
                        n.listener = k.event.resolveListener(n.listener);
                        var r, o = n.listener.apply(null, arguments);
                        if ((a.preventable && !1 === o || u.destroyed) && (r = !1), void 0 !== r) return r;
                    }
                }
            }
        };
    }, k.fireEvent = function(e, t, n) {
        var r = e.events[t];
        r && r.fire.apply(null, k.makeArray(n));
    }, k.event.addListenerToFirer = function(e, t, n, r) {
        if (r = r || k.identity, k.isArrayable(t)) for (var o = 0; o < t.length; ++o) k.event.addListenerToFirer(e, t[o], n, r); else "function" == typeof t || "string" == typeof t ? r(e).addListener(t, n) : t && "object" == typeof t && r(e).addListener(t.listener, n || t.namespace, t.priority, t.softNamespace, t.listenerId);
    }, k.event.resolveListenerRecord = function(e) {
        return {
            records: e
        };
    }, k.expandImmediate = function(e) {
        k.fail("fluid.expandImmediate could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor " + e);
    }, k.mergeListeners = function(i, u, e) {
        k.each(e, function(e, t) {
            var n, r;
            if (k.isIoCReference(t)) (n = k.expandImmediate(t, i)) || k.fail("Error in listener record: key " + t + ' could not be looked up to an event firer - did you miss out "events." when referring to an event firer?'); else {
                var o = t.indexOf(".");
                -1 !== o && (r = t.substring(o + 1), t = t.substring(0, o)), u[t] || k.fail("Listener registered for event " + t + " which is not defined for this component"), 
                n = u[t];
            }
            var a = k.event.resolveListenerRecord(e, i, t, r, !0);
            k.event.addListenerToFirer(n, a.records, r, a.adderWrapper);
        });
    }, k.eventFromRecord = function(e, t, n) {
        var r;
        return e && ("string" != typeof e || k.isIoCReference(e)) ? k.event.resolveEvent ? r = k.event.resolveEvent(n, t, e) : k.fail("fluid.event.resolveEvent could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor ", e) : r = k.makeEventFirer({
            name: k.event.nameEvent(n, t),
            preventable: "preventable" === e,
            ownerId: n.id
        }), r;
    }, k.instantiateFirers = function(n, e) {
        k.each(e.events, function(e, t) {
            n.events[t] = k.eventFromRecord(e, t, n);
        });
    }, k.mergeListenerPolicy = function(e, t, n) {
        return "string" != typeof n && k.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + n + " from ", t), 
        !k.isIoCReference(n) && -1 !== n.indexOf(".") ? t || e : k.arrayConcatPolicy(e, t);
    }, k.makeMergeListenersPolicy = function(r, t) {
        return function(n, e) {
            return n = n || {}, t && (k.isArrayable(e) || "string" == typeof e.target) ? n[""] = r(n[""], e, "") : k.each(e, function(e, t) {
                n[t] = r(n[t], e, t);
            }), n;
        };
    }, k.validateListenersImplemented = function(n) {
        var r = [];
        return k.each(n.events, function(e, t) {
            k.each(e.sortedListeners, function(e) {
                e.listener !== k.notImplemented && "fluid.notImplemented" !== e.listener.globalName || r.push({
                    name: t,
                    namespace: e.namespace,
                    componentSource: k.model.getSimple(n.options.listeners, [ t + "." + e.namespace, 0, "componentSource" ])
                });
            });
        }), r;
    }, k.unique = function(n) {
        return k.remove_if(n, function(e, t) {
            return !e || 0 < t && e === n[t - 1];
        });
    }, k.arrayConcatPolicy = function(e, t) {
        return k.makeArray(e).concat(k.makeArray(t));
    }, k.failureEvent = k.makeEventFirer({
        name: "failure event"
    }), k.failureEvent.addListener(k.builtinFail, "fail"), k.failureEvent.addListener(k.logFailure, "log", "before:fail"), 
    k.pushSoftFailure = function(e) {
        "function" == typeof e ? k.failureEvent.addListener(e, "fail") : -1 === e ? k.failureEvent.removeListener("fail") : "boolean" == typeof e && k.fail("pushSoftFailure with boolean value is no longer supported");
    }, k.componentConstructor = function() {}, k.typeTag = function(e) {
        var t = Object.create(k.componentConstructor.prototype);
        return t.typeName = e, t.id = k.allocateGuid(), t;
    };
    var l = 1, s = {};
    function b(e, t, n, r) {
        for (var o = 0; o < n; ++o) e = r(e, t[o], o, k.makeArray(t));
        return e;
    }
    k.defaultsStore = {}, k.resolveGradesImpl = function(e, t) {
        for (var n = (t = k.makeArray(t)).length - 1; 0 <= n; --n) {
            var r = t[n];
            if (r && !e.gradeHash[r]) {
                var o = (k.isIoCReference(r) ? null : k.rawDefaults(r)) || {}, a = s[r] || l - 1;
                e.lastTick = Math.max(e.lastTick, a), e.gradeHash[r] = !0, e.gradeChain.push(r);
                for (var i = k.makeArray(o.gradeNames), u = i.length - 1; 0 <= u; --u) k.resolveGradesImpl(e, i[u]);
            }
        }
        return e;
    }, k.resolveGradeStructure = function(e, t) {
        var n = {
            lastTick: 0,
            gradeChain: [],
            gradeHash: {}
        };
        return k.resolveGradesImpl(n, [ e ].concat(k.makeArray(t))), n.gradeChain.reverse(), 
        n;
    }, k.hasGrade = function(e, t) {
        return !(!e || !e.gradeNames) && k.contains(e.gradeNames, t);
    }, k.resolveGrade = function(e, t, n) {
        var r = k.resolveGradeStructure(t, n), o = k.transform(r.gradeChain, k.rawDefaults, k.copy);
        k.remove_if(o, function(e) {
            return !e;
        });
        for (var a = {}, i = 0; i < o.length; ++i) o[i] && o[i].mergePolicy && (a = y.extend(!0, a, o[i].mergePolicy));
        o = [ a, {} ].concat(o);
        var u = k.merge.apply(null, o);
        return u.gradeNames = r.gradeChain, k.freezeRecursive(u), {
            defaults: u,
            lastTick: r.lastTick
        };
    }, k.mergedDefaultsCache = {}, k.gradeNamesToKey = function(e, t) {
        return e + "|" + t.join("|");
    }, k.getMergedDefaults = function(e, t) {
        t = k.makeArray(t);
        var n = k.gradeNamesToKey(e, t), r = k.mergedDefaultsCache[n];
        if (r) {
            for (var o = 0, a = r.defaults.gradeNames || [], i = 0; i < a.length; ++i) o = Math.max(o, s[a[i]] || 0);
            o > r.lastTick && (k.passLogLevel(k.logLevel.TRACE) && k.log(k.logLevel.TRACE, "Clearing cache for component " + e + " with gradeNames ", a), 
            r = null);
        }
        if (!r) {
            var u = k.rawDefaults(e);
            if (!u) return u;
            r = k.mergedDefaultsCache[n] = k.resolveGrade(u, e, t);
        }
        return r.defaults;
    }, k.upgradePrimitiveFunc = function(e, t) {
        if (e && k.isPrimitive(e)) {
            var n = {};
            return n[t || ("string" == typeof e && "{" !== e.charAt(0) ? "funcName" : "func")] = e, 
            n.args = k.NO_VALUE, n;
        }
        return e;
    }, k.annotateListeners = function(n, e) {
        e.listeners = k.transform(e.listeners, function(e) {
            var t = k.makeArray(e);
            return k.transform(t, function(e) {
                return (e = k.upgradePrimitiveFunc(e, "listener")).componentSource = n, e;
            });
        }), e.invokers = k.transform(e.invokers, function(e) {
            return (e = k.upgradePrimitiveFunc(e)) && (e.componentSource = n), e;
        });
    }, k.rawDefaults = function(e) {
        var t = k.defaultsStore[e];
        return t && t.options;
    }, k.registerRawDefaults = function(e, t) {
        k.pushActivity("registerRawDefaults", "registering defaults for grade %componentName with options %options", {
            componentName: e,
            options: t
        });
        var n = k.expandCompact ? k.expandCompact(t) : k.copy(t);
        k.annotateListeners(e, n);
        var r = k.getCallerInfo && k.getCallerInfo(6);
        k.defaultsStore[e] = {
            options: n,
            callerInfo: r
        }, s[e] = l++, k.popActivity();
    }, k.doIndexDefaults = function(e, t, n, r) {
        for (var o = k.makeArray(r.gradeNames), a = 0; a < o.length; ++a) if (!k.hasGrade(t, o[a])) return;
        for (var i = ("function" == typeof r.indexFunc ? r.indexFunc : k.getGlobalValue(r.indexFunc))(t) || [], u = 0; u < i.length; ++u) k.pushArray(n, i[u], e);
    }, k.indexDefaults = function(e, t) {
        var n = {};
        for (var r in k.defaultsStore) {
            var o = k.getMergedDefaults(r);
            k.doIndexDefaults(r, o, n, t);
        }
        return n;
    }, k.defaults = function(e, t) {
        if (void 0 === t) return k.getMergedDefaults(e);
        t && t.options && k.fail("Probable error in options structure for " + e + ' with option named "options" - perhaps you meant to write these options at top level in fluid.defaults? - ', t), 
        k.registerRawDefaults(e, t);
        var n = k.getMergedDefaults(e);
        k.hasGrade(n, "fluid.function") || k.makeComponentCreator(e);
    }, k.makeComponentCreator = function(o) {
        var e = function() {
            var e = k.getMergedDefaults(o);
            if (e.gradeNames && 0 !== e.gradeNames.length) {
                if (e.initFunction) return k.initComponent(o, arguments);
                for (var t = [], n = 0; n < e.gradeNames.length; ++n) {
                    var r = e.gradeNames[n];
                    k.rawDefaults(r) || t.push(r);
                }
                0 === t.length ? k.fail("Cannot make component creator for type " + o + " which does not have an initFunction defined") : k.fail("The grade hierarchy of component with type " + o + " is incomplete - it inherits from the following grade(s): " + t.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these grades and ensure they are readable and have been loaded by this instance of Infusion");
            } else k.fail("Cannot make component creator for type " + o + " which does not have any gradeNames defined");
        }, t = k.getGlobalValue(o);
        t && y.extend(e, t), k.setGlobalValue(o, e);
    }, k.emptyPolicy = k.freezeRecursive({}), k.derefMergePolicy = function(e) {
        return (e ? e["*"] : k.emptyPolicy) || k.emptyPolicy;
    }, k.compileMergePolicy = function(e) {
        var i = {}, u = {}, l = {
            builtins: i,
            defaultValues: u
        };
        return e && k.each(e, function(e, t) {
            var n = {}, r = !0;
            if ("function" == typeof e) n.func = e; else if ("object" == typeof e) n = e; else if (k.isDefaultValueMergePolicy(e)) k.set(u, t, "{that}.options." + e), 
            r = !(l.hasDefaults = !0); else for (var o = e.split(/\s*,\s*/), a = 0; a < o.length; ++a) n[o[a]] = !0;
            r && k.set(i, k.composePath(t, "*"), n);
        }), l;
    }, k.isDefaultValueMergePolicy = function(e) {
        return "string" == typeof e && -1 === e.indexOf(",") && !/replace|nomerge|noexpand/.test(e);
    }, k.mergeOneImpl = function(e, t, n, r, o, a, i) {
        var u = e, l = k.isPrimitive(e);
        return void 0 !== t && (o.func || null === t || !k.isPlainObject(t) || o.nomerge ? (r[n] = void 0, 
        u = o.func ? o.func.call(null, e, t, i[a - 1], i, a) : t) : l && (u = e = k.freshContainer(t))), 
        u;
    }, k.fetchMergeChildren = function(r, o, a, i, u, l) {
        for (var e = k.derefMergePolicy(u), t = i.length - 1; 0 <= t; --t) {
            var n = i[t];
            if (void 0 !== n && (k.each(n, function(e, t) {
                var n = k.concreteTrundler(u, t);
                t in r && (!l.evaluateFully || void 0 !== n || k.isPrimitive(r[t])) || (a[o] = t, 
                l.strategy(r, t, o + 1, a, i, u));
            }), e.replace)) break;
        }
        return r;
    }, k.inEvaluationMarker = Object.freeze({
        __CURRENTLY_IN_EVALUATION__: !0
    }), k.strategyRecursionBailout = 50, k.makeMergeStrategy = function(v) {
        var e = function(e, t, n, r, o, a) {
            if (n > k.strategyRecursionBailout && k.fail("Overflow/circularity in options merging, current path is ", r, " at depth ", n, ' - please protect components from merging using the "nomerge" merge policy'), 
            !k.isPrimitive(e)) {
                var i;
                if (k.isTracing && k.tracing.pathCount.push(k.path(r.slice(0, n))), t in e) {
                    if (i = e[t], !v.evaluateFully) return i;
                } else e !== k.inEvaluationMarker && (e[t] = k.inEvaluationMarker);
                void 0 === o && (r = k.makeArray(r), o = function(e, t, n, r) {
                    for (var o = [], a = 0; a < e.length; ++a) {
                        var i = b(e[a], t, n, r[a]);
                        void 0 !== i && o.push(i);
                    }
                    return o;
                }(v.sources, r, n - 1, v.sourceStrategies), a = b(v.mergePolicy, r, n - 1, k.concreteTrundler));
                var u, l, s, c = k.concreteTrundler(a, t), f = k.derefMergePolicy(c);
                f.replace ? (u = 1 - o.length, l = 0, s = -1) : (u = 0, l = o.length - 1, s = 1);
                for (var d, p = [], m = u; m <= l; ++m) {
                    var g = s * m, h = v.sourceStrategies[g](o[g], t, n, r);
                    if (void 0 !== h && (k.isPrimitive(h) || (p[g] = h), void 0 === i)) {
                        if (-1 === s) {
                            d = e[t] = h;
                            break;
                        }
                        d = k.mergeOneImpl(d, h, m, p, f, n, r, v), e !== k.inEvaluationMarker && (e[t] = d);
                    }
                }
                return void 0 !== i && (d = i), 0 < p.length && k.isPlainObject(d) && k.fetchMergeChildren(d, n, r, p, c, v), 
                void 0 === i && 0 === p.length && delete e[t], d;
            }
        };
        return v.strategy = e;
    }, k.driveStrategy = function(e, t, n) {
        t = k.makeArray(t);
        for (var r = 0; r < t.length; ++r) {
            if (!e) return;
            e = n(e, t[r], r + 1, t);
        }
        return e;
    }, k.concreteTrundler = function(e, t) {
        return e ? e[t] : void 0;
    }, k.merge = function(e) {
        var t = Array.prototype.slice.call(arguments, 1), n = k.compileMergePolicy(e).builtins, r = k.makeMergeOptions(n, t, {});
        return r.initter(), r.target;
    }, k.simpleGingerBlock = function(e, t) {
        return {
            target: e,
            simple: !0,
            strategy: k.concreteTrundler,
            initter: k.identity,
            recordType: t,
            priority: k.mergeRecordTypes[t]
        };
    }, k.makeMergeOptions = function(e, t, n) {
        var r = {
            mergePolicy: e,
            sources: t
        };
        return (r = y.extend(r, n)).target = r.target || k.freshContainer(r.sources[0]), 
        r.sourceStrategies = r.sourceStrategies || k.generate(r.sources.length, k.concreteTrundler), 
        r.initter = function() {
            r.evaluateFully = !0, k.fetchMergeChildren(r.target, 0, [], r.sources, r.mergePolicy, r);
        }, k.makeMergeStrategy(r), r;
    }, k.transformOptions = function(e, t) {
        return k.expect("Options transformation record", t, [ "transformer", "config" ]), 
        k.getGlobalValue(t.transformer).call(null, e, t.config);
    }, k.findMergeBlocks = function(e, t) {
        return k.remove_if(k.makeArray(e), function(e) {
            return e.recordType !== t;
        });
    }, k.transformOptionsBlocks = function(n, r, e) {
        k.each(e, function(e) {
            var t = k.findMergeBlocks(n, e);
            k.each(t, function(e) {
                var t = e.source ? "source" : "target";
                e[e.simple || "target" === t ? "target" : "source"] = k.transformOptions(e[t], r);
            });
        });
    }, k.dedupeDistributionNamespaces = function(e) {
        var n = {};
        k.remove_if(e, function(e) {
            var t = e.namespace;
            if (t) {
                if (n[t] && n[t] !== e.contextThat.id) return !0;
                n[t] = e.contextThat.id;
            }
        });
    }, k.deliverOptionsStrategy = k.identity, k.computeComponentAccessor = k.identity, 
    k.computeDynamicComponents = k.identity, k.mergeRecordTypes = {
        defaults: 1e3,
        defaultValueMerge: 900,
        subcomponentRecord: 800,
        user: 700,
        distribution: 100
    }, k.model.applyChangeRequest = function(e, t) {
        var n = t.segs;
        if (0 === n.length) "ADD" === t.type ? y.extend(!0, e, t.value) : k.clear(e); else if ("ADD" === t.type) k.model.setSimple(e, t.segs, t.value); else {
            for (var r = 0; r < n.length - 1; ++r) if (!(e = e[n[r]])) return;
            delete e[n[n.length - 1]];
        }
    }, k.destroyValue = function(e, t) {
        e && k.model.applyChangeRequest(e, {
            type: "DELETE",
            segs: t
        });
    }, k.mergeComponentOptions = function(e, t, n, r) {
        var o = k.rawDefaults(t), a = k.getMergedDefaults(t, o && o.gradeNames ? null : r.gradeNames), i = {}, u = [];
        u = k.expandComponentOptions ? u.concat(k.expandComponentOptions(i, a, n, e)) : u.concat([ k.simpleGingerBlock(a, "defaults"), k.simpleGingerBlock(n, "user") ]);
        var l = {}, s = [], c = [], f = {
            target: l,
            sourceStrategies: s
        }, d = function() {
            k.each(u, function(e) {
                k.isPrimitive(e.priority) && (e.priority = k.parsePriority(e.priority, 0, !1, "options distribution"));
            }), k.sortByPriority(u), k.dedupeDistributionNamespaces(u), s.length = 0, c.length = 0, 
            k.each(u, function(e) {
                s.push(e.strategy), c.push(e.target);
            });
        };
        d();
        var p, m, g = k.makeMergeOptions(i, c, f);
        function h() {
            m = k.driveStrategy(l, "mergePolicy", g.strategy), m = y.extend({}, k.rootMergePolicy, m), 
            p = k.compileMergePolicy(m), y.extend(!0, i, p.builtins);
        }
        g.mergeBlocks = u, g.updateBlocks = d, g.destroyValue = function(e) {
            for (var t = 0; t < u.length; ++t) u[t].immutableTarget || k.destroyValue(u[t].target, e);
            k.destroyValue(f.target, e);
        }, h(), g.computeMergePolicy = h, p.hasDefaults && (k.generateExpandBlock ? (u.push(k.generateExpandBlock({
            options: p.defaultValues,
            recordType: "defaultValueMerge",
            priority: k.mergeRecordTypes.defaultValueMerge
        }, e, {})), d()) : k.fail("Cannot operate mergePolicy ", m, " for component ", e, " without including FluidIoC.js")), 
        e.options = l, k.driveStrategy(l, "gradeNames", g.strategy), k.deliverOptionsStrategy(e, l, g), 
        k.computeComponentAccessor(e, n && n.localRecord);
        var v = k.driveStrategy(l, "transformOptions", g.strategy);
        return v && (k.transformOptionsBlocks(u, v, [ "user", "subcomponentRecord" ]), d()), 
        f.target.mergePolicy || h(), g;
    }, k.defaults("fluid.function", {}), k.invokeGradedFunction = function(e, n) {
        var t = k.defaults(e);
        t && t.argumentMap && k.hasGrade(t, "fluid.function") || k.fail("Cannot look up name " + e + " to a function with registered argumentMap - got defaults ", t);
        var r = [];
        return k.each(t.argumentMap, function(e, t) {
            r[e] = n[t];
        }), k.invokeGlobalFunction(e, r);
    }, k.noNamespaceDistributionPrefix = "no-namespace-distribution-", k.mergeOneDistribution = function(e, t, n) {
        var r = t.namespace || n || k.noNamespaceDistributionPrefix + k.allocateGuid();
        e[t.namespace = r] = y.extend(!0, {}, e[r], t);
    }, k.distributeOptionsPolicy = function(n, e) {
        if (n = n || {}, k.isArrayable(e)) for (var t = 0; t < e.length; ++t) k.mergeOneDistribution(n, e[t]); else "string" == typeof e.target ? k.mergeOneDistribution(n, e) : k.each(e, function(e, t) {
            k.mergeOneDistribution(n, e, t);
        });
        return n;
    }, k.mergingArray = function() {}, k.mergingArray.prototype = [], k.membersMergePolicy = function(n, e) {
        return n = n || {}, k.each(e, function(e, t) {
            n[t] || (n[t] = new k.mergingArray()), e instanceof k.mergingArray ? n[t].push.apply(n[t], e) : void 0 !== e && n[t].push(e);
        }), n;
    }, k.invokerStrategies = k.arrayToHash([ "func", "funcName", "listener", "this", "method", "changePath", "value" ]), 
    k.invokersMergePolicy = function(a, e) {
        return a = a || {}, k.each(e, function(e, t) {
            if (e) {
                e = k.upgradePrimitiveFunc(e);
                var n = a[t];
                for (var r in n || (n = a[t] = {}), k.invokerStrategies) if (r in e) for (var o in k.invokerStrategies) n[o] = void 0;
                y.extend(n, e);
            } else a[t] = e;
        }), a;
    }, k.rootMergePolicy = {
        gradeNames: k.arrayConcatPolicy,
        distributeOptions: k.distributeOptionsPolicy,
        members: {
            noexpand: !0,
            func: k.membersMergePolicy
        },
        invokers: {
            noexpand: !0,
            func: k.invokersMergePolicy
        },
        transformOptions: "replace",
        listeners: k.makeMergeListenersPolicy(k.mergeListenerPolicy)
    }, k.defaults("fluid.component", {
        initFunction: "fluid.initLittleComponent",
        mergePolicy: k.rootMergePolicy,
        argumentMap: {
            options: 0
        },
        events: {
            onCreate: null,
            onDestroy: null,
            afterDestroy: null
        }
    }), k.defaults("fluid.emptySubcomponent", {
        gradeNames: [ "fluid.component" ]
    }), k.computeNickName = function(e) {
        var t = k.model.parseEL(e);
        return t[t.length - 1];
    }, k.defaults("fluid.typeFount", {
        gradeNames: [ "fluid.component" ]
    }), k.initLittleComponent = function(e, t, n, r) {
        var o = k.typeTag(e);
        o.lifecycleStatus = "constructing", n = n || {
            gradeNames: "fluid.component"
        }, o.destroy = k.makeRootDestroy(o);
        var a = k.mergeComponentOptions(o, e, t, n);
        a.exceptions = {
            members: {
                model: !0,
                modelRelay: !0
            }
        };
        var i = o.options;
        o.events = {}, (r || k.identity)(o, i, a.strategy), k.computeDynamicComponents(o, a);
        for (var u = 0; u < a.mergeBlocks.length; ++u) a.mergeBlocks[u].initter();
        return a.initter(), delete i.mergePolicy, k.instantiateFirers(o, i), k.mergeListeners(o, o.events, i.listeners), 
        o;
    }, k.diagnoseFailedView = k.identity, k.makeRootDestroy = function(e) {
        return function() {
            k.doDestroy(e), k.fireEvent(e, "afterDestroy", [ e, "", null ]);
        };
    }, k.isDestroyed = function(e) {
        return "destroyed" === e.lifecycleStatus;
    }, k.doDestroy = function(e, t, n) {
        for (var r in k.fireEvent(e, "onDestroy", [ e, t || "", n ]), e.lifecycleStatus = "destroyed", 
        e.events) "afterDestroy" !== r && "function" == typeof e.events[r].destroy && e.events[r].destroy();
        e.applier && e.applier.destroy();
    }, k.initComponent = function(e, t) {
        var n = k.defaults(e);
        n.gradeNames || k.fail("Cannot initialise component " + e + " which has no gradeName registered");
        var r, o = [ e ].concat(k.makeArray(t));
        k.pushActivity("initComponent", "constructing component of type %componentName with arguments %initArgs", {
            componentName: e,
            initArgs: t
        }), r = k.invokeGlobalFunction(n.initFunction, o), k.diagnoseFailedView(e, r, n, o), 
        k.initDependents && k.initDependents(r);
        var a = k.validateListenersImplemented(r);
        return 0 < a.length && k.fail(k.transform(a, function(e) {
            return [ "Error constructing component ", r, " - the listener for event " + e.name + " with namespace " + e.namespace + (e.componentSource ? " which was defined in grade " + e.componentSource : "") + " needs to be overridden with a concrete implementation" ];
        })).join("\n"), "constructing" === r.lifecycleStatus && (r.lifecycleStatus = "constructed"), 
        r.events.onCreate.fire(r), k.popActivity(), r;
    }, k.initSubcomponentImpl = function(e, t, n) {
        var r;
        if ("function" != typeof t) {
            var o = "string" == typeof t ? t : t.type;
            r = "fluid.emptySubcomponent" === o ? null : k.invokeGlobalFunction(o, n);
        } else r = t.apply(null, n);
        return r;
    };
    var r = "(?:[\\w\\u00c0-\\uFFFF*_-";
    k.simpleCSSMatcher = {
        regexp: new RegExp("([#.]?)(" + r + "]|\\\\.)+)", "g"),
        charToTag: {
            "": "tag",
            "#": "id",
            ".": "clazz"
        }
    }, k.IoCSSMatcher = {
        regexp: new RegExp("([&#]?)(" + r + "]|\\.|\\/)+)", "g"),
        charToTag: {
            "": "context",
            "&": "context",
            "#": "id"
        }
    };
    var p = new RegExp("\\s*(>)?\\s*", "g");
    k.parseSelector = function(e, t) {
        var n = [];
        e = e.trim();
        for (var r = t.regexp, o = r.lastIndex = 0; ;) {
            for (var a = [], i = !0; ;) {
                var u = r.exec(e);
                if (!u) break;
                if (u.index !== o) {
                    if (!i) break;
                    k.fail("Error in selector string - cannot match child selector expression starting at " + e.substring(o));
                }
                var l = {}, s = u[2], c = t.charToTag[u[1]];
                c && (l[c] = s), a[a.length] = l, o = r.lastIndex, i = !1;
            }
            p.lastIndex = o;
            var f = {
                predList: a
            }, d = p.exec(e);
            if (d && d.index === o || k.fail("Error in selector string - can not match child selector expression at " + e.substring(o)), 
            ">" === d[1] && (f.child = !0), n[n.length] = f, p.lastIndex >= e.length) break;
            o = p.lastIndex, r.lastIndex = p.lastIndex;
        }
        return n;
    }, k.flattenObjectPaths = function(e) {
        var r = {};
        return k.each(e, function(e, n) {
            if (null !== e && "object" == typeof e) {
                var t = k.flattenObjectPaths(e);
                k.each(t, function(e, t) {
                    r[n + "." + t] = e;
                }), "function" == typeof k.get(e, "toString") && (r[n] = e.toString());
            } else r[n] = e;
        }), r;
    }, k.stringTemplate = function(e, t) {
        var n = k.flattenObjectPaths(t), r = k.keys(n);
        r = r.sort(k.compareStringLength());
        for (var o = 0; o < r.length; ++o) for (var a = r[o], i = "%" + a, u = n[a], l = -1; -1 !== (l = e.indexOf(i)); ) e = e.slice(0, l) + u + e.slice(l + i.length);
        return e;
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(r, f) {
    "use strict";
    f.renderTimestamp = function(e) {
        var t = function(e, t) {
            t || (t = 2);
            var n = void 0 === e ? "" : e.toString();
            return "00000".substring(5 - t + n.length) + n;
        };
        return t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + "." + t(e.getMilliseconds(), 3);
    }, f.isTracing = !1, f.registerNamespace("fluid.tracing"), f.tracing.pathCount = [], 
    f.tracing.summarisePathCount = function(e) {
        e = e || f.tracing.pathCount;
        for (var t = {}, n = 0; n < e.length; ++n) {
            var r = e[n];
            t[r] ? ++t[r] : t[r] = 1;
        }
        var o = [];
        return f.each(t, function(e, t) {
            o.push({
                path: t,
                count: e
            });
        }), o.sort(function(e, t) {
            return t.count - e.count;
        }), o;
    }, f.tracing.condensePathCount = function(e, t) {
        e = f.makeArray(e);
        var r = {};
        f.each(e, function(e) {
            r[e] = 0;
        });
        var o = [];
        return f.each(t, function(t) {
            var n = t.path;
            f.find(e, function(e) {
                if (0 === n.indexOf(e)) return r[e] += t.count, !0;
            }) || o.push(t);
        }), f.each(r, function(e, t) {
            o.unshift({
                path: t,
                count: e
            });
        }), o;
    }, f.detectStackStyle = function(e) {
        var t = "other", n = {
            offset: 0
        };
        return e.arguments ? t = "chrome" : "undefined" != typeof window && window.opera && e.stacktrace ? t = "opera10" : e.stack ? (t = "firefox", 
        n.offset = -1 === e.stack.indexOf("Trace exception") ? 1 : 0) : "undefined" == typeof window || !window.opera || "stacktrace" in e || (t = "opera"), 
        n.style = t, n;
    }, f.obtainException = function() {
        try {
            throw new Error("Trace exception");
        } catch (e) {
            return e;
        }
    };
    var a = f.detectStackStyle(f.obtainException());
    f.registerNamespace("fluid.exceptionDecoders"), f.decodeStack = function() {
        if ("firefox" !== a.style) return null;
        var e = f.obtainException();
        return f.exceptionDecoders[a.style](e);
    }, f.exceptionDecoders.firefox = function(e) {
        var t = e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/gm, "{anonymous}(").split("\n");
        return f.transform(t, function(e) {
            var t = (e = e.replace(/\)/g, "")).indexOf("at ");
            return -1 === t ? [ e ] : [ e.substring(t + "at ".length), e.substring(0, t) ];
        });
    }, f.getCallerInfo = function(e) {
        e = (e || 3) - a.offset;
        var t = f.decodeStack(), n = t && t[e][0];
        if (n) {
            var r = n.lastIndexOf("/");
            -1 === r && (r = 0);
            var o = n.indexOf(":", r);
            return {
                path: n.substring(0, r),
                filename: n.substring(r + 1, o),
                index: n.substring(o + 1)
            };
        }
        return null;
    }, f.generatePadding = function(e, t) {
        for (var n = "", r = 0; r < t; ++r) n += e;
        return n;
    }, f.SYNTHETIC_PROPERTY = Object.freeze({}), f.getSafeProperty = function(e, t) {
        var n = Object.getOwnPropertyDescriptor(e, t);
        return n && !n.get ? e[t] : f.SYNTHETIC_PROPERTY;
    }, f.prettyPrintJSON = function(e, t) {
        return (t = r.extend({
            indent: 4,
            stack: [],
            output: ""
        }, t)).indentChars = f.generatePadding(" ", t.indent), function e(t, n, r) {
            function o(e) {
                r.output += e;
            }
            var a = n + r.indentChars, i = "function" == typeof t;
            if (void 0 !== r.maxRenderChars && r.output.length > r.maxRenderChars) return !0;
            if (null === t) o("null"); else if (void 0 === t) o("undefined"); else if (t === f.SYNTHETIC_PROPERTY) o("[Synthetic property]"); else if (f.isPrimitive(t) && !i) o(JSON.stringify(t)); else {
                if (-1 !== r.stack.indexOf(t)) return void o("(CIRCULAR)");
                var u;
                if (r.stack.push(t), f.isArrayable(t)) if (0 === t.length) o("[]"); else {
                    for (o("[\n" + a), u = 0; u < t.length; ++u) {
                        if (e(t[u], a, r)) return !0;
                        u !== t.length - 1 && o(",\n" + a);
                    }
                    o("\n" + n + "]");
                } else {
                    o("{" + (i ? " Function" : "") + "\n" + a);
                    var l = f.keys(t);
                    for (u = 0; u < l.length; ++u) {
                        var s = l[u], c = f.getSafeProperty(t, s);
                        if (o(JSON.stringify(s) + ": "), e(c, a, r)) return !0;
                        u !== l.length - 1 && o(",\n" + a);
                    }
                    o("\n" + n + "}");
                }
                r.stack.pop();
            }
        }(e, "", t), t.output;
    }, f.dumpEl = function(e) {
        var t;
        if (!e) return "null";
        if (3 === e.nodeType || 8 === e.nodeType) return "[data: " + e.data + "]";
        if (9 === e.nodeType) return "[document: location " + e.location + "]";
        if (!e.nodeType && f.isArrayable(e)) {
            t = "[";
            for (var n = 0; n < e.length; ++n) t += f.dumpEl(e[n]), n < e.length - 1 && (t += ", ");
            return t + "]";
        }
        return t = (e = r(e)).get(0).tagName, e.id && (t += "#" + e.id), e.attr("class") && (t += "." + e.attr("class")), 
        t;
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(f, h) {
    "use strict";
    h.visitComponentChildren = function(e, t, n, r) {
        for (var o in r = r || [], e) {
            var a = e[o];
            if (!(!h.isComponent(a) || n.visited && n.visited[a.id])) {
                if (r.push(o), n.visited && (n.visited[a.id] = !0), t(a, o, r, r.length - 1)) return !0;
                n.flat || h.visitComponentChildren(a, t, n, r), r.pop();
            }
        }
    }, h.getContextHash = function(e, t) {
        var n = e.idToShadow[t.id];
        return n && n.contextHash;
    }, h.componentHasGrade = function(e, t) {
        var n = h.getContextHash(h.globalInstantiator, e);
        return !(!n || !n[t]);
    }, h.visitComponentsForMatching = function(e, t, a) {
        var i = h.getInstantiator(e);
        t = f.extend({
            visited: {},
            instantiator: i
        }, t);
        var u = [ e ], l = [ h.getContextHash(i, e) ];
        h.visitComponentChildren(e, function(e, t, n) {
            u.length = 1, l.length = 1;
            for (var r = 0; r < n.length; ++r) {
                var o = u[r][n[r]];
                u[r + 1] = o, l[r + 1] = h.getContextHash(i, o) || {};
            }
            return a(e, u, l, n, n.length);
        }, t, []);
    }, h.getMemberNames = function(e, t) {
        if (0 === t.length) return [];
        var n = e.idToPath(t[t.length - 1].id), r = e.parseEL(n);
        return r.unshift.apply(r, h.generate(t.length - r.length, "")), r;
    }, h.visitComponentsForVisibility = function(e, t, n, r) {
        r = r || {
            visited: {},
            flat: !0,
            instantiator: e
        };
        for (var o = h.getMemberNames(e, t), a = t.length - 1; 0 <= a; --a) {
            var i = t[a];
            if (r.visited[i.id] = !0, n(i, o[a], o, a)) return;
            if (h.visitComponentChildren(i, n, r, o)) return;
            o.pop();
        }
    }, h.mountStrategy = function(a, e, i) {
        var u = a.length;
        return function(e, t, n, r) {
            if (!(n <= a.length)) {
                for (var o = 0; o < a.length; ++o) if (r[o] !== a[o]) return;
                return i(e, t, n - a.length, r.slice(u));
            }
        };
    }, h.invokerFromRecord = function(e, t, n) {
        h.pushActivity("makeInvoker", "beginning instantiation of invoker with name %name and record %record as child of %that", {
            name: t,
            record: e,
            that: n
        });
        var r = e ? h.makeInvoker(n, e, t) : void 0;
        return h.popActivity(), r;
    }, h.memberFromRecord = function(e, t, n) {
        for (var r, o = 0; o < e.length; ++o) {
            var a = h.expandImmediate(e[o], n);
            r = h.isPlainObject(r) ? f.extend(!0, r, a) : a;
        }
        return r;
    }, h.recordStrategy = function(a, i, u, l, s, n, r) {
        return n = n || [], {
            strategy: function(e, t, n) {
                if (1 === n) {
                    var r = h.driveStrategy(i, [ l, t ], u);
                    if (void 0 !== r) {
                        h.set(e, [ t ], h.inEvaluationMarker);
                        var o = s(r, t, a);
                        return h.set(e, [ t ], o), o;
                    }
                }
            },
            initter: function() {
                var e = h.driveStrategy(i, l, u) || {};
                for (var t in e) r && r[t] || h.getForComponent(a, n.concat([ t ]));
            }
        };
    }, h.instantiateFirers = function(e) {
        var t = h.shadowForComponent(e);
        (h.get(t, [ "eventStrategyBlock", "initter" ]) || h.identity)();
    }, h.makeDistributionRecord = function(e, t, n, r, o, a) {
        a = a || "distribution", h.pushActivity("makeDistributionRecord", "Making distribution record from source record %sourceRecord path %sourcePath to target path %targetSegs", {
            sourceRecord: t,
            sourcePath: n,
            targetSegs: r
        });
        var i = h.copy(h.get(t, n));
        h.each(o, function(e) {
            h.model.applyChangeRequest(i, {
                segs: e,
                type: "DELETE"
            });
        });
        var u = {
            options: {}
        };
        return h.model.applyChangeRequest(u, {
            segs: r,
            type: "ADD",
            value: i
        }), h.checkComponentRecord(u), h.popActivity(), f.extend(u, {
            contextThat: e,
            recordType: a
        });
    }, h.filterBlocks = function(t, e, o, a, i, u) {
        var l = [];
        return h.each(e, function(n) {
            var e = h.get(n.source, o);
            if (void 0 !== e) {
                l.push(h.makeDistributionRecord(t, n.source, o, a, i, n.recordType));
                var r = f.extend({}, e);
                u && h.model.applyChangeRequest(n.source, {
                    segs: o,
                    type: "DELETE"
                }), h.each(i, function(e) {
                    var t = h.get(r, e);
                    h.set(n.source, o.concat(e), t);
                });
            }
        }), l;
    }, h.noteCollectedDistribution = function(e, t, n) {
        h.model.setSimple(e, [ "collectedDistributions", t, n.id ], !0);
    }, h.isCollectedDistribution = function(e, t, n) {
        return h.model.getSimple(e, [ "collectedDistributions", t, n.id ]);
    }, h.clearCollectedDistributions = function(e, t) {
        h.model.applyChangeRequest(e, {
            segs: [ "collectedDistributions", t ],
            type: "DELETE"
        });
    }, h.collectDistributions = function(e, t, n, r, o, a, i) {
        var u = a[a.length - 1];
        !h.isCollectedDistribution(t, u, n) && h.matchIoCSelector(n.selector, r, o, a, i) && (e.push.apply(e, n.blocks), 
        h.noteCollectedDistribution(t, u, n));
    }, h.registerCollectedClearer = function(e, t, n) {
        !e.collectedClearer && t && (e.collectedClearer = function() {
            h.clearCollectedDistributions(t, n);
        });
    }, h.receiveDistributions = function(e, t, n, r) {
        var o = h.getInstantiator(e || r), a = o.getThatStack(e || r);
        a.unshift(h.rootComponent);
        var i = h.getMemberNames(o, a), u = h.transform(a, function(e) {
            return o.idToShadow[e.id];
        }), l = u[u.length - (e ? 1 : 2)], s = h.getMembers(u, "contextHash");
        e ? (i.push(n), s.push(h.gradeNamesToHash(t)), a.push(r)) : h.registerCollectedClearer(u[u.length - 1], l, i[i.length - 1]);
        for (var c = [], f = 0; f < a.length - 1; ++f) h.each(u[f].distributions, function(e) {
            h.collectDistributions(c, l, e, a, s, i, f);
        });
        return c;
    }, h.computeTreeDistance = function(e, t) {
        for (var n = 0; n < e.length && n < t.length && e[n] === t[n]; ) ++n;
        return e.length + t.length - 2 * n;
    }, h.computeDistributionPriority = function(e, t) {
        if (!t.priority) {
            var n = h.getInstantiator(e), r = n.getThatStack(e), o = h.getMemberNames(n, r), a = n.getThatStack(t.contextThat), i = h.getMemberNames(n, a), u = h.computeTreeDistance(o, i);
            t.priority = h.mergeRecordTypes.distribution - u;
        }
        return t;
    }, h.applyDistributions = function(t, e, n) {
        var r = h.transform(e, function(e) {
            return h.generateExpandBlock(e, t, n.mergePolicy);
        }, function(e) {
            return h.computeDistributionPriority(t, e);
        }), o = n.mergeOptions;
        return o.mergeBlocks.push.apply(o.mergeBlocks, r), o.updateBlocks(), r;
    }, h.matchIoCSelector = function(e, t, n, r, o) {
        for (var a = t.length - 1, i = e.length - 1; ;) {
            for (var u = a === t.length - 1 || e[i].child, l = t[a], s = e[i], c = !0, f = 0; f < s.predList.length; ++f) {
                var d = s.predList[f];
                if (d.context && !n[a][d.context] && r[a] !== d.context) {
                    c = !1;
                    break;
                }
                if (d.id && l.id !== d.id) {
                    c = !1;
                    break;
                }
            }
            if (0 === i && o < a && u && (c = !1), c) {
                if (0 === i) return !0;
                --a, --i;
            } else {
                if (u) return !1;
                --a;
            }
            if (a < o) return !1;
        }
    }, h.queryIoCSelector = function(e, t, n) {
        var a = h.parseSelector(t, h.IoCSSMatcher), i = [];
        return h.visitComponentsForMatching(e, {
            flat: n
        }, function(e, t, n, r, o) {
            h.matchIoCSelector(a, t, n, r, o) && i.push(e);
        }), i;
    }, h.isIoCSSSelector = function(e) {
        return -1 !== e.indexOf(" ");
    }, h.pushDistributions = function(e, t, n, r) {
        var o = h.shadowForComponent(e), a = h.allocateGuid(), i = {
            id: a,
            target: n,
            selector: t,
            blocks: r
        };
        return Object.freeze(i), Object.freeze(i.blocks), h.pushArray(o, "distributions", i), 
        a;
    }, h.clearDistribution = function(e, t) {
        var n = h.globalInstantiator.idToShadow[e];
        n && h.remove_if(n.distributions, function(e) {
            return e.id === t;
        });
    }, h.clearDistributions = function(e) {
        h.each(e.outDistributions, function(e) {
            h.clearDistribution(e.targetHeadId, e.distributionId);
        });
    }, h.extractSelectorHead = function(e) {
        var t = e[0].predList, n = t[0].context;
        return t.length = 0, n;
    }, h.parseExpectedOptionsPath = function(e, t) {
        var n = h.model.parseEL(e);
        return "options" !== n[0] && h.fail("Error in options distribution path ", e, " - only " + t + ' paths beginning with "options" are supported'), 
        n.slice(1);
    }, h.replicateProperty = function(t, n, e) {
        void 0 !== t[n] && h.each(e, function(e) {
            e[n] = t[n];
        });
    }, h.undistributableOptions = [ "gradeNames", "distributeOptions", "argumentMap", "initFunction", "mergePolicy", "progressiveCheckerOptions" ], 
    h.distributeOptions = function(m, e) {
        var g = h.shadowForComponent(m), t = h.driveStrategy(m.options, "distributeOptions", e);
        h.each(t, function(e) {
            h.pushActivity("distributeOptions", "parsing distributeOptions block %record %that ", {
                that: m,
                record: e
            }), "string" != typeof e.target && h.fail("Error in options distribution record ", e, ' a member named "target" must be supplied holding an IoC reference'), 
            "string" == typeof e.source ^ void 0 === e.record && h.fail("Error in options distribution record ", e, ': must supply either a member "source" holding an IoC reference or a member "record" holding a literal record');
            var t, n, r, o = h.parseContextReference(e.target);
            if (h.isIoCSSSelector(o.context)) {
                n = h.parseSelector(o.context, h.IoCSSMatcher);
                var a = h.extractSelectorHead(n);
                "/" === a ? t = h.rootComponent : r = a;
            } else r = o.context;
            (t = t || h.resolveContext(r, m)) || h.fail("Error in options distribution record ", e, " - could not resolve context {" + r + "} to a head component");
            var i, u = h.model.parseEL(o.path);
            if (void 0 !== e.record) i = [ h.makeDistributionRecord(m, e.record, [], u, []) ]; else {
                var l = h.parseContextReference(e.source);
                "that" !== l.context && h.fail("Error in options distribution record ", e, " only a context of {that} is supported");
                var s = h.parseExpectedOptionsPath(l.path, "source"), c = h.makeArray(e.exclusions).concat(0 === s.length ? h.undistributableOptions : []), f = h.transform(c, function(e) {
                    return h.model.parseEL(e);
                });
                i = h.filterBlocks(m, g.mergeOptions.mergeBlocks, s, u, f, e.removeSource), g.mergeOptions.updateBlocks();
            }
            if (h.replicateProperty(e, "priority", i), h.replicateProperty(e, "namespace", i), 
            n) {
                var d = h.pushDistributions(t, n, e.target, i);
                g.outDistributions = g.outDistributions || [], g.outDistributions.push({
                    targetHeadId: t.id,
                    distributionId: d
                });
            } else {
                var p = h.shadowForComponent(t);
                h.applyDistributions(m, i, p);
            }
            h.popActivity();
        });
    }, h.gradeNamesToHash = function(e) {
        var t = {};
        return h.each(e, function(e) {
            t[e] = !0, t[h.computeNickName(e)] = !0;
        }), t;
    }, h.cacheShadowGrades = function(n, r) {
        var e = h.gradeNamesToHash(n.options.gradeNames);
        e[r.memberName] || (e[r.memberName] = "memberName"), r.contextHash = e, h.each(e, function(e, t) {
            r.ownScope[t] = n, r.parentShadow && "fluid.rootComponent" !== r.parentShadow.that.type && (r.parentShadow.childrenScope[t] = n);
        });
    }, h.deliverOptionsStrategy = function(e, t, n) {
        var r = h.shadowForComponent(e, r);
        h.cacheShadowGrades(e, r), r.mergeOptions = n;
    }, h.collectDistributedGrades = function(e) {
        var t = h.receiveDistributions(null, null, null, e.that);
        if (0 < t.length) {
            var n = h.applyDistributions(e.that, t, e.shadow), r = h.transform(h.getMembers(n, [ "source", "gradeNames" ]), h.makeArray);
            h.accumulateDynamicGrades(e, h.flatten(r));
        }
    }, h.applyDynamicGrades = function(t) {
        t.oldGradeNames = h.makeArray(t.gradeNames);
        var e = h.copy(h.getMergedDefaults(t.that.typeName, t.gradeNames));
        t.gradeNames.length = 0, t.gradeNames.push.apply(t.gradeNames, e.gradeNames), h.each(t.gradeNames, function(e) {
            h.isIoCReference(e) || (t.seenGrades[e] = !0);
        });
        var n = t.shadow;
        h.cacheShadowGrades(t.that, n), n.mergeOptions.destroyValue([ "mergePolicy" ]), 
        n.mergeOptions.destroyValue([ "components" ]), n.mergeOptions.destroyValue([ "invokers" ]), 
        t.defaultsBlock.source = e, n.mergeOptions.updateBlocks(), n.mergeOptions.computeMergePolicy(), 
        h.accumulateDynamicGrades(t, e.gradeNames);
    }, h.accumulateDynamicGrades = function(t, e) {
        h.each(e, function(e) {
            t.seenGrades[e] || (h.isIoCReference(e) ? (t.rawDynamic.push(e), t.seenGrades[e] = !0) : h.contains(t.oldGradeNames, e) || t.plainDynamic.push(e));
        });
    }, h.computeDynamicGrades = function(e, t, n) {
        delete e.options.gradeNames;
        var r = h.driveStrategy(e.options, "gradeNames", n);
        r.length = 0;
        var o = {
            that: e,
            shadow: t,
            defaultsBlock: h.findMergeBlocks(t.mergeOptions.mergeBlocks, "defaults")[0],
            gradeNames: r,
            seenGrades: {},
            plainDynamic: [],
            rawDynamic: []
        };
        for (h.each(t.mergeOptions.mergeBlocks, function(e) {
            r.push.apply(r, h.makeArray(e.target && e.target.gradeNames)), h.applyDynamicGrades(o);
        }), h.collectDistributedGrades(o); ;) {
            for (;0 < o.plainDynamic.length; ) r.push.apply(r, o.plainDynamic), o.plainDynamic.length = 0, 
            h.applyDynamicGrades(o), h.collectDistributedGrades(o);
            if (!(0 < o.rawDynamic.length)) break;
            var a = h.expandImmediate(o.rawDynamic.shift(), e, t.localDynamic);
            "function" == typeof a && (a = a()), a && (o.plainDynamic = o.plainDynamic.concat(a));
        }
        t.collectedClearer && (t.collectedClearer(), delete t.collectedClearer);
    }, h.computeDynamicComponentKey = function(e, t) {
        return e + (0 === t ? "" : "-" + t);
    }, h.registerDynamicRecord = function(e, t, n, r, o) {
        var a = h.computeDynamicComponentKey(t, n), i = h.copy(r);
        return delete i[o], h.set(e.options, [ "components", a ], i), a;
    }, h.computeDynamicComponents = function(a, e) {
        var i = h.shadowForComponent(a), u = i.subcomponentLocal = {}, t = h.driveStrategy(a.options, "dynamicComponents", e.strategy);
        h.each(t, function(r, o) {
            if (r.sources || r.createOnEvent || h.fail("Cannot process dynamicComponents record ", r, ' without a "sources" or "createOnEvent" entry'), 
            r.sources) {
                var e = h.expandOptions(r.sources, a);
                h.each(e, function(e, t) {
                    var n = h.registerDynamicRecord(a, o, t, r, "sources");
                    u[n] = {
                        source: e,
                        sourcePath: t
                    };
                });
            } else if (r.createOnEvent) {
                var t = h.event.expandOneEvent(a, r.createOnEvent);
                h.set(i, [ "dynamicComponentCount", o ], 0);
                var n = function() {
                    var e = h.registerDynamicRecord(a, o, i.dynamicComponentCount[o]++, r, "createOnEvent"), t = {
                        arguments: h.makeArray(arguments)
                    };
                    h.initDependent(a, e, t);
                };
                t.addListener(n), h.recordListener(t, n, i);
            }
        });
    }, h.computeComponentAccessor = function(e, t) {
        var n = h.globalInstantiator, r = h.shadowForComponent(e);
        r.localDynamic = t;
        var o = e.options, a = r.mergeOptions.strategy, i = h.mountStrategy([ "options" ], o, a);
        r.invokerStrategy = h.recordStrategy(e, o, a, "invokers", h.invokerFromRecord), 
        r.eventStrategyBlock = h.recordStrategy(e, o, a, "events", h.eventFromRecord, [ "events" ]);
        var u = h.mountStrategy([ "events" ], e, r.eventStrategyBlock.strategy, [ "events" ]);
        if (r.memberStrategy = h.recordStrategy(e, o, a, "members", h.memberFromRecord, null, {
            model: !0,
            modelRelay: !0
        }), r.getConfig = {
            strategies: [ h.model.funcResolverStrategy, h.makeGingerStrategy(e), i, r.invokerStrategy.strategy, r.memberStrategy.strategy, u ]
        }, h.computeDynamicGrades(e, r, a, r.mergeOptions.mergeBlocks), h.distributeOptions(e, a), 
        r.contextHash["fluid.resolveRoot"]) {
            var l;
            if (r.contextHash["fluid.resolveRootSingle"]) {
                var s = h.getForComponent(e, [ "options", "singleRootType" ]);
                s || h.fail("Cannot register object with grades " + Object.keys(r.contextHash).join(", ") + " as fluid.resolveRootSingle since it has not defined option singleRootType"), 
                l = h.typeNameToMemberName(s);
            } else l = h.computeGlobalMemberName(e);
            var c = h.resolveRootComponent;
            c[l] && n.clearComponent(c, l), n.recordKnownComponent(c, e, l, !1);
        }
        return r.getConfig;
    }, h.shadowForComponent = function(e) {
        var t = h.getInstantiator(e);
        return t && e ? t.idToShadow[e.id] : null;
    }, h.getForComponent = function(e, t) {
        var n = h.shadowForComponent(e), r = n ? n.getConfig : void 0;
        return h.get(e, t, r);
    }, h.makeGingerStrategy = function(e) {
        var l = h.getInstantiator(e);
        return function(e, t, n, r) {
            var o = e[t];
            if (o === h.inEvaluationMarker && n === r.length && h.fail('Error in component configuration - a circular reference was found during evaluation of path segment "' + t + '": for more details, see the activity records following this message in the console, or issue fluid.setLogging(fluid.logLevel.TRACE) when running your application'), 
            1 < n) return o;
            if (void 0 === o && e.hasOwnProperty(t)) return h.NO_VALUE;
            if (void 0 === o) {
                var a = l.idToShadow[e.id].path, i = l.composePath(a, t);
                o = l.pathToComponent[i];
            }
            if (void 0 === o) {
                var u = h.getForComponent(e, [ "options", "components", t ]);
                u && (u.createOnEvent && h.fail('Error resolving path segment "' + t + '" of path ' + r.join(".") + " since component with record ", u, ' has annotation "createOnEvent" - this very likely represents an implementation error. Either alter the reference so it does not  match this component, or alter your workflow to ensure that the component is instantiated by the time this reference resolves'), 
                h.initDependent(e, t), o = e[t]);
            }
            return o;
        };
    }, h.frameworkGrades = [ "fluid.component", "fluid.modelComponent", "fluid.viewComponent", "fluid.rendererComponent" ], 
    h.filterBuiltinGrades = function(e) {
        return h.remove_if(h.makeArray(e), function(e) {
            return -1 !== h.frameworkGrades.indexOf(e);
        });
    }, h.dumpGradeNames = function(e) {
        return e.options && e.options.gradeNames ? " gradeNames: " + JSON.stringify(h.filterBuiltinGrades(e.options.gradeNames)) : "";
    }, h.dumpThat = function(e) {
        return '{ typeName: "' + e.typeName + '"' + h.dumpGradeNames(e) + " id: " + e.id + "}";
    }, h.dumpThatStack = function(e, n) {
        return h.transform(e, function(e) {
            var t = n.idToPath(e.id);
            return h.dumpThat(e) + (t ? " - path: " + t : "");
        }).join("\n");
    }, h.dumpComponentPath = function(e) {
        var t = h.pathForComponent(e);
        return t ? h.pathUtil.composeSegments(t) : "** no path registered for component **";
    }, h.resolveContext = function(r, e, t) {
        if ("that" === r) return e;
        if ("object" == typeof r) {
            var n = h.resolveContext(r.context, e, t);
            h.isComponent(n) || h.triggerMismatchedPathError(r.context, e);
            var o = h.getForComponent(n, r.path), a = h.expandOptions(o, e);
            return h.isComponent(a) || h.fail("Unable to resolve recursive context expression " + h.renderContextReference(r) + ": the directly resolved value of " + o + " did not resolve to a component in the scope of component ", e, ": got ", a), 
            a;
        }
        var i, u = h.globalInstantiator;
        if (t) return u.idToShadow[e.id].ownScope[r];
        var l = u.getFullStack(e);
        return h.visitComponentsForVisibility(u, l, function(e, t) {
            var n = h.shadowForComponent(e);
            return r === t || n && n.contextHash && n.contextHash[r] || r === e.typeName ? (i = e, 
            !0) : h.getForComponent(e, [ "options", "components", r ]) && !e[r] ? (i = h.getForComponent(e, r), 
            !0) : void 0;
        }), i;
    }, h.triggerMismatchedPathError = function(e, t) {
        var n = h.renderContextReference(e);
        h.fail("Failed to resolve reference " + n + " - could not match context with name " + e.context + " from component " + h.dumpThat(t) + " at path " + h.dumpComponentPath(t) + " component: ", t);
    }, h.makeStackFetcher = function(r, o, a) {
        return function(e) {
            r && "destroyed" === r.lifecycleStatus && h.fail("Cannot resolve reference " + h.renderContextReference(e) + " from component " + h.dumpThat(r) + " which has been destroyed");
            var t = e.context;
            if (o && t in o) return h.get(o[t], e.path);
            var n = h.resolveContext(t, r, a);
            return n || "" === e.path || h.triggerMismatchedPathError(e, r), h.getForComponent(n, e.path);
        };
    }, h.makeStackResolverOptions = function(e, t, n) {
        return f.extend(h.copy(h.rawDefaults("fluid.makeExpandOptions")), {
            localRecord: t || {},
            fetcher: h.makeStackFetcher(e, t, n),
            contextThat: e,
            exceptions: {
                members: {
                    model: !0,
                    modelRelay: !0
                }
            }
        });
    }, h.clearListeners = function(e) {
        h.each(e.listeners, function(e) {
            e.event.removeListener(e.listenerId || e.listener);
        }), delete e.listeners;
    }, h.recordListener = function(e, t, n, r) {
        e.ownerId !== n.that.id && h.pushArray(n, "listeners", {
            event: e,
            listener: t,
            listenerId: r
        });
    }, h.constructScopeObjects = function(e, t, n, r) {
        var o = t ? e.idToShadow[t.id] : null;
        r.childrenScope = o ? Object.create(o.ownScope) : {}, r.ownScope = Object.create(r.childrenScope), 
        r.parentShadow = o;
    }, h.clearChildrenScope = function(e, n, r, t) {
        h.each(t.contextHash, function(e, t) {
            n.childrenScope[t] === r && delete n.childrenScope[t];
        });
    }, h.instantiator = function() {
        var c = h.typeTag("instantiator");
        function i(e, t, n, r, o) {
            var a;
            if (o) (a = c.idToShadow[t.id] = {}).that = t, a.path = n, a.memberName = r, h.constructScopeObjects(c, e, t, a); else {
                (a = c.idToShadow[t.id]).injectedPaths = a.injectedPaths || {}, a.injectedPaths[n] = !0;
                var i = c.idToShadow[e.id], u = h.keys(a.contextHash);
                h.remove_if(u, function(e) {
                    return a.contextHash && "memberName" === a.contextHash[e];
                }), u.push(r), h.each(u, function(e) {
                    i.childrenScope[e] || (i.childrenScope[e] = t);
                });
            }
            c.pathToComponent[n] && h.fail("Error during instantiation - path " + n + " which has just created component " + h.dumpThat(t) + " has already been used for component " + h.dumpThat(c.pathToComponent[n]) + " - this is a circular instantiation or other oversight. Please clear the component using instantiator.clearComponent() before reusing the path."), 
            c.pathToComponent[n] = t;
        }
        return f.extend(c, {
            lifecycleStatus: "constructed",
            pathToComponent: {},
            idToShadow: {},
            modelTransactions: {
                init: {}
            },
            composePath: h.model.composePath,
            composeSegments: h.model.composeSegments,
            parseEL: h.model.parseEL,
            events: {
                onComponentAttach: h.makeEventFirer({
                    name: "instantiator's onComponentAttach event"
                }),
                onComponentClear: h.makeEventFirer({
                    name: "instantiator's onComponentClear event"
                })
            }
        }), c.idToPath = function(e) {
            var t = c.idToShadow[e];
            return t ? t.path : "";
        }, c.getThatStack = function(e) {
            var t = c.idToShadow[e.id];
            if (t) {
                for (var n = t.path, r = c.parseEL(n), o = c.pathToComponent[""], a = [], i = 0; i < r.length; ++i) o = o[r[i]], 
                a.push(o);
                return a;
            }
            return [];
        }, c.getFullStack = function(e) {
            var t = e ? c.getThatStack(e) : [];
            return t.unshift(h.resolveRootComponent), t;
        }, c.recordRoot = function(e) {
            i(null, e, "", "", !0);
        }, c.recordKnownComponent = function(e, t, n, r) {
            if (e[n] = t, h.isComponent(t) || "instantiator" === t.type) {
                var o = c.idToShadow[e.id].path, a = c.composePath(o, n);
                i(e, t, a, n, r), c.events.onComponentAttach.fire(t, a, c, r);
            } else h.fail("Cannot record non-component with value ", t, ' at path "' + n + '" of parent ', e);
        }, c.clearConcreteComponent = function(o) {
            h.each(o.childShadow.injectedPaths, function(e, t) {
                var n = h.model.getToTailPath(t), r = c.pathToComponent[n];
                c.clearComponent(r, h.model.getTailPath(t), o.child);
            }), h.clearDistributions(o.childShadow), h.clearListeners(o.childShadow), h.fireEvent(o.child, "afterDestroy", [ o.child, o.name, o.component ]), 
            delete c.idToShadow[o.child.id];
        }, c.clearComponent = function(e, t, a, i, n, r) {
            var o = c.idToShadow[e.id];
            i = i || {
                flat: !0,
                instantiator: c,
                destroyRecs: []
            }, a = a || e[t], void 0 === (r = r || o.path) && h.fail("Cannot clear component " + t + " from component ", e, " which was not created by this instantiator");
            var u = c.composePath(r, t), l = c.idToShadow[a.id];
            if (l) {
                var s = l.path === u;
                c.events.onComponentClear.fire(a, u, e, s), s ? (h.visitComponentChildren(a, function(e, t, n, r) {
                    var o = c.composeSegments.apply(null, n.slice(0, r));
                    c.clearComponent(a, t, null, i, !0, o);
                }, i, c.parseEL(u)), h.doDestroy(a, t, e), i.destroyRecs.push({
                    child: a,
                    childShadow: l,
                    name: t,
                    component: e
                })) : h.remove_if(l.injectedPaths, function(e, t) {
                    return t === u;
                }), h.clearChildrenScope(c, o, a, l), delete c.pathToComponent[u], n || (delete e[t], 
                h.each(i.destroyRecs, c.clearConcreteComponent));
            }
        }, c;
    }, h.globalInstantiator = h.instantiator(), h.getInstantiator = function(e) {
        var t = h.globalInstantiator;
        return e && t.idToShadow[e.id] ? t : null;
    }, h.defaults("fluid.resolveRoot"), h.defaults("fluid.resolveRootSingle", {
        gradeNames: "fluid.resolveRoot"
    }), h.constructRootComponents = function(e) {
        h.rootComponent = e.rootComponent = h.typeTag("fluid.rootComponent"), e.recordRoot(h.rootComponent), 
        h.resolveRootComponent = e.resolveRootComponent = h.typeTag("fluid.resolveRootComponent"), 
        e.recordKnownComponent(h.rootComponent, h.resolveRootComponent, "resolveRootComponent", !0);
        var t = e.idToShadow[h.rootComponent.id];
        t.contextHash = {};
        var n = e.idToShadow[h.resolveRootComponent.id];
        n.ownScope = t.ownScope, n.childrenScope = t.childrenScope, e.recordKnownComponent(h.resolveRootComponent, e, "instantiator", !0), 
        n.childrenScope.instantiator = e;
    }, h.constructRootComponents(h.globalInstantiator), h.expandOptions = function(e, t, n, r, o) {
        if (!e) return e;
        h.pushActivity("expandOptions", "expanding options %args for component %that ", {
            that: t,
            args: e
        });
        var a = h.makeStackResolverOptions(t, r);
        a.mergePolicy = n, a.defer = o && o.defer;
        var i = a.defer ? h.makeExpandOptions(e, a) : h.expand(e, a);
        return h.popActivity(), i;
    }, h.localRecordExpected = h.arrayToHash([ "type", "options", "container", "createOnEvent", "priority", "recordType" ]), 
    h.checkComponentRecord = function(n) {
        h.each(n, function(e, t) {
            h.localRecordExpected[t] || h.fail("Probable error in subcomponent record ", n, ' - key "' + t + '" found, where the only legal options are ' + h.keys(h.localRecordExpected).join(", "));
        });
    }, h.mergeRecordsToList = function(n, e) {
        var r = [];
        return h.each(e, function(e, t) {
            if ("distributions" === (e.recordType = t)) r.push.apply(r, h.transform(e, function(e) {
                return h.computeDistributionPriority(n, e);
            })); else {
                if (!e.options) return;
                e.priority = h.mergeRecordTypes[t], void 0 === e.priority && h.fail("Merge record with unrecognised type " + t + ": ", e), 
                r.push(e);
            }
        }), r;
    };
    h.generateExpandBlock = function(e, t, n, r) {
        var o = h.expandOptions(e.options, e.contextThat || t, n, r, {
            defer: !0
        });
        return o.priority = e.priority, o.namespace = e.namespace, o.recordType = e.recordType, 
        o;
    };
    var u = function(t, e, n, r) {
        var o, a = h.copy(e);
        o = t, h.each([ "gradeNames", "mergePolicy", "argumentMap", "components", "dynamicComponents", "events", "listeners", "modelListeners", "modelRelay", "distributeOptions", "transformOptions" ], function(e) {
            h.set(o, [ e, "*", "noexpand" ], !0);
        }), h.shadowForComponent(r).mergePolicy = t;
        var i = {
            defaults: {
                options: a
            }
        };
        f.extend(i, n.mergeRecords), i.subcomponentRecord && h.checkComponentRecord(i.subcomponentRecord);
        var u = h.mergeRecordsToList(r, i);
        return h.transform(u, function(e) {
            return h.generateExpandBlock(e, r, t, n.localRecord);
        });
    };
    h.fabricateDestroyMethod = function(e, t, n, r) {
        return function() {
            n.clearComponent(e, t, r);
        };
    }, h.computeGlobalMemberName = function(e) {
        return h.computeNickName(e.typeName) + "-" + e.id;
    }, h.typeNameToMemberName = function(e) {
        return e.replace(/\./g, "_");
    }, h.expandComponentOptions = function(e, t, n, r) {
        var o = n, a = n && n.marker === h.EXPAND ? n.instantiator : null;
        h.pushActivity("expandComponentOptions", "expanding component options %options with record %record for component %that", {
            options: a ? n.mergeRecords.user : n,
            record: o,
            that: r
        }), a || (a = h.globalInstantiator, o = {
            mergeRecords: {
                user: {
                    options: h.expandCompact(n, !0)
                }
            },
            memberName: h.computeGlobalMemberName(r),
            instantiator: a,
            parentThat: h.rootComponent
        }), r.destroy = h.fabricateDestroyMethod(o.parentThat, o.memberName, a, r), a.recordKnownComponent(o.parentThat, r, o.memberName, !0);
        var i = u(e, t, o, r);
        return h.popActivity(), i;
    }, h.assembleCreatorArguments = function(o, e, a) {
        var t = h.defaults(e);
        t && t.argumentMap || h.fail("Error in assembleCreatorArguments: cannot look up component type name " + e + " to a component creator grade with an argumentMap");
        var n = o ? h.receiveDistributions(o, t.gradeNames, a.memberName, {}) : [];
        h.each(n, function(e) {
            h.computeDistributionPriority(o, e), h.isPrimitive(e.priority) && (e.priority = h.parsePriority(e.priority, 0, !1, "options distribution"));
        }), h.sortByPriority(n);
        var i = a.localDynamic, u = f.extend({}, h.censorKeys(a.componentRecord, [ "type" ]), i), r = t.argumentMap, l = Object.keys(r).concat([ "type" ]);
        h.each(l, function(e) {
            for (var t = 0; t < n.length; ++t) void 0 !== n[t][e] && (u[e] = n[t][e]);
        }), e = u.type || e, delete u.type, delete u.options;
        var s = {
            distributions: n
        };
        void 0 !== a.componentRecord && (s.subcomponentRecord = f.extend({}, a.componentRecord));
        var c = [];
        return h.each(r, function(e, t) {
            var n;
            if ("options" === t) n = {
                marker: h.EXPAND,
                localRecord: i,
                mergeRecords: s,
                instantiator: h.getInstantiator(o),
                parentThat: o,
                memberName: a.memberName
            }; else {
                var r = u[t];
                n = h.expandImmediate(r, o, u);
            }
            c[e] = n;
        }), {
            args: c,
            funcName: e
        };
    }, h.initDependent = function(e, t, n) {
        if (!e[t]) {
            var r, o = e.options.components[t], a = h.globalInstantiator, i = a.idToShadow[e.id], u = n || i.subcomponentLocal && i.subcomponentLocal[t];
            if (h.pushActivity("initDependent", 'instantiating dependent component at path "%path" with record %record as child of %parent', {
                path: i.path + "." + t,
                record: o,
                parent: e
            }), "string" == typeof o || o.expander) e[t] = h.inEvaluationMarker, (r = h.expandImmediate(o, e)) ? a.recordKnownComponent(e, r, t, !1) : delete e[t]; else if (o.type) {
                var l = h.expandImmediate(o.type, e, u);
                l || h.fail("Error in subcomponent record: ", o.type, " could not be resolved to a type for component ", t, " of parent ", e);
                var s = h.assembleCreatorArguments(e, l, {
                    componentRecord: o,
                    memberName: t,
                    localDynamic: u
                });
                r = h.initSubcomponentImpl(e, {
                    type: s.funcName
                }, s.args);
            } else h.fail("Unrecognised material in place of subcomponent " + t + ' - no "type" field found');
            return h.popActivity(), r;
        }
    }, h.bindDeferredComponent = function(n, r, o) {
        var e = h.makeArray(o.createOnEvent);
        h.each(e, function(t) {
            var e = h.isIoCReference(t) ? h.expandOptions(t, n) : n.events[t];
            e && e.addListener || h.fail("Error instantiating createOnEvent component with name " + r + " of parent ", n, " since event specification " + t + " could not be expanded to an event - got ", e), 
            e.addListener(function() {
                h.pushActivity("initDeferred", "instantiating deferred component %componentName of parent %that due to event %eventName", {
                    componentName: r,
                    that: n,
                    eventName: t
                }), n[r] && h.globalInstantiator.clearComponent(n, r);
                var e = {
                    arguments: h.makeArray(arguments)
                };
                h.initDependent(n, r, e), h.popActivity();
            }, null, o.priority);
        });
    }, h.priorityForComponent = function(e) {
        return e.priority ? e.priority : "fluid.typeFount" === e.type || h.hasGrade(h.defaults(e.type), "fluid.typeFount") ? "first" : void 0;
    }, h.initDependents = function(r) {
        h.pushActivity("initDependents", "instantiating dependent components for component %that", {
            that: r
        });
        var e = h.shadowForComponent(r);
        if (e.memberStrategy.initter(), e.invokerStrategy.initter(), h.getForComponent(r, "modelRelay"), 
        h.getForComponent(r, "model"), !h.isDestroyed(r)) {
            var t = r.options.components || {}, o = [];
            h.each(t, function(e, t) {
                if (e.createOnEvent) h.bindDeferredComponent(r, t, e); else {
                    var n = h.priorityForComponent(e);
                    o.push({
                        namespace: t,
                        priority: h.parsePriority(n)
                    });
                }
            }), h.sortByPriority(o), h.each(o, function(e) {
                h.initDependent(r, e.namespace);
            }), e.subcomponentLocal && h.clear(e.subcomponentLocal), r.lifecycleStatus = "constructed", 
            h.assessTreeConstruction(r, e), h.popActivity();
        }
    }, h.assessTreeConstruction = function(e, t) {
        var n = h.globalInstantiator, r = n.getThatStack(e);
        h.find_if(r, function(e) {
            return "constructing" === e.lifecycleStatus;
        }) ? e.lifecycleStatus = "constructed" : h.markSubtree(n, e, t.path, "treeConstructed");
    }, h.markSubtree = function(o, e, a, i) {
        e.lifecycleStatus = i, h.visitComponentChildren(e, function(e, t) {
            var n = o.composePath(a, t), r = o.idToShadow[e.id];
            r && r.path === n && h.markSubtree(o, e, n, i);
        }, {
            flat: !0
        });
    }, h.pathForComponent = function(e, t) {
        var n = (t = t || h.getInstantiator(e) || h.globalInstantiator).idToShadow[e.id];
        return n ? t.parseEL(n.path) : null;
    }, h.construct = function(e, t, n) {
        var r = h.destroy(e, n);
        return h.set(r.parent, [ "options", "components", r.memberName ], {
            type: t.type,
            options: t
        }), h.initDependent(r.parent, r.memberName);
    }, h.destroy = function(e, t) {
        t = t || h.globalInstantiator;
        var n = h.model.parseToSegments(e, t.parseEL, !0);
        0 === n.length && h.fail("Cannot destroy the root component");
        var r = n.pop(), o = t.composeSegments.apply(null, n), a = t.pathToComponent[o];
        return a || h.fail("Cannot modify component with nonexistent parent at path ", e), 
        a[r] && a[r].destroy(), {
            parent: a,
            memberName: r
        };
    }, h.constructSingle = function(e, t, n) {
        n = n || h.globalInstantiator, e = e || "";
        var r = h.model.parseToSegments(e, n.parseEL, !0);
        "string" == typeof t && (t = {
            type: t
        });
        var o = t.type;
        o || h.fail("Cannot construct singleton object without a type entry");
        var a = (t = f.extend({}, t)).gradeNames = h.makeArray(t.gradeNames);
        a.unshift(o), t.type = "fluid.component", 0 === r.length && a.push("fluid.resolveRoot");
        var i = h.typeNameToMemberName(t.singleRootType || o);
        r.push(i), h.construct(r, t, n);
    }, h.destroySingle = function(e, t, n) {
        n = n || h.globalInstantiator;
        var r = h.model.parseToSegments(e, n.parseEL, !0), o = h.typeNameToMemberName(t);
        r.push(o), h.destroy(r, n);
    }, h.makeGradeLinkage = function(e, t, n) {
        h.defaults(e, {
            gradeNames: "fluid.component",
            distributeOptions: {
                record: n,
                target: "{/ " + t.join("&") + "}.options.gradeNames"
            }
        }), h.constructSingle([], e);
    }, h.componentForPath = function(e) {
        return h.globalInstantiator.pathToComponent[h.isArrayable(e) ? e.join(".") : e];
    }, h.debugger = function() {}, h.defaults("fluid.debuggingProbe", {
        gradeNames: [ "fluid.component" ]
    }), h.probeToDistribution = function(e) {
        var t = h.globalInstantiator, n = h.parseContextReference(e.target), r = h.model.parseToSegments(n.path, t.parseEL, !0);
        "options" !== r[0] && r.unshift("options");
        var o = h.parsePriority(e.priority);
        return o.constraint && !o.constraint.target && (o.constraint.target = "authoring"), 
        {
            target: "{/ " + n.context + "}." + t.composeSegments.apply(null, r),
            record: {
                func: e.func,
                funcName: e.funcName,
                args: e.args,
                priority: h.renderPriority(o)
            }
        };
    }, h.registerProbes = function(e) {
        var t = h.transform(e, h.probeToDistribution), n = "fluid_debuggingProbe_" + h.allocateGuid();
        return h.construct([ n ], {
            type: "fluid.debuggingProbe",
            distributeOptions: t
        }), n;
    }, h.deregisterProbes = function(e) {
        h.destroy([ e ]);
    }, h.thisistToApplicable = function(o, a, i) {
        return {
            apply: function(e, t) {
                var n = h.expandOptions(a, i);
                "string" == typeof n && (n = h.getGlobalValue(n)), n || h.fail("Could not resolve reference " + a + " to a value");
                var r = n[o.method];
                return "function" != typeof r && h.fail("Object ", n, " at reference " + a + " has no member named " + o.method + " which is a function "), 
                h.passLogLevel(h.logLevel.TRACE) && h.log(h.logLevel.TRACE, "Applying arguments ", t, " to method " + o.method + " of instance ", n), 
                r.apply(n, t);
            }
        };
    }, h.changeToApplicable = function(u, l) {
        return {
            apply: function(e, t, n, r) {
                var o = h.parseValidModelReference(l, "changePath listener record", u.changePath), a = h.expandOptions(u.value, l, {}, h.extend(n, {
                    arguments: t
                })), i = r && r.source && r.source.length ? h.makeArray(u.source).concat(r.source) : u.source;
                o.applier.change(o.modelSegs, a, u.type, i);
            }
        };
    }, h.recordToApplicable = function(e, t, n) {
        if (void 0 !== e.changePath) return h.changeToApplicable(e, t, n);
        var r = e.this;
        return e.method ^ r && h.fail("Record ", t, ' must contain both entries "method" and "this" if it contains either'), 
        e.method ? h.thisistToApplicable(e, r, t) : null;
    }, h.getGlobalValueNonComponent = function(e, t) {
        var n = h.defaults(e);
        return n && h.hasGrade(n, "fluid.component") && h.fail("Error in function specification - cannot invoke function " + e + " in the context of " + t + ": component creator functions can only be used as subcomponents"), 
        h.getGlobalValue(e);
    }, h.makeInvoker = function(n, r, o) {
        void 0 === (r = h.upgradePrimitiveFunc(r)).args || r.args === h.NO_VALUE || h.isArrayable(r.args) || (r.args = h.makeArray(r.args));
        var a = h.recordToApplicable(r, n), i = h.preExpand(r.args), u = {}, l = h.makeStackResolverOptions(n, u, !0);
        return (a = a || (r.funcName ? h.getGlobalValueNonComponent(r.funcName, "an invoker") : h.expandImmediate(r.func, n))) && a.apply ? a === h.notImplemented && h.fail("Error constructing component ", n, " - the invoker named " + o + " which was defined in grade " + r.componentSource + " needs to be overridden with a concrete implementation") : h.fail("Error in invoker record: could not resolve members func, funcName or method to a function implementation - got " + a + " from ", r), 
        function() {
            var e, t;
            return !1 === h.defeatLogging && h.pushActivity("invokeInvoker", "invoking invoker with name %name and record %record from path %path holding component %that", {
                name: o,
                record: r,
                path: h.dumpComponentPath(n),
                that: n
            }), "destroyed" === n.lifecycleStatus ? h.log(h.logLevel.WARN, "Ignoring call to invoker " + o + " of component ", n, " which has been destroyed") : (u.arguments = arguments, 
            void 0 === r.args || r.args === h.NO_VALUE ? t = arguments : (h.expandImmediateImpl(i, l), 
            t = i.source), e = a.apply(null, t)), !1 === h.defeatLogging && h.popActivity(), 
            e;
        };
    }, h.event.makeTrackedListenerAdder = function(e) {
        var i = h.shadowForComponent(e);
        return function(a) {
            return {
                addListener: function(e, t, n, r, o) {
                    h.recordListener(a, e, i, o), a.addListener.apply(null, arguments);
                }
            };
        };
    }, h.event.listenerEngine = function(n, r, o) {
        var a = {};
        h.each(n, function(e, t) {
            o(e).addListener(function() {
                a[t] = h.makeArray(arguments), function() {
                    if (!h.find(n, function(e, t) {
                        if (void 0 === a[t]) return !0;
                    })) {
                        var e = a;
                        a = {}, r(e);
                    }
                }();
            });
        });
    }, h.event.dispatchListener = function(r, o, a, i, u) {
        void 0 === i.args || i.args === h.NO_VALUE || h.isArrayable(i.args) || (i.args = h.makeArray(i.args)), 
        o = h.event.resolveListener(o);
        var l = h.preExpand(i.args), s = {}, c = h.makeStackResolverOptions(r, s, !0), e = function() {
            !1 === h.defeatLogging && h.pushActivity("dispatchListener", "firing to listener to event named %eventName of component %that", {
                eventName: a,
                that: r
            });
            var e, t = u ? arguments[0] : arguments;
            s.arguments = t, void 0 !== i.args && i.args !== h.NO_VALUE ? (h.expandImmediateImpl(l, c), 
            e = l.source) : e = t;
            var n = o.apply(null, e);
            return !1 === h.defeatLogging && h.popActivity(), n;
        };
        return h.event.impersonateListener(o, e), e;
    }, h.event.resolveSoftNamespace = function(e) {
        if ("string" != typeof e) return null;
        var t = Math.max(e.lastIndexOf("."), e.lastIndexOf("}"));
        return e.substring(t + 1);
    }, h.event.resolveListenerRecord = function(e, i, u, l, s) {
        var c = function(e, t) {
            h.fail("Error in listener record - could not resolve reference ", e, ' to a listener or firer. Did you miss out "events." when referring to an event firer?' + t);
        };
        h.pushActivity("resolveListenerRecord", "resolving listener record for event named %eventName for component %that", {
            eventName: u,
            that: i
        });
        var t = h.makeArray(e), n = {
            records: h.transform(t, function(e) {
                var t = h.isPrimitive(e) || e.expander ? {
                    listener: e
                } : h.copy(e), n = h.recordToApplicable(e, i, s);
                t.listener = n || (t.listener || t.func || t.funcName), t.listener || c(e, ' Listener record must contain a member named "listener", "func", "funcName" or "method"');
                var r = e.method ? h.event.resolveSoftNamespace(e.this) + "." + e.method : h.event.resolveSoftNamespace(t.listener);
                t.namespace || l || !r || (t.softNamespace = !0, t.namespace = (e.componentSource ? e.componentSource : i.typeName) + "." + r);
                var o = t.listener = h.expandOptions(t.listener, i);
                o || c(e, "");
                var a = !1;
                return "fluid.event.firer" === o.typeName && (o = o.fire, a = !0), t.listener = s && (t.args && "fluid.notImplemented" !== o || a) ? h.event.dispatchListener(i, o, u, t) : o, 
                t.listenerId = h.allocateGuid(), t;
            }),
            adderWrapper: s ? h.event.makeTrackedListenerAdder(i) : null
        };
        return h.popActivity(), n;
    }, h.event.expandOneEvent = function(e, t) {
        var n;
        return (n = "string" == typeof t && "{" !== t.charAt(0) ? h.getForComponent(e, [ "events", t ]) : h.expandOptions(t, e)) && "fluid.event.firer" === n.typeName || h.fail("Error in event specification - could not resolve base event reference ", t, " to an event firer: got ", n), 
        n;
    }, h.event.expandEvents = function(t, e) {
        return "string" == typeof e ? h.event.expandOneEvent(t, e) : h.transform(e, function(e) {
            return h.event.expandOneEvent(t, e);
        });
    }, h.event.resolveEvent = function(i, u, l) {
        h.pushActivity("resolveEvent", "resolving event with name %eventName attached to component %that", {
            eventName: u,
            that: i
        });
        var s = h.event.makeTrackedListenerAdder(i);
        "string" == typeof l && (l = {
            event: l
        });
        var e = "fluid.event.firer" === l.typeName ? l : l.event || l.events;
        e || h.fail("Event specification for event with name " + u + " does not include a base event specification: ", l);
        var t, c = "fluid.event.firer" === e.typeName ? e : h.event.expandEvents(i, e), n = "fluid.event.firer" !== c.typeName;
        if (l.args || n) {
            t = h.makeEventFirer({
                name: " [composite] " + h.event.nameEvent(i, u)
            });
            var r = h.event.dispatchListener(i, t.fire, u, l, n);
            n ? h.event.listenerEngine(c, r, s) : s(c).addListener(r);
        } else t = {
            typeName: "fluid.event.firer",
            fire: function() {
                var e = h.makeArray(arguments);
                h.pushActivity("fireSynthetic", "firing synthetic event %eventName ", {
                    eventName: u
                });
                var t = c.fire.apply(null, e);
                return h.popActivity(), t;
            },
            addListener: function(e, t, n, r, o) {
                var a = h.event.dispatchListener(i, e, u, l);
                s(c).addListener(a, t, n, r, o);
            },
            removeListener: function(e) {
                c.removeListener(e);
            }
        };
        return h.popActivity(), t;
    }, h.withEnvironment = function(e, t, n) {
        var r;
        n = n || h.globalThreadLocal();
        try {
            for (r in e) n[r] = e[r];
            return f.extend(n, e), t();
        } finally {
            for (r in e) delete n[r];
        }
    }, h.fetchContextReference = function(e, t, n, r, o) {
        r && (e = r(e, n));
        var a = e.context ? n[e.context] : t;
        return a ? e.noDereference ? e.path : h.get(a, e.path) : o && o(e) || a;
    }, h.makeEnvironmentFetcher = function(n, r, o, a) {
        return o = o || h.globalThreadLocal, function(e) {
            var t = o();
            return h.fetchContextReference(e, n, t, r, a);
        };
    }, h.coerceToPrimitive = function(e) {
        return "false" !== e && ("true" === e || (isFinite(e) ? Number(e) : e));
    }, h.compactStringToRec = function(e, t) {
        var n = e.indexOf("("), r = e.indexOf(")");
        if ((-1 === n ^ -1 === r || r < n) && h.fail("Badly-formed compact " + t + " record without matching parentheses: " + e), 
        -1 !== n && -1 !== r) {
            var o = e.substring(r + 1);
            "" !== f.trim(o) && h.fail("Badly-formed compact " + t + " record " + e + " - unexpected material following close parenthesis: " + o);
            var a = e.substring(0, n), i = f.trim(e.substring(n + 1, r)), u = "" === i ? [] : h.transform(i.split(","), f.trim, h.coerceToPrimitive), l = h.upgradePrimitiveFunc(a, null);
            return l.args = u, l;
        }
        return "expander" === t && h.fail("Badly-formed compact expander record without parentheses: " + e), 
        e;
    }, h.expandPrefix = "@expand:", h.expandCompactString = function(e, t) {
        var n = e;
        if (0 === e.indexOf(h.expandPrefix)) {
            var r = e.substring(h.expandPrefix.length);
            n = {
                expander: h.compactStringToRec(r, "expander")
            };
        } else t && (n = h.compactStringToRec(e, t));
        return n;
    };
    var a = {
        listeners: "listener",
        modelListeners: "modelListener"
    }, i = f.extend({
        invokers: "invoker"
    }, a);
    function c(e, t, n, r) {
        for (var o = 0; o < n; ++o) e = r(e, t[o], o, h.makeArray(t));
        return e;
    }
    h.expandCompactRec = function(n, r, e) {
        h.guardCircularExpansion(n, n.length);
        var t = 0 < n.length ? n[n.length - 1] : "", o = i[t];
        !o && 1 < n.length && (o = a[n[n.length - 2]]), h.each(e, function(e, t) {
            if (h.isPlainObject(e)) return r[t] = h.freshContainer(e), n.push(t), h.expandCompactRec(n, r[t], e), 
            void n.pop();
            "string" == typeof e && (e = h.expandCompactString(e, o)), r[t] = e;
        });
    }, h.expandCompact = function(e) {
        var t = {};
        return h.expandCompactRec([], t, e), t;
    }, h.extractEL = function(e, t) {
        if ("ALL" === t.ELstyle) return e;
        if (1 === t.ELstyle.length) {
            if (e.charAt(0) === t.ELstyle) return e.substring(1);
        } else if ("${}" === t.ELstyle) {
            var n = e.indexOf("${"), r = e.lastIndexOf("}");
            if (0 === n && -1 !== r) return e.substring(2, r);
        }
    }, h.extractELWithContext = function(e, t) {
        var n = h.extractEL(e, t);
        return h.isIoCReference(n) ? h.parseContextReference(n) : n ? {
            path: n
        } : n;
    }, h.parseContextReference = function(e, t, n) {
        t = t || 0;
        var r, o, a, i = "{" === e.charAt(t + 1);
        -1 === (r = i ? (a = h.parseContextReference(e, t + 1, "}")).endpos : e.indexOf("}", t + 1)) && h.fail('Cannot parse context reference "' + e + '": Malformed context reference without }'), 
        o = i ? a : e.substring(t + 1, r);
        var u = n ? e.indexOf(n, r + 1) : e.length, l = e.substring(r + 1, u);
        return "." === l.charAt(0) && (l = l.substring(1)), {
            context: o,
            path: l,
            endpos: u
        };
    }, h.renderContextReference = function(e) {
        var t = e.context;
        return "{" + ("string" == typeof t ? t : h.renderContextReference(t)) + "}" + (e.path ? "." + e.path : "");
    }, h.resolveContextValue = function(e, n) {
        function t(e) {
            h.pushActivity("resolveContextValue", "resolving context value %parsed", {
                parsed: e
            });
            var t = n.fetcher(e);
            return h.pushActivity("resolvedContextValue", "resolved value %parsed to value %value", {
                parsed: e,
                value: t
            }), h.popActivity(2), t;
        }
        var r;
        if (n.bareContextRefs && h.isIoCReference(e)) return t(r = h.parseContextReference(e));
        if (n.ELstyle && "${}" !== n.ELstyle && (r = h.extractELWithContext(e, n))) return t(r);
        for (;"string" == typeof e; ) {
            var o = e.indexOf("${"), a = e.indexOf("}", o + 2);
            if (-1 === o || -1 === a) break;
            "{" === e.charAt(o + 2) ? a = (r = h.parseContextReference(e, o + 2, "}")).endpos : r = {
                path: e.substring(o + 2, a)
            };
            var i = t(r), u = 0 === o && a === e.length - 1;
            if (null == i) return i;
            e = u ? i : e.substring(0, o) + i + e.substring(a + 1);
        }
        return e;
    }, h.fetchExpandChildren = function(n, r, o, a, i, u) {
        if (a.expander) {
            var e = h.expandExpander(n, a, u);
            if (h.isPrimitive(e) || !h.isPlainObject(e) || h.isArrayable(e) ^ h.isArrayable(n)) return e;
            f.extend(!0, n, e);
        }
        return h.each(a, function(e, t) {
            void 0 === e ? n[t] = void 0 : "expander" !== t && (o[r] = t, !0 !== h.getImmediate(u.exceptions, o, r) && u.strategy(n, t, r + 1, o, a, i));
        }), n;
    }, h.isUnexpandable = function(e) {
        return h.isPrimitive(e) || !h.isPlainObject(e);
    }, h.expandSource = function(e, t, n, r, o, a, i, u) {
        var l, s, c = h.derefMergePolicy(i);
        return "string" != typeof a || c.noexpand ? c.noexpand || h.isUnexpandable(a) ? l = a : a.expander ? l = h.expandExpander(o, a, e) : (l = h.freshContainer(a), 
        s = !0) : e.defaultEL && "{" !== a.charAt(0) ? l = a : (h.pushActivity("expandContextValue", "expanding context value %source held at path %path", {
            source: a,
            path: h.path.apply(null, r.slice(0, n))
        }), l = h.resolveContextValue(a, e), h.popActivity(1)), l !== h.NO_VALUE && o(l), 
        s && u(l, a, n, r, i), l;
    }, h.guardCircularExpansion = function(e, t) {
        t > h.strategyRecursionBailout && h.fail("Overflow/circularity in options expansion, current path is ", e, " at depth ", t, ' - please ensure options are not circularly connected, or protect from expansion using the "noexpand" policy or expander');
    }, h.makeExpandStrategy = function(l) {
        var s = function(e, t, n, r, o) {
            return h.fetchExpandChildren(e, n || 0, r || [], t, o, l);
        }, e = function(t, n, e, r, o, a) {
            if (h.guardCircularExpansion(r, e), t) {
                if (t.hasOwnProperty(n)) return t[n];
                void 0 === o && (o = c(l.source, r, e - 1, l.sourceStrategy), a = c(l.mergePolicy, r, e - 1, h.concreteTrundler));
                var i = l.sourceStrategy(o, n, e, r), u = h.concreteTrundler(a, n);
                return h.expandSource(l, t, e, r, function(e) {
                    t[n] = e;
                }, i, u, s);
            }
        };
        return l.recurse = s, l.strategy = e;
    }, h.defaults("fluid.makeExpandOptions", {
        ELstyle: "${}",
        bareContextRefs: !0,
        target: h.inCreationMarker
    }), h.makeExpandOptions = function(e, t) {
        return (t = f.extend({}, h.rawDefaults("fluid.makeExpandOptions"), t)).defaultEL = "${}" === t.ELStyle && t.bareContextRefs, 
        t.expandSource = function(e) {
            return h.expandSource(t, null, 0, [], h.identity, e, t.mergePolicy, !1);
        }, h.isUnexpandable(e) ? (t.strategy = h.concreteTrundler, t.initter = h.identity, 
        t.target = "string" == typeof e ? (t.defer ? h.copy : h.identity)(t.expandSource(e)) : e, 
        t.immutableTarget = !0) : (t.source = e, t.target = h.freshContainer(e), t.sourceStrategy = t.sourceStrategy || h.concreteTrundler, 
        h.makeExpandStrategy(t), t.initter = function() {
            t.target = h.fetchExpandChildren(t.target, 0, [], t.source, t.mergePolicy, t);
        }), t;
    }, h.expand = function(e, t) {
        var n = h.makeExpandOptions(e, t);
        return n.initter(), n.target;
    }, h.preExpandRecurse = function(n, r, t, o, a) {
        function e(e) {
            n.expanders.push({
                expander: e,
                holder: t,
                member: o
            }), delete t[o];
        }
        if (h.guardCircularExpansion(a, a.length), h.isIoCReference(r)) {
            var i = h.parseContextReference(r), u = h.model.parseEL(i.path);
            e({
                typeFunc: h.expander.fetch,
                context: i.context,
                segs: u
            });
        } else h.isPlainObject(r) && (r.expander ? (r.expander.typeFunc = h.getGlobalValue(r.expander.type || "fluid.invokeFunc"), 
        e(r.expander)) : h.each(r, function(e, t) {
            a.push(t), h.preExpandRecurse(n, e, r, t, a), a.pop();
        }));
    }, h.preExpand = function(e) {
        var t = {
            expanders: [],
            source: h.isUnexpandable(e) ? e : h.copy(e)
        };
        return h.preExpandRecurse(t, t.source, t, "source", []), t;
    }, h.expandImmediate = function(e, t, n) {
        var r = h.makeStackResolverOptions(t, n, !0), o = h.preExpand(e);
        return h.expandImmediateImpl(o, r), o.source;
    }, h.expandImmediateImpl = function(e, t) {
        for (var n = e.expanders, r = 0; r < n.length; ++r) {
            var o = n[r];
            o.holder[o.member] = o.expander.typeFunc(null, o, t);
        }
    }, h.expandExpander = function(e, t, n) {
        var r = h.getGlobalValue(t.expander.type || "fluid.invokeFunc");
        return r || h.fail("Unknown expander with type " + t.expander.type), r(e, t, n);
    }, h.registerNamespace("fluid.expander"), h.expander.fetch = function(e, t, n) {
        var r = n.localRecord, o = t.expander.context, a = t.expander.segs, i = void 0 !== r[o], u = n.contextThat.lifecycleStatus, l = "treeConstructed" === u || "destroyed" === u, s = i ? r[o] : h.resolveContext(o, n.contextThat, l);
        if (s) {
            var c = s;
            if (i || "constructing" !== s.lifecycleStatus) for (var f = 0; f < a.length; ++f) c = c ? c[a[f]] : void 0; else c = h.getForComponent(s, a);
            return void 0 !== c || i || (c = h.getForComponent(s, a)), c;
        }
        0 < a.length && h.triggerMismatchedPathError(t.expander, n.contextThat);
    }, h.invokeFunc = function(e, t, n) {
        var r = t.expander, o = h.makeArray(r.args);
        r.args = o, o = n.recurse ? n.recurse([], o) : (r = h.expandImmediate(r, n.contextThat, n.localRecord)).args;
        var a = r.func || r.funcName, i = (n.expandSource ? n.expandSource(a) : a) || h.recordToApplicable(r, n.contextThat);
        return "string" == typeof i && (i = h.getGlobalValue(i)), i || h.fail("Error in expander record ", r, ": " + a + " could not be resolved to a function for component ", n.contextThat), 
        i.apply(null, o);
    }, h.noexpand = function(e, t) {
        return t.expander.value ? t.expander.value : t.expander.tree;
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(n, y) {
    "use strict";
    y.model.makeEnvironmentStrategy = function(r) {
        return function(e, t, n) {
            return 0 === n && r[t] ? r[t] : void 0;
        };
    }, y.model.defaultCreatorStrategy = function(e, t) {
        if (void 0 === e[t]) return e[t] = {}, e[t];
    }, y.model.defaultFetchStrategy = function(e, t) {
        return e[t];
    }, y.model.funcResolverStrategy = function(e, t) {
        if (e.resolvePathSegment) return e.resolvePathSegment(t);
    }, y.model.traverseWithStrategy = function(e, t, n, r, o) {
        for (var a = r.strategies, i = t.length - o, u = n; u < i; ++u) {
            if (!e) return e;
            for (var l, s = 0; s < a.length && void 0 === (l = a[s](e, t[u], u + 1, t)); ++s) ;
            l === y.NO_VALUE && (l = void 0), e = l;
        }
        return e;
    }, y.model.getValueAndSegments = function(e, t, n, r) {
        return y.model.accessWithStrategy(e, t, y.NO_VALUE, n, r, !0);
    }, y.model.makeTrundler = function(n) {
        return function(e, t) {
            return y.model.getValueAndSegments(e.root, t, n, e.segs);
        };
    }, y.model.getWithStrategy = function(e, t, n, r) {
        return y.model.accessWithStrategy(e, t, y.NO_VALUE, n, r);
    }, y.model.setWithStrategy = function(e, t, n, r, o) {
        y.model.accessWithStrategy(e, t, n, r, o);
    }, y.model.accessWithStrategy = function(e, t, n, r, o, a) {
        if (y.isPrimitive(t) || y.isArrayable(t)) return y.model.accessImpl(e, t, n, r, o, a, y.model.traverseWithStrategy);
        var i = t.type || "default", u = r.resolvers[i];
        u || y.fail("Unable to find resolver of type " + i);
        var l = y.model.makeTrundler(r), s = {
            root: e,
            segs: o
        };
        return s = u(s, t, l), t.path && s && (s = l(s, t.path)), a ? s : s ? s.root : void 0;
    }, y.registerNamespace("fluid.pathUtil"), y.pathUtil.getPathSegmentImpl = function(e, t, n) {
        var r = null;
        e && (r = "");
        for (var o = !1, a = t.length; n < a; ++n) {
            var i = t.charAt(n);
            if (o) o = !1, null !== r && (r += i); else {
                if ("." === i) break;
                "\\" === i ? o = !0 : null !== r && (r += i);
            }
        }
        return null !== r && (e[0] = r), n;
    };
    var a = [];
    y.pathUtil.parseEL = function(e) {
        for (var t = [], n = 0, r = e.length; n < r; ) {
            var o = y.pathUtil.getPathSegmentImpl(a, e, n);
            t.push(a[0]), n = o + 1;
        }
        return t;
    }, y.pathUtil.composeSegment = function(e, t) {
        t = t.toString();
        for (var n = 0; n < t.length; ++n) {
            var r = t.charAt(n);
            "." !== r && "\\" !== r && "}" !== r || (e += "\\"), e += r;
        }
        return e;
    }, y.pathUtil.escapeSegment = function(e) {
        return y.pathUtil.composeSegment("", e);
    }, y.pathUtil.composePath = function(e, t) {
        return 0 !== e.length && (e += "."), y.pathUtil.composeSegment(e, t);
    }, y.pathUtil.composeSegments = function() {
        for (var e = "", t = 0; t < arguments.length; ++t) e = y.pathUtil.composePath(e, arguments[t]);
        return e;
    }, y.pathUtil.matchSegments = function(e, t, n, r) {
        if (r - n !== e.length) return !1;
        for (var o = n; o < r; ++o) if (t[o] !== e[o - n]) return !1;
        return !0;
    }, y.model.unescapedParser = {
        parse: y.model.parseEL,
        compose: y.model.composeSegments
    }, y.model.defaultGetConfig = {
        parser: y.model.unescapedParser,
        strategies: [ y.model.funcResolverStrategy, y.model.defaultFetchStrategy ]
    }, y.model.defaultSetConfig = {
        parser: y.model.unescapedParser,
        strategies: [ y.model.funcResolverStrategy, y.model.defaultFetchStrategy, y.model.defaultCreatorStrategy ]
    }, y.model.escapedParser = {
        parse: y.pathUtil.parseEL,
        compose: y.pathUtil.composeSegments
    }, y.model.escapedGetConfig = {
        parser: y.model.escapedParser,
        strategies: [ y.model.defaultFetchStrategy ]
    }, y.model.escapedSetConfig = {
        parser: y.model.escapedParser,
        strategies: [ y.model.defaultFetchStrategy, y.model.defaultCreatorStrategy ]
    }, y.stronglyConnected = function(e, t) {
        var n = {
            stack: [],
            accessor: t,
            components: [],
            index: 0
        };
        return e.forEach(function(e) {
            void 0 === e.tarjanIndex && y.stronglyConnectedOne(e, n);
        }), n.components;
    }, y.stronglyConnectedOne = function(t, n) {
        if (t.tarjanIndex = n.index, t.lowIndex = n.index, ++n.index, n.stack.push(t), t.onStack = !0, 
        n.accessor(t).forEach(function(e) {
            void 0 === e.tarjanIndex ? (y.stronglyConnectedOne(e, n), t.lowIndex = Math.min(t.lowIndex, e.lowIndex)) : e.onStack && (t.lowIndex = Math.min(t.lowIndex, e.tarjanIndex));
        }), t.lowIndex === t.tarjanIndex) {
            for (var e, r = []; (e = n.stack.pop()).onStack = !1, r.push(e), e !== t; ) ;
            n.components.push(r);
        }
    }, y.initRelayModel = function(e) {
        return y.deenlistModelComponent(e), e.model;
    }, y.isModelComplete = function(e) {
        return "model" in e && e.model !== y.inEvaluationMarker;
    }, y.enlistModelComponent = function(e) {
        var t = y.getInstantiator(e), n = t.modelTransactions.init[e.id];
        return n || (n = {
            that: e,
            applier: y.getForComponent(e, "applier"),
            complete: y.isModelComplete(e)
        }, t.modelTransactions.init[e.id] = n), n;
    }, y.clearTransactions = function() {
        var e = y.globalInstantiator;
        y.clear(e.modelTransactions), e.modelTransactions.init = {};
    }, y.failureEvent.addListener(y.clearTransactions, "clearTransactions", "before:fail"), 
    y.clearLinkCounts = function(n, r) {
        y.each(n, function(e, t) {
            "number" == typeof e ? n[t] = 0 : r && e.options && "number" == typeof e.relayCount && (e.relayCount = 0);
        });
    }, y.computeInitialOutArcs = function(a, i) {
        return y.transform(i, function(e, n) {
            var r = {}, t = e.that.applier.listeners.sortedListeners;
            y.each(t, function(e) {
                if (e.isRelay && !y.isExcludedChangeSource(a[n], e.cond)) {
                    var t = e.targetId;
                    t !== n && (r[t] = !0);
                }
            });
            var o = Object.keys(r).map(function(e) {
                return i[e];
            });
            return y.remove_if(o, function(e) {
                return void 0 === e;
            }), o;
        });
    }, y.sortCompleteLast = function(e, t) {
        return (e.completeOnInit ? 1 : 0) - (t.completeOnInit ? 1 : 0);
    }, y.operateInitialTransaction = function(e, t) {
        var n, r = y.allocateGuid(), o = y.getModelTransactionRec(e, r), a = y.transform(t, function(e) {
            return n = e.that.applier.initiate(null, "init", r), o[e.that.applier.applierId] = {
                transaction: n
            }, n;
        }), i = y.computeInitialOutArcs(a, t), u = y.values(t), l = y.stronglyConnected(u, function(e) {
            return i[e.that.id];
        }), s = 0;
        l.forEach(function(e) {
            e.forEach(function(e) {
                e.initPriority = e.completeOnInit ? Math.Infinity : s++;
            });
        }), u.sort(function(e, t) {
            return e.initPriority - t.initPriority;
        }), u.forEach(function(e) {
            var t = e.that, n = a[t.id];
            e.completeOnInit ? y.initModelEvent(t, t.applier, n, t.applier.listeners.sortedListeners) : y.each(e.initModels, function(e) {
                n.fireChangeRequest({
                    type: "ADD",
                    segs: [],
                    value: e
                }), y.clearLinkCounts(o, !0);
            });
            var r = y.shadowForComponent(t);
            r && (r.modelComplete = !0);
        }), n.commit();
    }, y.deenlistModelComponent = function(e) {
        var t = y.getInstantiator(e), n = t.modelTransactions.init;
        if (n[e.id] && (e.model = void 0, n[e.id].complete = !0, !y.find_if(n, function(e) {
            return !0 !== e.complete;
        }))) {
            try {
                y.operateInitialTransaction(e, n);
            } catch (e) {
                throw y.clearTransactions(), e;
            }
            t.modelTransactions.init = {};
        }
    }, y.parseModelReference = function(e, t) {
        var n = y.parseContextReference(t);
        return n.segs = e.applier.parseEL(n.path), n;
    }, y.parseValidModelReference = function(e, t, n, r) {
        var o, a, i, u = function() {
            var e = [ "Error in " + t + ": ", n ].concat(y.makeArray(arguments));
            y.fail.apply(null, e);
        }, l = function(e) {
            u(" must be a reference to a component with a ChangeApplier (descended from fluid.modelComponent), instead got ", e);
        };
        if ("string" == typeof n) if (y.isIoCReference(n)) {
            var s = (o = y.parseModelReference(e, n)).segs.indexOf("model");
            -1 === s ? r ? o.nonModel = !0 : u(' must be a reference into a component model via a path including the segment "model"') : (o.modelSegs = o.segs.slice(s + 1), 
            o.contextSegs = o.segs.slice(0, s), delete o.path);
        } else o = {
            path: n,
            modelSegs: e.applier.parseEL(n)
        }; else y.isArrayable(n.segs) || u(' must contain an entry "segs" holding path segments referring a model path within a component'), 
        o = {
            context: n.context,
            modelSegs: y.expandOptions(n.segs, e)
        };
        return o.context ? ((a = y.resolveContext(o.context, e)) || u(" context must be a reference to an existing component"), 
        i = o.contextSegs ? y.getForComponent(a, o.contextSegs) : a) : i = e, o.nonModel || (y.isComponent(i) || l(i), 
        i.applier || y.getForComponent(i, [ "applier" ]), i.applier || l(i)), o.that = i, 
        o.applier = i && i.applier, o.path || (o.path = i && i.applier.composeSegments.apply(null, o.modelSegs)), 
        o;
    }, y.getModelTransactionRec = function(e, t) {
        var n = y.getInstantiator(e);
        if (t || y.fail("Cannot get transaction record without transaction id"), !n) return null;
        var r = n.modelTransactions[t];
        return r || (r = n.modelTransactions[t] = {
            relays: [],
            sources: {},
            externalChanges: {}
        }), r;
    }, y.recordChangeListener = function(e, t, n, r) {
        var o = y.shadowForComponent(e);
        y.recordListener(t.modelChanged, n, o, r);
    }, y.registerRelayTransaction = function(e, t, n, r, o) {
        var a = t.initiate("relay", null, n), i = e[t.applierId] = {
            transaction: a,
            relayCount: 0,
            namespace: o.namespace,
            priority: o.priority,
            options: r
        };
        return i.priority = y.parsePriority(i.priority, e.relays.length, !1, "model relay"), 
        e.relays.push(i), i;
    }, y.relayRecursionBailout = 100, y.registerDirectChangeRelay = function(s, c, e, f, d, p, m, g) {
        var h = m.targetApplier || s.applier, t = m.sourceApplier || e.applier, v = h.applierId;
        c = y.makeArray(c), f = y.makeArray(f);
        var n = function(e, t, n, r, o, a) {
            var i = o.id, u = y.getModelTransactionRec(s, i);
            a && o && !u[a.applierId] && (u[a.applierId] = {
                transaction: o
            });
            var l = u[v];
            u[d] = u[d] || 0;
            ++u[d], u[d] > y.relayRecursionBailout && y.fail("Error in model relay specification at component ", s, " - operated more than " + y.relayRecursionBailout + " relays without model value settling - current model contents are ", o.newHolder.model), 
            l || (l = y.registerRelayTransaction(u, h, i, m, g)), p && !m.targetApplier ? p(l.transaction, m.sourceApplier ? void 0 : e, f, c, r) : (r && "DELETE" === r.type && l.transaction.fireChangeRequest({
                type: "DELETE",
                segs: c
            }), void 0 !== e && l.transaction.fireChangeRequest({
                type: "ADD",
                segs: c,
                value: e
            }));
        }, r = t.modelChanged.addListener({
            isRelay: !0,
            cond: p && p.cond,
            targetId: s.id,
            targetApplierId: h.id,
            segs: f,
            transactional: m.transactional
        }, n);
        y.passLogLevel(y.logLevel.TRACE) && y.log(y.logLevel.TRACE, "Adding relay listener with listenerId " + r.listenerId + " to source applier with id " + t.applierId + " from target applier with id " + v + " for target component with id " + s.id), 
        e && (y.recordChangeListener(e, t, n, r.listenerId), s !== e && y.recordChangeListener(s, t, n, r.listenerId));
    }, y.connectModelRelay = function(e, t, n, r, o) {
        var a = y.allocateGuid();
        function i(e) {
            var t = y.enlistModelComponent(e);
            t.complete && (y.shadowForComponent(e).modelComplete && (t.completeOnInit = !0));
        }
        i(n), i(e);
        var u = y.filterKeys(o, [ "namespace", "priority" ]);
        o.update ? o.targetApplier ? y.registerDirectChangeRelay(e, t, n, r, a, null, {
            transactional: !1,
            targetApplier: o.targetApplier,
            update: o.update
        }, u) : y.registerDirectChangeRelay(n, r, e, [], a + "-transform", o.forwardAdapter, {
            transactional: !0,
            sourceApplier: o.forwardApplier
        }, u) : (y.registerDirectChangeRelay(n, r, e, t, a, o.forwardAdapter, {
            transactional: !1
        }, u), y.registerDirectChangeRelay(e, t, n, r, a, o.backwardAdapter, {
            transactional: !1
        }, u));
    }, y.parseSourceExclusionSpec = function(e, t) {
        return e.excludeSource = y.arrayToHash(y.makeArray(t.excludeSource || (t.includeSource ? "*" : void 0))), 
        e.includeSource = y.arrayToHash(y.makeArray(t.includeSource)), e;
    }, y.isExcludedChangeSource = function(e, t) {
        if (!t || !t.excludeSource) return !1;
        var n = t.excludeSource["*"];
        for (var r in e.fullSources) t.excludeSource[r] && (n = !0), t.includeSource[r] && (n = !1);
        return n;
    }, y.model.guardedAdapter = function(e, t, n, r) {
        y.isExcludedChangeSource(e, t) || n === y.model.transform.uninvertibleTransform || n.apply(null, r);
    }, y.transformToAdapter = function(e, a) {
        var i = {};
        return i[a] = e, function(e, t, n, r, o) {
            o && "DELETE" === o.type && e.fireChangeRequest({
                type: "DELETE",
                path: a
            }), y.model.transformWithRules(t, i, {
                finalApplier: e
            });
        };
    }, y.makeTransformPackage = function(e, n, r, o, a, t, i, u) {
        var l = {
            forwardHolder: {
                model: n
            },
            backwardHolder: {
                model: null
            },
            generateAdapters: function(e) {
                if (l.forwardAdapterImpl = y.transformToAdapter(e ? e.newHolder.model : l.forwardHolder.model, o), 
                null !== r) {
                    var t = y.model.transform.invertConfiguration(n);
                    t !== y.model.transform.uninvertibleTransform ? (l.backwardHolder.model = t, l.backwardAdapterImpl = y.transformToAdapter(l.backwardHolder.model, r)) : l.backwardAdapterImpl = t;
                }
            },
            forwardAdapter: function(e, t) {
                void 0 === t && l.generateAdapters(), y.model.guardedAdapter(e, a, l.forwardAdapterImpl, arguments);
            }
        };
        l.forwardAdapter.cond = a, l.runTransform = function(e) {
            e.commit(), e.reset();
        }, l.forwardApplier = y.makeHolderChangeApplier(l.forwardHolder), l.forwardApplier.isRelayApplier = !0, 
        l.invalidator = y.makeEventFirer({
            name: "Invalidator for model relay with applier " + l.forwardApplier.applierId
        }), null !== r && (l.backwardApplier = y.makeHolderChangeApplier(l.backwardHolder), 
        l.backwardAdapter = function(e) {
            y.model.guardedAdapter(e, t, l.backwardAdapterImpl, arguments);
        }, l.backwardAdapter.cond = t), l.update = l.invalidator.fire;
        var s = {
            targetApplier: l.forwardApplier,
            update: l.update,
            namespace: i,
            priority: u,
            refCount: 0
        };
        return l.forwardHolder.model = y.parseImplicitRelay(e, n, [], s), l.refCount = s.refCount, 
        l.namespace = i, l.priority = u, l.generateAdapters(), l.invalidator.addListener(l.generateAdapters), 
        l.invalidator.addListener(l.runTransform), l;
    }, y.singleTransformToFull = function(e) {
        return {
            "": {
                transform: n.extend(!0, {
                    inputPath: ""
                }, e)
            }
        };
    }, y.model.relayConditions = {
        initOnly: {
            includeSource: "init"
        },
        liveOnly: {
            excludeSource: "init"
        },
        never: {
            includeSource: []
        },
        always: {}
    }, y.model.parseRelayCondition = function(e) {
        var t;
        return "initOnly" === e ? y.log(y.logLevel.WARN, 'The relay condition "initOnly" is deprecated: Please use the form \'includeSource: "init"\' instead') : "liveOnly" === e && y.log(y.logLevel.WARN, 'The relay condition "liveOnly" is deprecated: Please use the form \'excludeSource: "init"\' instead'), 
        e ? "string" == typeof e ? (t = y.model.relayConditions[e]) || y.fail('Unrecognised model relay condition string "' + e + '": the supported values are "never" or a record with members "includeSource" and/or "excludeSource"') : t = e : t = {}, 
        y.parseSourceExclusionSpec({}, t);
    }, y.parseModelRelay = function(e, t, n) {
        var r = void 0 !== t.source ? y.parseValidModelReference(e, 'modelRelay record member "source"', t.source) : {
            path: null,
            modelSegs: null
        }, o = y.parseValidModelReference(e, 'modelRelay record member "target"', t.target), a = t.namespace || n, i = t.singleTransform ? y.singleTransformToFull(t.singleTransform) : t.transform;
        i || y.fail('Cannot parse modelRelay record without element "singleTransform" or "transform":', t);
        var u = y.model.parseRelayCondition(t.forward), l = y.model.parseRelayCondition(t.backward), s = y.makeTransformPackage(e, i, r.path, o.path, u, l, a, t.priority);
        0 === s.refCount ? y.connectModelRelay(r.that || e, r.modelSegs, o.that, o.modelSegs, y.filterKeys(s, [ "forwardAdapter", "backwardAdapter", "namespace", "priority" ])) : (r.modelSegs && y.fail('Error in model relay definition: If a relay transform has a model dependency, you can not specify a "source" entry - please instead enter this as "input" in the transform specification. Definition was ', t, " for component ", e), 
        y.connectModelRelay(e, null, o.that, o.modelSegs, s));
    }, y.parseImplicitRelay = function(r, e, o, a) {
        var i;
        if (y.isIoCReference(e)) {
            var t = y.parseValidModelReference(r, "model reference from model (implicit relay)", e, !0);
            t.nonModel ? i = y.getForComponent(t.that, t.segs) : (++a.refCount, y.connectModelRelay(r, o, t.that, t.modelSegs, a));
        } else y.isPrimitive(e) || !y.isPlainObject(e) ? i = e : e.expander && y.isPlainObject(e.expander) ? i = y.expandOptions(e, r) : (i = y.freshContainer(e), 
        y.each(e, function(e, t) {
            o.push(t);
            var n = y.parseImplicitRelay(r, e, o, a);
            void 0 !== n && (i[t] = n), o.pop();
        }));
        return i;
    }, y.model.notifyExternal = function(e) {
        var t = e ? y.values(e.externalChanges) : [];
        y.sortByPriority(t);
        for (var n = 0; n < t.length; ++n) {
            var r = t[n];
            r.args[5].destroyed || r.listener.apply(null, r.args);
        }
        y.clearLinkCounts(e, !0);
    }, y.model.commitRelays = function(e, t) {
        var n = e.modelTransactions[t];
        y.each(n, function(e) {
            e.transaction && (e.transaction.commit("relay"), e.transaction.reset());
        });
    }, y.model.updateRelays = function(e, t) {
        var n = e.modelTransactions[t], r = 0;
        return y.sortByPriority(n.relays), y.each(n.relays, function(e) {
            0 < e.transaction.changeRecord.changes && e.relayCount < 2 && e.options.update && (e.relayCount++, 
            y.clearLinkCounts(n), e.options.update(e.transaction, n), ++r);
        }), r;
    }, y.establishModelRelay = function(r, e, t, n, o) {
        var a = y.shadowForComponent(r);
        a.modelRelayEstablished ? y.fail("FLUID-5887 failure: Model relay initialised twice on component", r) : a.modelRelayEstablished = !0, 
        y.mergeModelListeners(r, t);
        var i = y.enlistModelComponent(r);
        y.each(n, function(e, t) {
            for (var n = 0; n < e.length; ++n) y.parseModelRelay(r, e[n], t);
        });
        var u = y.transform(e, function(e) {
            return y.parseImplicitRelay(r, e, [], {
                refCount: 0,
                priority: "first"
            });
        });
        i.initModels = u;
        var l = y.getInstantiator(r);
        return o.preCommit.addListener(function(e) {
            for (;0 < y.model.updateRelays(l, e.id); ) ;
        }), o.preCommit.addListener(function(e, t, n) {
            "relay" !== n && y.model.commitRelays(l, e.id);
        }), o.postCommit.addListener(function(e, t, n) {
            "relay" !== n && (y.model.notifyExternal(l.modelTransactions[e.id]), delete l.modelTransactions[e.id]);
        }), null;
    }, y.defaults("fluid.modelComponent", {
        gradeNames: [ "fluid.component" ],
        changeApplierOptions: {
            relayStyle: !0,
            cullUnchanged: !0
        },
        members: {
            model: "@expand:fluid.initRelayModel({that}, {that}.modelRelay)",
            applier: "@expand:fluid.makeHolderChangeApplier({that}, {that}.options.changeApplierOptions)",
            modelRelay: "@expand:fluid.establishModelRelay({that}, {that}.options.model, {that}.options.modelListeners, {that}.options.modelRelay, {that}.applier)"
        },
        mergePolicy: {
            model: {
                noexpand: !0,
                func: y.arrayConcatPolicy
            },
            modelListeners: y.makeMergeListenersPolicy(y.arrayConcatPolicy),
            modelRelay: y.makeMergeListenersPolicy(y.arrayConcatPolicy, !0)
        }
    }), y.modelChangedToChange = function(e) {
        return {
            value: e[0],
            oldValue: e[1],
            path: e[2],
            transaction: e[4]
        };
    }, y.event.invokeListener = function(e, t, n, r) {
        return "string" == typeof e && (e = y.event.resolveListener(e)), e.apply(null, t, n, r);
    }, y.resolveModelListener = function(o, a) {
        var e = function() {
            if (!y.isDestroyed(o)) {
                var e = y.modelChangedToChange(arguments), t = arguments, n = {
                    change: e,
                    arguments: t
                }, r = {
                    source: Object.keys(e.transaction.sources)
                };
                a.args && (t = y.expandOptions(a.args, o, {}, n)), y.event.invokeListener(a.listener, y.makeArray(t), n, r);
            }
        };
        return y.event.impersonateListener(a.listener, e), e;
    }, y.registerModelListeners = function(r, o, e, a) {
        var i = y.resolveModelListener(r, o);
        y.each(o.byTarget, function(e) {
            var t = e[0], n = {
                listener: i,
                listenerId: y.allocateGuid(),
                segsArray: y.getMembers(e, "modelSegs"),
                pathArray: y.getMembers(e, "path"),
                includeSource: o.includeSource,
                excludeSource: o.excludeSource,
                priority: y.expandOptions(o.priority, r),
                transactional: !0
            };
            (n = t.applier.modelChanged.addListener(n, i, a, o.softNamespace), y.recordChangeListener(r, t.applier, i, n.listenerId), 
            r === t.that || y.isModelComplete(r)) || y.getForComponent(r, [ "events", "onCreate" ]).addListener(function() {
                if (y.isModelComplete(t.that)) {
                    var e = t.applier.initiate(null, "init");
                    y.initModelEvent(r, t.applier, e, [ n ]), e.commit();
                }
            });
        });
    }, y.mergeModelListeners = function(o, e) {
        y.each(e, function(e, r) {
            "string" == typeof e && (e = {
                funcName: e
            });
            var t = y.event.resolveListenerRecord(e, o, "modelListeners", null, !1).records;
            y.each(t, function(n) {
                n.byTarget = {};
                var e = y.makeArray(void 0 === n.path ? r : n.path);
                y.each(e, function(e) {
                    var t = y.parseValidModelReference(o, "modelListeners entry", e);
                    y.pushArray(n.byTarget, t.that.id, t);
                });
                var t = (n.namespace && !n.softNamespace ? n.namespace : null) || (void 0 !== n.path ? r : null);
                y.registerModelListeners(o, n, e, t);
            });
        });
    }, y.fireChanges = function(e, t) {
        for (var n = 0; n < t.length; ++n) e.fireChangeRequest(t[n]);
    }, y.model.isChangedPath = function(e, t) {
        for (var n = 0; n <= t.length; ++n) {
            if ("string" == typeof e) return !0;
            n < t.length && e && (e = e[t[n]]);
        }
        return !1;
    }, y.model.setChangedPath = function(t, n, r) {
        var e = function(e) {
            n.unshift(e), y.model.setSimple(t, n, r), n.shift();
        };
        y.model.isChangedPath(t.changeMap, n) || (++t.changes, e("changeMap")), y.model.isChangedPath(t.deltaMap, n) || (++t.deltas, 
        e("deltaMap"));
    }, y.model.fetchChangeChildren = function(n, r, o, e, a) {
        y.each(e, function(e, t) {
            o[r] = t, y.model.applyChangeStrategy(n, t, r, o, e, a), o.length = r;
        });
    }, y.model.isSameValue = function(e, t) {
        return "number" != typeof e || "number" != typeof t ? e === t : e === t || e != e && t != t || Math.abs((e - t) / t) < 1e-12;
    }, y.model.applyChangeStrategy = function(e, t, n, r, o, a) {
        var i = e[t], u = y.typeCode(o), l = y.typeCode(i), s = y.NO_VALUE;
        "primitive" === u ? y.model.isSameValue(i, o) || (s = o, ++a.unchanged) : (l !== u || "array" === u && o.length !== i.length) && (s = y.freshContainer(o)), 
        s !== y.NO_VALUE && (e[t] = s, a.changeMap && y.model.setChangedPath(a, r, a.inverse ? "DELETE" : "ADD")), 
        "primitive" !== u && y.model.fetchChangeChildren(e[t], n + 1, r, o, a);
    }, y.model.stepTargetAccess = function(e, t, n, r, o, a) {
        for (var i = r; i < o; ++i) {
            if (e) e[n[i]] !== (e = y.model.traverseWithStrategy(e, n, i, a["ADD" === t ? "resolverSetConfig" : "resolverGetConfig"], n.length - i - 1)) && a.changeMap && y.model.setChangedPath(a, n.slice(0, i + 1), "ADD");
        }
        return {
            root: e,
            last: n[o]
        };
    }, y.model.defaultAccessorConfig = function(e) {
        return (e = e || {}).resolverSetConfig = e.resolverSetConfig || y.model.escapedSetConfig, 
        e.resolverGetConfig = e.resolverGetConfig || y.model.escapedGetConfig, e;
    }, y.model.applyHolderChangeRequest = function(e, t, n) {
        (n = y.model.defaultAccessorConfig(n)).deltaMap = n.changeMap ? {} : null, n.deltas = 0;
        var r, o = t.segs.length, a = 0 === o;
        if (a ? r = {
            root: e,
            last: "model"
        } : (e.model || (e.model = {}, y.model.setChangedPath(n, [], n.inverse ? "DELETE" : "ADD")), 
        r = y.model.stepTargetAccess(e.model, t.type, t.segs, 0, o - 1, n)), "ADD" === t.type) {
            var i = t.value, u = y.makeArray(t.segs);
            y.model.applyChangeStrategy(r.root, r.last, o - 1, u, i, n, a);
        } else "DELETE" === t.type ? r.root && void 0 !== r.root[r.last] && (delete r.root[r.last], 
        n.changeMap && y.model.setChangedPath(n, t.segs, "DELETE")) : y.fail("Unrecognised change type of " + t.type);
        return n.deltas ? n.deltaMap : null;
    }, y.model.diff = function(e, t, n) {
        n = n || {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        var r, o = y.typeCode(e), a = y.typeCode(t);
        if ("primitive" === o && "primitive" === a) r = y.model.isSameValue(e, t); else if ("primitive" === o ^ "primitive" === a) r = !1; else {
            var i = {
                model: y.copy(e)
            };
            y.model.applyHolderChangeRequest(i, {
                value: t,
                segs: [],
                type: "ADD"
            }, n);
            var u = {
                model: y.copy(t)
            };
            n.inverse = !0, y.model.applyHolderChangeRequest(u, {
                value: e,
                segs: [],
                type: "ADD"
            }, n), r = 0 === n.changes;
        }
        return !1 === r && 0 === n.changes ? (n.changes = 1, n.changeMap = void 0 === t ? "DELETE" : "ADD") : !0 === r && 0 === n.unchanged && (n.unchanged = 1), 
        r;
    }, y.outputMatches = function(n, r, e) {
        y.each(e, function(e, t) {
            n.push(r.concat(t));
        });
    }, y.matchChanges = function(e, t, n, r) {
        for (var o = n.model, a = r.model, i = e, u = [ "model" ], l = !1, s = [], c = 0; c < t.length; ++c) {
            var f = t[c];
            "*" === f ? c === t.length - 1 ? l = !0 : y.fail("Wildcard specification in modelChanged listener is only supported for the final path segment: " + t.join(".")) : (u.push(f), 
            i = y.isPrimitive(i) ? i : i[f], o = o ? o[f] : void 0, a = a ? a[f] : void 0);
        }
        return i && (l ? "DELETE" === i ? y.outputMatches(s, u, a) : "ADD" === i ? y.outputMatches(s, u, o) : y.outputMatches(s, u, i) : s.push(u)), 
        s;
    }, y.storeExternalChange = function(e, t, n, r, o) {
        var a = t.composeSegments.apply(null, n), i = [ t.holder.id, r.listenerId, r.wildcard ? a : "" ].join("|");
        e.externalChanges[i] = {
            listener: r.listener,
            namespace: r.namespace,
            priority: r.priority,
            args: o
        };
    }, y.notifyModelChanges = function(e, t, n, r, o, a, i, u) {
        if (e) for (var l = a && y.getModelTransactionRec(u, a.id), s = 0; s < e.length; ++s) for (var c = e[s], f = 1 < c.segsArray.length, d = 0; d < c.segsArray.length; ++d) for (var p = y.matchChanges(t, c.segsArray[d], n, r), m = 0; m < p.length; ++m) {
            if (i.destroyed) return;
            var g = p[m];
            c.listener = y.event.resolveListener(c.listener);
            var h = [ f ? n.model : y.model.getSimple(n, g), f ? r.model : y.model.getSimple(r, g), f ? [] : g.slice(1), o, a, i ];
            if (!c.isRelay) {
                if (y.model.diff(h[0], h[1])) continue;
                if (y.isExcludedChangeSource(a, c)) continue;
            }
            l && !c.isRelay && c.transactional ? y.storeExternalChange(l, i, g, c, h) : c.listener.apply(null, h);
        }
    }, y.bindELMethods = function(t) {
        t.parseEL = function(e) {
            return y.model.pathToSegments(e, t.options.resolverSetConfig);
        }, t.composeSegments = function() {
            return t.options.resolverSetConfig.parser.compose.apply(null, arguments);
        };
    }, y.initModelEvent = function(e, t, n, r) {
        y.notifyModelChanges(r, "ADD", n.oldHolder, y.emptyHolder, null, n, t, e);
    }, y.emptyHolder = y.freezeRecursive({
        model: void 0
    }), y.preFireChangeRequest = function(e, t) {
        t.type || (t.type = "ADD"), t.segs = t.segs || e.parseEL(t.path);
    }, y.bindRequestChange = function(a) {
        a.change = function(e, t, n, r) {
            var o = {
                path: e,
                value: t,
                type: n,
                source: r
            };
            a.fireChangeRequest(o);
        };
    }, y.isObjectSimple = function(e) {
        return "[object Object]" === Object.prototype.toString.call(e);
    }, y.mergeChangeSources = function(t, e) {
        y.isObjectSimple(e) ? y.extend(t, e) : y.each(y.makeArray(e), function(e) {
            t[e] = !0;
        });
    }, y.ChangeApplier = function() {}, y.makeHolderChangeApplier = function(i, u) {
        u = y.model.defaultAccessorConfig(u);
        var e = y.allocateGuid(), l = new y.ChangeApplier(), t = y.isComponent(i) ? "ChangeApplier for component " + y.dumpThat(i) : "ChangeApplier with id " + e;
        return n.extend(l, {
            applierId: e,
            holder: i,
            listeners: y.makeEventFirer({
                name: "Internal change listeners for " + t
            }),
            transListeners: y.makeEventFirer({
                name: "External change listeners for " + t
            }),
            options: u,
            modelChanged: {},
            preCommit: y.makeEventFirer({
                name: "preCommit event for " + t
            }),
            postCommit: y.makeEventFirer({
                name: "postCommit event for " + t
            })
        }), l.destroy = function() {
            l.preCommit.destroy(), l.postCommit.destroy(), l.destroyed = !0;
        }, l.modelChanged.addListener = function(e, t, n, r) {
            return (e = "string" == typeof e ? {
                path: e
            } : y.copy(e)).listenerId = e.listenerId || y.allocateGuid(), e.namespace = n, e.softNamespace = r, 
            "string" == typeof t && (t = {
                globalName: t
            }), e.listener = t, !1 !== e.transactional && (e.transactional = !0), e.segsArray || (void 0 !== e.path && (e.segs = e.segs || l.parseEL(e.path)), 
            e.segsArray || (e.segsArray = [ e.segs ])), e.isRelay || (y.parseSourceExclusionSpec(e, e), 
            e.wildcard = y.accumulate(y.transform(e.segsArray, function(e) {
                return y.contains(e, "*");
            }), y.add, 0), e.wildcard && 1 < e.segsArray.length && y.fail("Error in model listener specification ", e, " - you may not supply a wildcard pattern as one of a set of multiple paths to be matched")), 
            l[e.transactional ? "transListeners" : "listeners"].addListener(e), e;
        }, l.modelChanged.removeListener = function(e) {
            l.listeners.removeListener(e), l.transListeners.removeListener(e);
        }, l.fireChangeRequest = function(e) {
            var t = l.initiate("local", e.source);
            t.fireChangeRequest(e), t.commit();
        }, l.initiate = function(e, t, n) {
            var r = "relay" === (e = "init" === t ? null : e || "local"), o = {
                instanceId: y.allocateGuid(),
                id: n || y.allocateGuid(),
                changeRecord: {
                    resolverSetConfig: u.resolverSetConfig,
                    resolverGetConfig: u.resolverGetConfig
                },
                reset: function() {
                    o.oldHolder = i, o.newHolder = {
                        model: y.copy(i.model)
                    }, o.changeRecord.changes = 0, o.changeRecord.unchanged = 0, o.changeRecord.changeMap = {};
                },
                commit: function(e) {
                    if (l.preCommit.fire(o, l, e), 0 < o.changeRecord.changes) {
                        var t = {
                            model: i.model
                        };
                        i.model = o.newHolder.model, y.notifyModelChanges(l.transListeners.sortedListeners, o.changeRecord.changeMap, i, t, null, o, l, i);
                    }
                    r || l.postCommit.fire(o, l, e);
                },
                fireChangeRequest: function(e) {
                    y.preFireChangeRequest(l, e), e.transactionId = o.id;
                    var t = y.model.applyHolderChangeRequest(o.newHolder, e, o.changeRecord);
                    y.notifyModelChanges(l.listeners.sortedListeners, t, o.newHolder, i, e, o, l, i);
                },
                hasChangeSource: function(e) {
                    return o.fullSources[e];
                }
            }, a = y.getModelTransactionRec(i, o.id);
            return a && (y.mergeChangeSources(a.sources, t), o.sources = a.sources, o.fullSources = Object.create(a.sources), 
            o.fullSources[e] = !0), o.reset(), y.bindRequestChange(o), o;
        }, y.bindRequestChange(l), y.bindELMethods(l), l;
    }, y.modelPairToChanges = function(e, t, n) {
        n = n || "";
        var r = {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        y.model.diff(t, e, r);
        var o = [];
        return y.modelPairToChangesImpl(e, y.pathUtil.parseEL(n), r.changeMap, [], o), o;
    }, y.modelPairToChangesImpl = function(r, o, e, a, i) {
        "ADD" === e ? i.push({
            path: o,
            value: r,
            type: "ADD"
        }) : "DELETE" === e ? i.push({
            path: o,
            value: null,
            type: "DELETE"
        }) : y.isPlainObject(e, !0) && y.each(e, function(e, t) {
            var n = a.concat([ t ]);
            "ADD" === e ? i.push({
                path: o.concat(n),
                value: y.get(r, n),
                type: "ADD"
            }) : "DELETE" === e ? i.push({
                path: o.concat(n),
                value: null,
                type: "DELETE"
            }) : y.isPlainObject(e, !0) && y.modelPairToChangesImpl(r, o, e, n, i);
        });
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(l, c) {
    "use strict";
    c.registerNamespace("fluid.model.transform"), c.defaults("fluid.transformFunction", {
        gradeNames: "fluid.function"
    }), c.defaults("fluid.standardInputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    }), c.defaults("fluid.standardOutputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    }), c.defaults("fluid.multiInputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    }), c.defaults("fluid.standardTransformFunction", {
        gradeNames: [ "fluid.standardInputTransformFunction", "fluid.standardOutputTransformFunction" ]
    }), c.defaults("fluid.lens", {
        gradeNames: "fluid.transformFunction",
        invertConfiguration: null
    }), c.model.transform.pathToRule = function(e) {
        return {
            transform: {
                type: "fluid.transforms.value",
                inputPath: e
            }
        };
    }, c.model.transform.literalValueToRule = function(e) {
        return {
            transform: {
                type: "fluid.transforms.literalValue",
                input: e
            }
        };
    }, c.model.composePaths = function(e, t) {
        return t = 0 === t ? "0" : t || "", (e = 0 === e ? "0" : e || "") ? t ? e + "." + t : e : t;
    }, c.model.transform.accumulateInputPath = function(e, t, n) {
        void 0 !== e && n.push(c.model.composePaths(t.inputPrefix, e));
    }, c.model.transform.accumulateStandardInputPath = function(e, t, n, r) {
        c.model.transform.getValue(void 0, t[e], n), c.model.transform.accumulateInputPath(t[e + "Path"], n, r);
    }, c.model.transform.accumulateMultiInputPaths = function(e, n, r, o) {
        c.each(e, function(e, t) {
            c.model.transform.accumulateStandardInputPath(t, n, r, o);
        });
    }, c.model.transform.getValue = function(e, t, n) {
        var r;
        return void 0 !== e && (r = c.get(n.source, c.model.composePaths(n.inputPrefix, e), n.resolverGetConfig)), 
        void 0 === r && (r = c.isPrimitive(t) ? t : "literalValue" in t ? t.literalValue : void 0 === t.transform ? t : n.expand(t)), 
        r;
    }, c.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN = {}, c.model.transform.setValue = function(e, t, n) {
        var r = c.copy(t), o = c.model.composePaths(n.outputPrefix, e);
        return void 0 !== r && n.applier.change(o, r), e ? c.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN : r;
    }, c.model.transform.resolveParam = function(e, t, n, r) {
        var o = c.model.transform.getValue(e[n + "Path"], e[n], t);
        return void 0 !== o ? o : r;
    }, c.model.transform.matchValue = function(e, t, n) {
        var r = {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        return c.model.diff(e, t, r), 0 === r.unchanged ? 0 : n ? 0xffffff000000 - 16777216 * r.changes + r.unchanged : r.changes ? 0 : 0xffffff000000 + r.unchanged;
    }, c.model.transform.invertPaths = function(e, t) {
        var n = c.model.composePaths(t.outputPrefix, e.outputPath);
        return e.outputPath = c.model.composePaths(t.inputPrefix, e.inputPath), e.inputPath = n, 
        e;
    }, c.model.transform.prefixApplier = function(e, t) {
        e.inputPrefix && t.inputPrefixOp.push(e.inputPrefix), e.outputPrefix && t.outputPrefixOp.push(e.outputPrefix), 
        t.expand(e.input), e.inputPrefix && t.inputPrefixOp.pop(), e.outputPrefix && t.outputPrefixOp.pop();
    }, c.defaults("fluid.model.transform.prefixApplier", {
        gradeNames: [ "fluid.transformFunction" ]
    }), c.model.makePathStack = function(n, r) {
        var o = n[r + "Stack"] = [];
        return n[r] = "", {
            push: function(e) {
                var t = c.model.composePaths(n[r], e);
                o.push(n[r]), n[r] = t;
            },
            pop: function() {
                n[r] = o.pop();
            }
        };
    }, c.model.transform.doTransform = function(r, o, e) {
        var t = e.defaults, n = c.getGlobalValue(e.typeName);
        "function" != typeof n && c.fail("Transformation record specifies transformation function with name " + r.type + " which is not a function - ", n), 
        c.hasGrade(t, "fluid.transformFunction") || (t = c.defaults("fluid.standardTransformFunction"));
        var a = [ r, o ];
        if (c.hasGrade(t, "fluid.multiInputTransformFunction")) {
            var i = {};
            c.each(t.inputVariables, function(t, n) {
                i[n] = function() {
                    var e = c.model.transform.getValue(r[n + "Path"], r[n], o);
                    return e = void 0 === e && null !== t ? t : e;
                };
            }), a.unshift(i);
        }
        if (c.hasGrade(t, "fluid.standardInputTransformFunction")) {
            "input" in r || "inputPath" in r || c.fail('Error in transform specification. Either "input" or "inputPath" must be specified for a standardInputTransformFunction: received ', r);
            var u = c.model.transform.getValue(r.inputPath, r.input, o);
            if (a.unshift(u), void 0 === u) return;
        }
        var l = n.apply(null, a);
        c.hasGrade(t, "fluid.standardOutputTransformFunction") && (void 0 !== (void 0 !== r.outputPath ? r.outputPath : e.doOutput ? "" : void 0) && void 0 !== l && (c.model.transform.setValue(r.outputPath, l, o), 
        l = void 0));
        return l;
    };
    var n = [];
    c.registerNamespace("fluid.pathUtil"), c.pathUtil.getPathSegment = function(e, t) {
        return c.pathUtil.getPathSegmentImpl(n, e, t), n[0];
    }, c.pathUtil.getHeadPath = function(e) {
        return c.pathUtil.getPathSegment(e, 0);
    }, c.pathUtil.getFromHeadPath = function(e) {
        var t = c.pathUtil.getPathSegmentImpl(null, e, 0);
        return t === e.length ? "" : e.substring(t + 1);
    }, c.pathUtil.matchPath = function(e, t, n) {
        for (var r = []; ;) {
            if ("" === t ^ "" === e && n) return null;
            if (!e || !t) break;
            var o = c.pathUtil.getHeadPath(e), a = c.pathUtil.getHeadPath(t);
            if ("*" !== o && o !== a) return null;
            r.push(a), e = c.pathUtil.getFromHeadPath(e), t = c.pathUtil.getFromHeadPath(t);
        }
        return r;
    }, c.model.transform.expandWildcards = function(u, e) {
        c.each(e, function(e, t) {
            var n = u.queuedTransforms;
            u.pathOp.push(c.pathUtil.escapeSegment(t.toString()));
            for (var r = 0; r < n.length; ++r) if (c.pathUtil.matchPath(n[r].matchPath, u.path, !0)) {
                var o = c.copy(n[r].transformSpec);
                (void 0 === o.inputPath || c.model.transform.hasWildcard(o.inputPath)) && (o.inputPath = ""), 
                u.inputPrefixOp.push(u.path), u.outputPrefixOp.push(u.path);
                var a = c.model.transform.lookupType(o.type), i = c.model.transform.doTransform(o, u, a);
                void 0 !== i && c.model.transform.setValue(null, i, u), u.outputPrefixOp.pop(), 
                u.inputPrefixOp.pop();
            }
            c.isPrimitive(e) || c.model.transform.expandWildcards(u, e), u.pathOp.pop();
        });
    }, c.model.transform.hasWildcard = function(e) {
        return "string" == typeof e && -1 !== e.indexOf("*");
    }, c.model.transform.maybePushWildcard = function(e, t) {
        var n, r = c.model.transform.hasWildcard;
        return r(e.inputPath) ? n = c.model.composePaths(t.inputPrefix, e.inputPath) : (r(t.outputPrefix) || r(e.outputPath)) && (n = c.model.composePaths(t.outputPrefix, e.outputPath)), 
        !!n && (t.queuedTransforms.push({
            transformSpec: e,
            outputPrefix: t.outputPrefix,
            inputPrefix: t.inputPrefix,
            matchPath: n
        }), !0);
    }, c.model.sortByKeyLength = function(e) {
        return c.keys(e).sort(c.compareStringLength(!0));
    }, c.model.transform.handleTransformStrategy = function(e, t, n) {
        return c.model.transform.maybePushWildcard(e, t) ? void 0 : c.model.transform.doTransform(e, t, n);
    }, c.model.transform.handleInvertStrategy = function(e, t, n) {
        e = c.copy(e), c.hasGrade(n.defaults, "fluid.standardTransformFunction") && (e = c.model.transform.invertPaths(e, t));
        var r = n.defaults && n.defaults.invertConfiguration;
        if (r) {
            var o = c.invokeGlobalFunction(r, [ e, t ]);
            t.inverted.push(o);
        } else t.inverted.push(c.model.transform.uninvertibleTransform);
    }, c.model.transform.handleCollectStrategy = function(e, t, n) {
        var r = n.defaults, o = c.hasGrade(r, "fluid.standardInputTransformFunction"), a = c.hasGrade(r, "fluid.multiInputTransformFunction");
        o && c.model.transform.accumulateStandardInputPath("input", e, t, t.inputPaths), 
        a && c.model.transform.accumulateMultiInputPaths(r.inputVariables, e, t, t.inputPaths);
        var i = r.collectInputPaths;
        if (i) {
            var u = c.makeArray(c.invokeGlobalFunction(i, [ e, t ]));
            Array.prototype.push.apply(t.inputPaths, u);
        }
    }, c.model.transform.lookupType = function(e, t) {
        return e || c.fail("Transformation record is missing a type name: ", t), -1 === e.indexOf(".") && (e = "fluid.transforms." + e), 
        {
            defaults: c.defaults(e),
            typeName: e
        };
    }, c.model.transform.processRule = function(e, r) {
        var t, n, o;
        if ("string" == typeof e ? e = c.model.transform.pathToRule(e) : void 0 !== e.literalValue && (e = c.model.transform.literalValueToRule(e.literalValue)), 
        e.transform) if (c.isArrayable(e.transform)) {
            var a = e.transform;
            t = void 0;
            for (var i = 0; i < a.length; ++i) n = a[i], o = c.model.transform.lookupType(n.type), 
            r.transformHandler(n, r, o);
        } else n = e.transform, o = c.model.transform.lookupType(n.type), t = r.transformHandler(n, r, o);
        return c.isArrayable(e) && (r.collectedFlatSchemaOpts = r.collectedFlatSchemaOpts || {}, 
        r.collectedFlatSchemaOpts[r.outputPrefix] = "array"), c.each(e, function(e, t) {
            if ("transform" !== t) {
                r.outputPrefixOp.push(t);
                var n = r.expand(e, r);
                void 0 !== n && (c.model.transform.setValue(null, n, r), n = void 0), r.outputPrefixOp.pop();
            }
        }), t;
    }, c.model.transform.makeStrategy = function(t, e, n) {
        n = n || c.model.transform.processRule, t.expand = function(e) {
            return n(e, t);
        }, t.outputPrefixOp = c.model.makePathStack(t, "outputPrefix"), t.inputPrefixOp = c.model.makePathStack(t, "inputPrefix"), 
        t.transformHandler = e;
    }, c.model.transform.uninvertibleTransform = Object.freeze({}), c.model.transform.invertConfiguration = function(e) {
        var t = {
            inverted: []
        };
        return c.model.transform.makeStrategy(t, c.model.transform.handleInvertStrategy), 
        t.expand(e), -1 === t.inverted.indexOf(c.model.transform.uninvertibleTransform) ? {
            transform: t.inverted
        } : c.model.transform.uninvertibleTransform;
    }, c.model.transform.collectInputPaths = function(e) {
        var t = {
            inputPaths: []
        };
        c.model.transform.makeStrategy(t, c.model.transform.handleCollectStrategy), t.expand(e);
        var n = c.arrayToHash(t.inputPaths);
        return Object.keys(n);
    }, c.model.transform.flatSchemaStrategy = function(u, l) {
        var s = c.model.sortByKeyLength(u);
        return function(e, t, n, r) {
            for (var o = l.parser.compose.apply(null, r.slice(0, n)), a = 0; a < s.length; ++a) {
                var i = s[a];
                if (null !== c.pathUtil.matchPath(i, o, !0)) return u[i];
            }
        };
    }, c.model.transform.defaultSchemaValue = function(e) {
        return "array" === (c.isPrimitive(e) ? e : e.type) ? [] : {};
    }, c.model.transform.isomorphicSchemaStrategy = function(a, i) {
        return function(e, t, n, r) {
            var o = c.get(a, r.slice(0, n), i);
            return c.isArrayable(o) ? "array" : "object";
        };
    }, c.model.transform.decodeStrategy = function(e, t, n) {
        return t.isomorphic ? c.model.transform.isomorphicSchemaStrategy(e, n) : t.flatSchema ? c.model.transform.flatSchemaStrategy(t.flatSchema, n) : void 0;
    }, c.model.transform.schemaToCreatorStrategy = function(a) {
        return function(e, t, n, r) {
            if (void 0 === e[t]) {
                var o = a(e, t, n, r);
                return e[t] = c.model.transform.defaultSchemaValue(o), e[t];
            }
        };
    }, c.model.transform.sequence = function(e, t, n) {
        for (var r = 0; r < t.length; ++r) e = c.model.transform(e, t[r], n);
        return e;
    }, c.model.compareByPathLength = function(e, t) {
        var n = e.path.length - t.path.length;
        return 0 === n ? e.sequence - t.sequence : n;
    }, c.model.fireSortedChanges = function(e, t) {
        e.sort(c.model.compareByPathLength), c.fireChanges(t, e);
    }, c.model.transformWithRules = function(e, t, n) {
        n = n || {};
        var r = c.model.escapedGetConfig, o = c.model.escapedSetConfig, a = c.model.transform.decodeStrategy(e, n, r), i = {
            source: e,
            target: {
                model: a ? c.model.transform.defaultSchemaValue(a(null, "", 0, [ "" ])) : {}
            },
            resolverGetConfig: r,
            resolverSetConfig: o,
            collectedFlatSchemaOpts: void 0,
            queuedChanges: [],
            queuedTransforms: []
        };
        c.model.transform.makeStrategy(i, c.model.transform.handleTransformStrategy), i.applier = {
            fireChangeRequest: function(e) {
                e.sequence = i.queuedChanges.length, i.queuedChanges.push(e);
            }
        }, c.bindRequestChange(i.applier), i.expand(t);
        var u = c.copy(o);
        return void 0 !== i.collectedFlatSchemaOpts && (l.extend(i.collectedFlatSchemaOpts, n.flatSchema), 
        a = c.model.transform.flatSchemaStrategy(i.collectedFlatSchemaOpts, r)), u.strategies = [ c.model.defaultFetchStrategy, a ? c.model.transform.schemaToCreatorStrategy(a) : c.model.defaultCreatorStrategy ], 
        i.finalApplier = n.finalApplier || c.makeHolderChangeApplier(i.target, {
            resolverSetConfig: u
        }), 0 < i.queuedTransforms.length && (i.typeStack = [], i.pathOp = c.model.makePathStack(i, "path"), 
        c.model.transform.expandWildcards(i, e)), c.model.fireSortedChanges(i.queuedChanges, i.finalApplier), 
        i.target.model;
    }, l.extend(c.model.transformWithRules, c.model.transform), c.model.transform = c.model.transformWithRules, 
    c.transformOne = function(e) {
        return {
            transformOptions: {
                transformer: "fluid.model.transformWithRules",
                config: e
            }
        };
    }, c.transformMany = function(e) {
        return {
            transformOptions: {
                transformer: "fluid.model.transform.sequence",
                config: e
            }
        };
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(l, s) {
    "use strict";
    s.registerNamespace("fluid.model.transform"), s.registerNamespace("fluid.transforms"), 
    s.defaults("fluid.transforms.value", {
        gradeNames: "fluid.standardTransformFunction",
        invertConfiguration: "fluid.identity"
    }), s.transforms.value = s.identity, s.transforms.identity = s.transforms.value, 
    s.defaults("fluid.transforms.identity", {
        gradeNames: "fluid.transforms.value"
    }), s.transforms.invertToIdentity = function(e) {
        return e.type = "fluid.transforms.identity", e;
    }, s.defaults("fluid.transforms.literalValue", {
        gradeNames: "fluid.standardOutputTransformFunction"
    }), s.transforms.literalValue = function(e) {
        return e.input;
    }, s.defaults("fluid.transforms.stringToNumber", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.stringToNumber.invert"
    }), s.transforms.stringToNumber = function(e) {
        var t = Number(e);
        return isNaN(t) ? void 0 : t;
    }, s.transforms.stringToNumber.invert = function(e) {
        return e.type = "fluid.transforms.numberToString", e;
    }, s.defaults("fluid.transforms.numberToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.numberToString.invert"
    }), s.transforms.numberToString = function(e, t) {
        if ("number" == typeof e) return "number" != typeof t.scale || isNaN(t.scale) ? e.toString() : s.roundToDecimal(e, t.scale, t.method).toString();
    }, s.transforms.numberToString.invert = function(e) {
        return e.type = "fluid.transforms.stringToNumber", e;
    }, s.defaults("fluid.transforms.count", {
        gradeNames: "fluid.standardTransformFunction"
    }), s.transforms.count = function(e) {
        return s.makeArray(e).length;
    }, s.defaults("fluid.transforms.round", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.invertToIdentity"
    }), s.transforms.round = function(e, t) {
        return s.roundToDecimal(e, t.scale, t.method);
    }, s.defaults("fluid.transforms.delete", {
        gradeNames: "fluid.transformFunction"
    }), s.transforms.delete = function(e, t) {
        var n = s.model.composePaths(t.outputPrefix, e.outputPath);
        t.applier.change(n, null, "DELETE");
    }, s.defaults("fluid.transforms.firstValue", {
        gradeNames: "fluid.standardOutputTransformFunction"
    }), s.transforms.firstValue = function(e, t) {
        e.values && e.values.length || s.fail('firstValue transformer requires an array of values at path named "values", supplied', e);
        for (var n = 0; n < e.values.length; n++) {
            var r = e.values[n], o = t.expand(r);
            if (void 0 !== o) return o;
        }
    }, s.defaults("fluid.transforms.linearScale", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.linearScale.invert",
        inputVariables: {
            factor: 1,
            offset: 0
        }
    }), s.transforms.linearScale = function(e, t) {
        var n = t.factor(), r = t.offset();
        if ("number" == typeof e && "number" == typeof n && "number" == typeof r) return e * n + r;
    }, s.transforms.linearScale.invert = function(e) {
        return delete e.factorPath, delete e.offsetPath, void 0 !== e.factor && (e.factor = 0 === e.factor ? 0 : 1 / e.factor), 
        void 0 !== e.offset && (e.offset = -e.offset * (void 0 !== e.factor ? e.factor : 1)), 
        e;
    }, s.defaults("fluid.transforms.binaryOp", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
        inputVariables: {
            left: null,
            right: null
        }
    }), s.transforms.binaryLookup = {
        "===": function(e, t) {
            return s.model.isSameValue(e, t);
        },
        "!==": function(e, t) {
            return !s.model.isSameValue(e, t);
        },
        "<=": function(e, t) {
            return e <= t;
        },
        "<": function(e, t) {
            return e < t;
        },
        ">=": function(e, t) {
            return t <= e;
        },
        ">": function(e, t) {
            return t < e;
        },
        "+": function(e, t) {
            return e + t;
        },
        "-": function(e, t) {
            return e - t;
        },
        "*": function(e, t) {
            return e * t;
        },
        "/": function(e, t) {
            return e / t;
        },
        "%": function(e, t) {
            return e % t;
        },
        "&&": function(e, t) {
            return e && t;
        },
        "||": function(e, t) {
            return e || t;
        }
    }, s.transforms.binaryOp = function(e, t, n) {
        var r = e.left(), o = e.right(), a = s.model.transform.getValue(void 0, t.operator, n), i = s.transforms.binaryLookup[a];
        return void 0 === i || void 0 === r || void 0 === o ? void 0 : i(r, o);
    }, s.defaults("fluid.transforms.condition", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
        inputVariables: {
            true: null,
            false: null,
            condition: null
        }
    }), s.transforms.condition = function(e) {
        var t = e.condition();
        if (null !== t) return e[t ? "true" : "false"]();
    }, s.defaults("fluid.transforms.valueMapper", {
        gradeNames: [ "fluid.lens" ],
        invertConfiguration: "fluid.transforms.valueMapper.invert",
        collectInputPaths: "fluid.transforms.valueMapper.collect"
    }), s.model.transform.compareMatches = function(e, t) {
        var n = t.matchValue - e.matchValue;
        return 0 === n ? e.index - t.index : n;
    }, s.transforms.valueMapper = function(e, t) {
        e.match || s.fail('valueMapper requires an array or hash of matches at path named "match", supplied ', e);
        var n = s.model.transform.getValue(e.defaultInputPath, e.defaultInput, t), r = s.isArrayable(e.match) ? s.transforms.valueMapper.longFormMatch(n, e, t) : e.match[n];
        if (void 0 === r && (r = e.noMatch), void 0 !== r) {
            var o, a = void 0 === r.outputPath ? e.defaultOutputPath : r.outputPath;
            return t.outputPrefixOp.push(a), o = s.isPrimitive(r) ? r : r.outputUndefinedValue ? void 0 : void 0 === (o = s.model.transform.resolveParam(r, t, "outputValue", void 0)) ? e.defaultOutputValue : o, 
            "string" == typeof a && void 0 !== o && (s.model.transform.setValue(void 0, o, t, e.merge), 
            o = void 0), t.outputPrefixOp.pop(), o;
        }
    }, s.transforms.valueMapper.longFormMatch = function(e, t, n) {
        var r = t.match;
        0 === r.length && s.fail("valueMapper supplied empty list of matches: ", t);
        for (var o = [], a = 0; a < r.length; ++a) {
            var i = r[a], u = i.inputPath ? s.model.transform.getValue(i.inputPath, void 0, n) : e, l = s.model.transform.matchValue(i.inputValue, u, i.partialMatches);
            o[a] = {
                index: a,
                matchValue: l
            };
        }
        return o.sort(s.model.transform.compareMatches), o[0].matchValue <= 0 ? void 0 : r[o[0].index];
    }, s.transforms.valueMapper.invert = function(o, a) {
        var i = [], e = {
            type: "fluid.transforms.valueMapper",
            match: i
        }, u = s.isArrayable(o.match);
        e.defaultInputPath = s.model.composePaths(a.outputPrefix, o.defaultOutputPath), 
        e.defaultOutputPath = s.model.composePaths(a.inputPrefix, o.defaultInputPath);
        var l = s.firstDefined;
        return s.each(o.match, function(e, t) {
            if (!0 !== e.outputUndefinedValue) {
                var n = {}, r = l(u ? e.inputValue : t, o.defaultInputValue);
                void 0 === r && s.fail("Failure inverting configuration for valueMapper - inputValue could not be resolved for record " + t + ": ", o), 
                n.outputValue = r, n.inputValue = !u && s.isPrimitive(e) ? e : l(e.outputValue, o.defaultOutputValue), 
                e.outputPath && (n.inputPath = s.model.composePaths(a.outputPrefix, l(e.outputPath, o.outputPath))), 
                e.inputPath && (n.outputPath = s.model.composePaths(a.inputPrefix, l(e.inputPath, o.inputPath))), 
                i.push(n);
            }
        }), e;
    }, s.transforms.valueMapper.collect = function(e, t) {
        var n = [];
        return s.model.transform.accumulateStandardInputPath("defaultInput", e, t, n), s.each(e.match, function(e) {
            s.model.transform.accumulateInputPath(e.inputPath, t, n);
        }), n;
    }, s.defaults("fluid.transforms.arrayToSetMembership", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.arrayToSetMembership.invert"
    }), s.transforms.arrayToSetMembership = function(r, o, a) {
        var i = {}, e = o.options;
        return r && s.isArrayable(r) || s.fail("arrayToSetMembership didn't find array at inputPath nor passed as value.", o), 
        e || s.fail("arrayToSetMembership requires an options block set"), void 0 === o.presentValue && (o.presentValue = !0), 
        void 0 === o.missingValue && (o.missingValue = !1), s.each(e, function(e, t) {
            var n = -1 !== r.indexOf(t) ? o.presentValue : o.missingValue;
            s.set(i, e, n, a.resolverSetConfig);
        }), i;
    }, s.transforms.arrayToSetMembership.invertWithType = function(e, t, n) {
        e.type = n;
        var r = {};
        return s.each(e.options, function(e, t) {
            r[e] = t;
        }), e.options = r, e;
    }, s.transforms.arrayToSetMembership.invert = function(e, t) {
        return s.transforms.arrayToSetMembership.invertWithType(e, t, "fluid.transforms.setMembershipToArray");
    }, s.defaults("fluid.transforms.setMembershipToArray", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.setMembershipToArray.invert"
    }), s.transforms.setMembershipToArray = function(n, r, o) {
        var e = r.options;
        e || s.fail("setMembershipToArray requires an options block specified"), void 0 === r.presentValue && (r.presentValue = !0), 
        void 0 === r.missingValue && (r.missingValue = !1);
        var a = [];
        return s.each(e, function(e, t) {
            s.get(n, t, o.resolverGetConfig) === r.presentValue && a.push(e);
        }), a;
    }, s.transforms.setMembershipToArray.invert = function(e, t) {
        return s.transforms.arrayToSetMembership.invertWithType(e, t, "fluid.transforms.arrayToSetMembership");
    }, s.model.transform.applyPaths = function(e, t, n) {
        for (var r = 0; r < n.length; ++r) "push" === e ? t.push(n[r]) : t.pop();
    }, s.model.transform.expandInnerValues = function(e, t, n, r) {
        var o = n.inputPrefixOp, a = n.outputPrefixOp, i = s.model.transform.applyPaths;
        i("push", o, e), i("push", a, t);
        var u = {};
        return s.each(r, function(e) {
            var t = n.expand(e);
            s.isPrimitive(t) ? u = t : l.extend(!0, u, t);
        }), i("pop", a, t), i("pop", o, e), u;
    }, s.defaults("fluid.transforms.indexArrayByKey", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.indexArrayByKey.invert"
    }), s.transforms.indexArrayByKey = function(e, a, i) {
        void 0 === a.key && s.fail("indexArrayByKey requires a 'key' option.", a), s.isArrayable(e) || s.fail("indexArrayByKey didn't find array at inputPath.", a);
        var u = {}, l = a.key;
        return s.each(e, function(e, t) {
            var n = e[l], r = typeof n;
            "string" !== r && "boolean" !== r && "number" !== r && s.fail("indexArrayByKey encountered untransformable array due to missing or invalid key", e);
            var o = s.copy(e);
            delete o[l], a.innerValue && (o = s.model.transform.expandInnerValues([ i.inputPrefix, a.inputPath, t.toString() ], [ a.outputPath, n ], i, a.innerValue)), 
            u[n] = o;
        }), u;
    }, s.transforms.indexArrayByKey.invert = function(e) {
        if (e.type = "fluid.transforms.deindexIntoArrayByKey", e.innerValue) for (var t = e.innerValue, n = 0; n < t.length; ++n) {
            var r = s.model.transform.invertConfiguration(t[n]);
            if (r === s.model.transform.uninvertibleTransform) return r;
            t[n] = r;
        }
        return e;
    }, s.defaults("fluid.transforms.deindexIntoArrayByKey", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.deindexIntoArrayByKey.invert"
    }), s.transforms.deindexIntoArrayByKey = function(e, r, o) {
        void 0 === r.key && s.fail('deindexIntoArrayByKey requires a "key" option.', r);
        var a = [], i = r.key;
        return s.each(e, function(e, t) {
            var n = {};
            n[i] = t, r.innerValue && (e = s.model.transform.expandInnerValues([ r.inputPath, t ], [ r.outputPath, a.length.toString() ], o, r.innerValue)), 
            l.extend(!0, n, e), a.push(n);
        }), a;
    }, s.transforms.deindexIntoArrayByKey.invert = function(e) {
        if (e.type = "fluid.transforms.indexArrayByKey", e.innerValue) for (var t = e.innerValue, n = 0; n < t.length; ++n) t[n] = s.model.transform.invertConfiguration(t[n]);
        return e;
    }, s.defaults("fluid.transforms.limitRange", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.invertToIdentity"
    }), s.transforms.limitRange = function(e, t) {
        var n = t.min;
        void 0 !== n && (e < (n += t.excludeMin || 0) && (e = n));
        var r = t.max;
        void 0 !== r && ((r -= t.excludeMax || 0) < e && (e = r));
        return e;
    }, s.defaults("fluid.transforms.indexOf", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.indexOf.invert"
    }), s.transforms.indexOf = function(e, t) {
        "number" == typeof t.notFound && 0 <= t.notFound && s.fail("A positive number is not allowed as 'notFound' value for indexOf");
        var n = s.transforms.parseIndexationOffset(t.offset, "indexOf"), r = s.makeArray(t.array).indexOf(e);
        return -1 === r && t.notFound ? t.notFound : r + n;
    }, s.transforms.indexOf.invert = function(e, t) {
        var n = s.transforms.invertArrayIndexation(e, t);
        return n.type = "fluid.transforms.dereference", n;
    }, s.defaults("fluid.transforms.dereference", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.dereference.invert"
    }), s.transforms.dereference = function(e, t) {
        if ("number" == typeof e) {
            var n = s.transforms.parseIndexationOffset(t.offset, "dereference");
            return s.makeArray(t.array)[e + n];
        }
    }, s.transforms.dereference.invert = function(e, t) {
        var n = s.transforms.invertArrayIndexation(e, t);
        return n.type = "fluid.transforms.indexOf", n;
    }, s.transforms.parseIndexationOffset = function(e, t) {
        var n = 0;
        return void 0 !== e && (n = s.parseInteger(e), isNaN(n) && s.fail(t + ' requires the value of "offset" to be an integer or a string that can be converted to an integer. ' + e + " is invalid.")), 
        n;
    }, s.transforms.invertArrayIndexation = function(e) {
        return isNaN(Number(e.offset)) || (e.offset = -1 * Number(e.offset)), e;
    }, s.defaults("fluid.transforms.stringTemplate", {
        gradeNames: "fluid.standardOutputTransformFunction"
    }), s.transforms.stringTemplate = function(e) {
        return s.stringTemplate(e.template, e.terms);
    }, s.defaults("fluid.transforms.free", {
        gradeNames: "fluid.transformFunction"
    }), s.transforms.free = function(e) {
        var t = s.makeArray(e.args);
        return s.invokeGlobalFunction(e.func, t);
    }, s.defaults("fluid.transforms.quantize", {
        gradeNames: "fluid.standardTransformFunction",
        collectInputPaths: "fluid.transforms.quantize.collect"
    }), s.transforms.quantize = function(e, t, n) {
        t.ranges && t.ranges.length || s.fail("fluid.transforms.quantize should have a key called ranges containing an array defining ranges to quantize");
        for (var r = 0; r < t.ranges.length; r++) {
            var o = t.ranges[r];
            if (e <= o.upperBound || void 0 === o.upperBound && e >= Number.NEGATIVE_INFINITY) return s.isPrimitive(o.output) ? o.output : n.expand(o.output);
        }
    }, s.transforms.quantize.collect = function(e, t) {
        e.ranges.forEach(function(e) {
            s.isPrimitive(e.output) || t.expand(e.output);
        });
    }, s.defaults("fluid.transforms.inRange", {
        gradeNames: "fluid.standardTransformFunction"
    }), s.transforms.inRange = function(e, t) {
        return (void 0 === t.min || t.min <= e) && (void 0 === t.max || t.max >= e);
    }, s.transforms.stringToBoolean = function(e) {
        return !!e && !("0" === e || "false" === e);
    }, s.transforms.stringToBoolean.invert = function(e) {
        return e.type = "fluid.transforms.booleanToString", e;
    }, s.defaults("fluid.transforms.stringToBoolean", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.stringToBoolean.invert"
    }), s.transforms.booleanToString = function(e) {
        return e ? "true" : "false";
    }, s.transforms.booleanToString.invert = function(e) {
        return e.type = "fluid.transforms.stringToBoolean", e;
    }, s.defaults("fluid.transforms.booleanToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.booleanToString.invert"
    }), s.transforms.JSONstringToObject = function(e) {
        try {
            return JSON.parse(e);
        } catch (e) {
            return;
        }
    }, s.transforms.JSONstringToObject.invert = function(e) {
        return e.type = "fluid.transforms.objectToJSONString", e;
    }, s.defaults("fluid.transforms.JSONstringToObject", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.JSONstringToObject.invert"
    }), s.transforms.objectToJSONString = function(e, t) {
        var n = t.space || 0;
        return JSON.stringify(e, null, n);
    }, s.transforms.objectToJSONString.invert = function(e) {
        return e.type = "fluid.transforms.JSONstringToObject", e;
    }, s.defaults("fluid.transforms.objectToJSONString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.objectToJSONString.invert"
    }), s.transforms.stringToDate = function(e) {
        var t = new Date(e);
        return isNaN(t.getTime()) ? void 0 : t;
    }, s.transforms.stringToDate.invert = function(e) {
        return e.type = "fluid.transforms.dateToString", e;
    }, s.defaults("fluid.transforms.stringToDate", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.stringToDate.invert"
    }), s.transforms.dateToString = function(e) {
        if (e instanceof Date) {
            var t = e.toISOString();
            return t.substring(0, t.indexOf("T"));
        }
    }, s.transforms.dateToString.invert = function(e) {
        return e.type = "fluid.transforms.stringToDate", e;
    }, s.defaults("fluid.transforms.dateToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.dateToString.invert"
    }), s.transforms.dateTimeToString = function(e) {
        return e instanceof Date ? e.toISOString() : void 0;
    }, s.defaults("fluid.transforms.dateTimeToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.dateToString.invert"
    });
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, a) {
    "use strict";
    a.registerNamespace("fluid.contextAware"), a.defaults("fluid.contextAware.marker", {
        gradeNames: [ "fluid.component" ]
    }), a.contextAware.makeCheckMarkers = function(e, n, r) {
        a.each(e, function(e, t) {
            a.constructSingle(n, {
                type: t,
                gradeNames: "fluid.contextAware.marker",
                value: e
            }, r);
        });
    }, a.contextAware.performChecks = function(e) {
        return a.transform(e, function(e) {
            return "function" == typeof e ? e = {
                func: e
            } : "string" == typeof e && (e = {
                funcName: e
            }), a.isPrimitive(e) ? e : "value" in e ? e.value : "func" in e ? e.func() : "funcName" in e ? a.invokeGlobalFunction(e.funcName) : void a.fail("Error in contextAwareness check record ", e, " - must contain an entry with name value, func, or funcName");
        });
    }, a.contextAware.makeChecks = function(e, t, n) {
        var r = a.contextAware.performChecks(e);
        a.contextAware.makeCheckMarkers(r, t, n);
    }, a.contextAware.forgetChecks = function(e, r, o) {
        o = o || a.globalInstantiator, r = r || [];
        var t = a.makeArray(e);
        a.each(t, function(e) {
            var t = a.typeNameToMemberName(e), n = a.model.parseToSegments(r, o.parseEL, !0);
            n.push(t), a.destroy(n, o);
        });
    }, a.defaults("fluid.contextAware", {
        gradeNames: [ "{that}.check" ],
        mergePolicy: {
            contextAwareness: "noexpand"
        },
        contextAwareness: {},
        invokers: {
            check: {
                funcName: "fluid.contextAware.check",
                args: [ "{that}", "{that}.options.contextAwareness" ]
            }
        }
    }), a.contextAware.getCheckValue = function(e, t) {
        var n = a.parseContextReference(t), r = a.resolveContext(n.context, e), o = n.path || [ "options", "value" ];
        return a.getForComponent(r, o);
    }, a.contextAware.checkOne = function(n, e) {
        e.checks && e.checks.contextValue && a.fail("Nesting error in contextAwareness record ", e, ' - the "checks" entry must contain a hash and not a contextValue/gradeNames record at top level');
        var t = a.parsePriorityRecords(e.checks, "contextAwareness checkRecord");
        return a.find(t, function(e) {
            e.contextValue || a.fail("Cannot perform check for contextAwareness record ", e, ' without a valid field named "contextValue"');
            var t = a.contextAware.getCheckValue(n, e.contextValue);
            if (void 0 === e.equals ? t : t === e.equals) return e.gradeNames;
        }, e.defaultGradeNames);
    }, a.contextAware.check = function(n, e) {
        var r = [], t = a.parsePriorityRecords(e, "contextAwareness adaptationRecord");
        return a.each(t, function(e) {
            var t = a.contextAware.checkOne(n, e);
            r = r.concat(a.makeArray(t));
        }), r;
    }, a.contextAware.makeAdaptation = function(e) {
        a.expect("fluid.contextAware.makeAdaptation", e, [ "distributionName", "targetName", "adaptationName", "checkName", "record" ]), 
        a.defaults(e.distributionName, {
            gradeNames: [ "fluid.component" ],
            distributeOptions: {
                target: "{/ " + e.targetName + "}.options.contextAwareness." + e.adaptationName + ".checks." + e.checkName,
                record: e.record
            }
        }), a.constructSingle([], e.distributionName);
    }, a.contextAware.isBrowser = function() {
        return "undefined" != typeof window && window.document;
    }, a.contextAware.makeChecks({
        "fluid.browser": {
            funcName: "fluid.contextAware.isBrowser"
        }
    }), a.registerNamespace("fluid.contextAware.browser"), a.contextAware.browser.getPlatformName = function() {
        return "undefined" != typeof navigator && navigator.platform ? navigator.platform : void 0;
    }, a.contextAware.browser.getUserAgent = function() {
        return "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent : void 0;
    }, a.contextAware.makeChecks({
        "fluid.browser.platformName": {
            funcName: "fluid.contextAware.browser.getPlatformName"
        },
        "fluid.browser.userAgent": {
            funcName: "fluid.contextAware.browser.getUserAgent"
        }
    });
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(o, n) {
    "use strict";
    var e, t;
    n.uaMatch = function(e) {
        e = e.toLowerCase();
        var t = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || e.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
        return {
            browser: t[1] || "",
            version: t[2] || "0"
        };
    }, o.browser || (navigator.userAgent.match(/Trident\/7\./) ? t = {
        msie: !0,
        version: 11
    } : (t = {}, (e = n.uaMatch(navigator.userAgent)).browser && (t[e.browser] = !0, 
    t.version = e.version), t.chrome ? t.webkit = !0 : t.webkit && (t.safari = !0)), 
    o.browser = t);
    var r = "fluid-scoped-data";
    n.getScopedData = function(e, t) {
        var n = o(e).data(r);
        return n ? n[t] : void 0;
    }, n.setScopedData = function(e, t, n) {
        o(e).each(function() {
            var e = o.data(this, r) || {};
            e[t] = n, o.data(this, r, e);
        });
    };
    var a = null;
    o(document).on("focusin", function(e) {
        a = e.target;
    }), n.getLastFocusedElement = function() {
        return a;
    };
    var i = "enablement";
    n.enabled = function(e, t) {
        if (e = o(e), void 0 === t) return !1 !== n.getScopedData(e, i);
        o("*", e).add(e).each(function() {
            void 0 !== n.getScopedData(this, i) ? n.setScopedData(this, i, t) : /select|textarea|input/i.test(this.nodeName) && o(this).prop("disabled", !t);
        }), n.setScopedData(e, i, t);
    }, n.initEnablement = function(e) {
        n.setScopedData(e, i, !0);
    }, n.resolveEventTarget = function(e) {
        for (;e.originalEvent && e.originalEvent.target; ) e = e.originalEvent;
        return e.target;
    }, o.each([ "focus", "blur" ], function(e, r) {
        n[r] = function(e) {
            return n = r, (t = o(t = e)).trigger("fluid-" + n), t.triggerHandler(n), t[n](), 
            t;
            var t, n;
        };
    }), n.changeElementValue = function(e, t) {
        (e = o(e)).val(t).change();
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, i) {
    "use strict";
    i.dom = i.dom || {};
    var u = function(e) {
        if (e.node.firstChild) return e.node = e.node.firstChild, e.depth += 1, e;
        for (;e.node; ) {
            if (e.node.nextSibling) return e.node = e.node.nextSibling, e;
            e.node = e.node.parentNode, e.depth -= 1;
        }
        return e;
    };
    i.dom.iterateDom = function(e, t, n) {
        for (var r, o = {
            node: e,
            depth: 0
        }, a = e; null !== o.node && 0 <= o.depth && o.depth < i.dom.iterateDom.DOM_BAIL_DEPTH; ) {
            if (r = null, (1 === o.node.nodeType || n) && (r = t(o.node, o.depth)), r) if ("delete" === r) o.node.parentNode.removeChild(o.node), 
            o.node = a; else if ("stop" === r) return o.node;
            a = o.node, o = u(o);
        }
    }, i.dom.iterateDom.DOM_BAIL_DEPTH = 256, i.dom.isContainer = function(e, t) {
        for (;t; t = t.parentNode) if (e === t) return !0;
        return !1;
    }, i.dom.getElementText = function(e) {
        for (var t = e.childNodes, n = "", r = 0; r < t.length; ++r) {
            var o = t[r];
            3 === o.nodeType && (n += o.nodeValue);
        }
        return n;
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(p, m) {
    "use strict";
    m.defaults("fluid.viewComponent", {
        gradeNames: [ "fluid.modelComponent" ],
        initFunction: "fluid.initView",
        argumentMap: {
            container: 0,
            options: 1
        },
        members: {
            dom: "@expand:fluid.initDomBinder({that}, {that}.options.selectors)"
        }
    }), m.dumpSelector = function(e) {
        return "string" == typeof e ? e : e.selector ? e.selector : "";
    }, m.diagnoseFailedView = function(e, t, n, r) {
        if (!t && m.hasGrade(n, "fluid.viewComponent")) {
            var o = m.wrap(r[1]), a = "Instantiation of view component with type " + e + " failed, since ";
            o ? 0 === o.length ? m.fail(a + 'selector "', m.dumpSelector(r[1]), '" did not match any markup in the document') : m.fail(a + " component creator function did not return a value") : m.fail(a + " container argument is empty");
        }
    }, m.checkTryCatchParameter = function() {
        var e = (window.location || {
            search: "",
            protocol: "file:"
        }).search.slice(1).split("&");
        return !0 === m.find(e, function(e) {
            if (0 === e.indexOf("notrycatch")) return !0;
        });
    }, m.notrycatch = m.checkTryCatchParameter(), m.wrap = function(e, t) {
        return t = t || p, !e || e.jquery ? e : t(e);
    }, m.unwrap = function(e) {
        return e && e.jquery ? e[0] : e;
    }, m.container = function(e, t, n) {
        var r = e.selector || e;
        n && (e = m.unwrap(e));
        var o = m.wrap(e, n);
        if (t && (!o || 0 === o.length)) return null;
        if (!o || !o.jquery || 1 !== o.length) {
            "string" != typeof e && (e = o.selector);
            var a = void 0 !== o.length ? o.length : 0;
            m.fail((1 < a ? "More than one (" + a + ") container elements were" : "No container element was") + " found for selector " + e);
        }
        return m.isDOMNode(o[0]) || m.fail("fluid.container was supplied a non-jQueryable element"), 
        o.selector = r, o.context = o.context || e.ownerDocument || document, o;
    }, m.createDomBinder = function(l, s) {
        var c = {
            id: m.allocateGuid(),
            cache: {}
        }, f = l.constructor;
        function d(e, t) {
            return m.allocateSimpleId(t) + "-" + e;
        }
        return c.locate = function(e, t) {
            var n, r, o, a, i, u;
            if (void 0 !== (n = s[e])) return (r = t ? p(t) : l) || m.fail("DOM binder invoked for selector " + e + " without container"), 
            (o = "" === n ? r : n ? "function" == typeof n ? f(n.call(null, m.unwrap(r))) : f(n, r) : f()).selector || (o.selector = n, 
            o.context = r), o.selectorName = e, a = e, i = r, u = o, c.cache[d(a, i)] = u, o;
        }, c.fastLocate = function(e, t) {
            var n = d(e, t || l), r = c.cache[n];
            return r || c.locate(e, t);
        }, c.clear = function() {
            c.cache = {};
        }, c.refresh = function(e, t) {
            var n = t || l;
            "string" == typeof e && (e = [ e ]), void 0 === n.length && (n = [ n ]);
            for (var r = 0; r < e.length; ++r) for (var o = 0; o < n.length; ++o) c.locate(e[r], n[o]);
        }, c.resolvePathSegment = c.locate, c;
    }, m.expectFilledSelector = function(e, t) {
        e && 0 === e.length && e.jquery && m.fail(t + ': selector "' + e.selector + '" with name ' + e.selectorName + " returned no results in context " + m.dumpEl(e.context));
    }, m.initView = function(e, t, n, r) {
        var o = m.container(t, !0);
        if (m.expectFilledSelector(o, 'Error instantiating component with name "' + e), 
        !o) return null;
        var a = m.initLittleComponent(e, n, r || {
            gradeNames: [ "fluid.viewComponent" ]
        }, function(e) {
            e.container = o;
        });
        a.dom || m.initDomBinder(a);
        var i = a.options.jQuery;
        return m.log("Constructing view component " + e + " with container " + o.constructor.expando + (i ? " user jQuery " + i.expando : "") + " env: " + p.expando), 
        a;
    }, m.initDomBinder = function(e, t) {
        return e.container || m.fail("fluid.initDomBinder called for component with typeName " + e.typeName + ' without an initialised container - this has probably resulted from placing "fluid.viewComponent" in incorrect position in grade merging order.  Make sure to place it to the right of any non-view grades in the gradeNames list to ensure that it overrides properly: resolved gradeNames is ', e.options.gradeNames, " for component ", e), 
        e.dom = m.createDomBinder(e.container, t || e.options.selectors || {}), e.locate = e.dom.locate, 
        e.dom;
    }, m.findAncestor = function(e, t) {
        for (e = m.unwrap(e); e; ) {
            if (t(e)) return e;
            e = e.parentNode;
        }
    }, m.findForm = function(e) {
        return m.findAncestor(e, function(e) {
            return "form" === e.nodeName.toLowerCase();
        });
    }, m.each([ "text", "html" ], function(n) {
        m[n] = function(e, t) {
            return e = p(e), void 0 === t ? e[n]() : e[n](t);
        };
    }), m.value = function(e, t) {
        var n = m.unwrap(e), r = !1;
        if (void 0 === n.nodeType && 1 < n.length && (n = n[0], r = !0), "input" !== n.nodeName.toLowerCase() || !/radio|checkbox/.test(n.type)) return void 0 === t ? p(n).val() : p(n).val(t);
        var o, a = n.name;
        if (void 0 === a && m.fail("Cannot acquire value from node " + m.dumpEl(n) + " which does not have name attribute set"), 
        r) o = e; else {
            o = n.ownerDocument.getElementsByName(a);
            var i = m.findForm(n);
            o = p.grep(o, function(e) {
                return e.name === a && (!i || m.dom.isContainer(i, e));
            });
        }
        if (void 0 === t) {
            var u = p.map(o, function(e) {
                return e.checked ? e.value : null;
            });
            return "radio" === n.type ? u[0] : u;
        }
        "boolean" == typeof t && (t = t ? "true" : "false"), p.each(o, function() {
            this.checked = t instanceof Array ? -1 !== t.indexOf(this.value) : t === this.value;
        });
    }, m.BINDING_ROOT_KEY = "fluid-binding-root", m.findData = function(e, t) {
        for (;e; ) {
            var n = p.data(e, t);
            if (n) return n;
            e = e.parentNode;
        }
    }, m.bindFossils = function(e, t, n) {
        p.data(e, m.BINDING_ROOT_KEY, {
            data: t,
            fossils: n
        });
    }, m.boundPathForNode = function(e, t) {
        var n = t[(e = m.unwrap(e)).name || e.id];
        return n ? n.EL : null;
    }, m.applyBoundChange = function(e, t, n) {
        e = m.unwrap(e), void 0 === t && (t = m.value(e)), void 0 === e.nodeType && 0 < e.length && (e = e[0]);
        var r = m.findData(e, m.BINDING_ROOT_KEY);
        r || m.fail("Bound data could not be discovered in any node above " + m.dumpEl(e));
        var o = e.name, a = r.fossils[o];
        a || m.fail("No fossil discovered for name " + o + " in fossil record above " + m.dumpEl(e)), 
        "boolean" == typeof a.oldvalue && (t = !!t[0]);
        var i = r.fossils[o].EL;
        n ? n.fireChangeRequest({
            path: i,
            value: t,
            source: "DOM:" + e.id
        }) : m.set(r.data, i, t);
    }, m.jById = function(e, t) {
        t = t && 9 === t.nodeType ? t : document;
        var n = m.byId(e, t), r = n ? p(n) : [];
        return r.selector = "#" + e, r.context = t, r;
    }, m.byId = function(e, t) {
        var n = (t = t && 9 === t.nodeType ? t : document).getElementById(e);
        return n ? (n.id !== e && m.fail("Problem in document structure - picked up element " + m.dumpEl(n) + " for id " + e + " without this id - most likely the element has a name which conflicts with this id"), 
        n) : null;
    }, m.getId = function(e) {
        return m.unwrap(e).id;
    }, m.allocateSimpleId = function(e) {
        if (!(e = m.unwrap(e)) || m.isPrimitive(e)) return null;
        if (!e.id) {
            var t = "fluid-id-" + m.allocateGuid();
            e.id = t;
        }
        return e.id;
    }, m.getDocument = function(e) {
        var t = m.unwrap(e);
        return 9 === t.nodeType ? t : t.ownerDocument;
    }, m.defaults("fluid.ariaLabeller", {
        gradeNames: [ "fluid.viewComponent" ],
        labelAttribute: "aria-label",
        liveRegionMarkup: '<div class="liveRegion fl-hidden-accessible" aria-live="polite"></div>',
        liveRegionId: "fluid-ariaLabeller-liveRegion",
        invokers: {
            generateLiveElement: {
                funcName: "fluid.ariaLabeller.generateLiveElement",
                args: "{that}"
            },
            update: {
                funcName: "fluid.ariaLabeller.update",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        listeners: {
            onCreate: {
                func: "{that}.update",
                args: [ null ]
            }
        }
    }), m.ariaLabeller.update = function(e, t) {
        if (t = t || e.options, e.container.attr(e.options.labelAttribute, t.text), t.dynamicLabel) {
            var n = m.jById(e.options.liveRegionId);
            0 === n.length && (n = e.generateLiveElement()), n.text(t.text);
        }
    }, m.ariaLabeller.generateLiveElement = function(e) {
        var t = p(e.options.liveRegionMarkup);
        return t.prop("id", e.options.liveRegionId), p("body").append(t), t;
    };
    var o = "aria-labelling";
    m.getAriaLabeller = function(e) {
        return e = p(e), m.getScopedData(e, o);
    }, m.updateAriaLabel = function(e, t, n) {
        n = p.extend({}, n || {}, {
            text: t
        });
        var r = m.getAriaLabeller(e);
        return r ? r.update(n) : (r = m.ariaLabeller(e, n), m.setScopedData(e, o, r)), r;
    };
    var r = {};
    p(document).click(function(n) {
        for (var e = m.resolveEventTarget(n); e; ) {
            if (r[e.id]) return;
            e = e.parentNode;
        }
        m.each(r, function(e, t) {
            e(n), delete r[t];
        });
    }), m.globalDismissal = function(e, n) {
        m.each(e, function(e) {
            var t = m.unwrap(e).ownerDocument === document ? m.allocateSimpleId(e) : m.allocateGuid();
            n ? r[t] = n : delete r[t];
        });
    }, m.now = function() {
        return Date.now ? Date.now() : new Date().getTime();
    }, m.deadMansBlur = function(n, e) {
        var r = {
            options: p.extend(!0, {}, m.defaults("fluid.deadMansBlur"), e),
            blurPending: !1,
            lastCancel: 0,
            canceller: function(e) {
                m.log("Cancellation through " + e.type + " on " + m.dumpEl(e.target)), r.lastCancel = m.now(), 
                r.blurPending = !1;
            },
            noteProceeded: function() {
                m.globalDismissal(r.options.exclusions);
            },
            reArm: function() {
                m.globalDismissal(r.options.exclusions, r.proceed);
            },
            addExclusion: function(e) {
                m.globalDismissal(e, r.proceed);
            },
            proceed: function(e) {
                m.log("Direct proceed through " + e.type + " on " + m.dumpEl(e.target)), r.blurPending = !1, 
                r.options.handler(n);
            }
        };
        return m.each(r.options.exclusions, function(e) {
            e = p(e), m.each(e, function(e) {
                p(e).on("focusin", r.canceller).on("fluid-focus", r.canceller).click(r.canceller).mousedown(r.canceller);
            });
        }), r.options.cancelByDefault ? r.reArm() : p(n).on("focusout", function(e) {
            m.log("Starting blur timer for element " + m.dumpEl(e.target));
            var t = m.now();
            m.log("back delay: " + (t - r.lastCancel)), t - r.lastCancel > r.options.backDelay && (r.blurPending = !0), 
            setTimeout(function() {
                r.blurPending && r.options.handler(n);
            }, r.options.delay);
        }), r;
    }, m.defaults("fluid.deadMansBlur", {
        gradeNames: "fluid.function",
        delay: 150,
        backDelay: 100
    });
}(jQuery, fluid_3_0_0), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.ArrayMath) {
        var t = {
            add: function(e, t, n) {
                var r;
                if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = t[r] + n[r]; else for (r = Math.min(e.length, n.length) - 1; 0 <= r; --r) e[r] = t + n[r];
            },
            sub: function(e, t, n) {
                var r;
                if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = t[r] - n[r]; else for (r = Math.min(e.length, n.length) - 1; 0 <= r; --r) e[r] = t - n[r];
            },
            mul: function(e, t, n) {
                var r;
                if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = t[r] * n[r]; else for (r = Math.min(e.length, n.length) - 1; 0 <= r; --r) e[r] = t * n[r];
            },
            mulCplx: function(e, t, n, r, o, a) {
                var i, u, l, s, c;
                if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, r.length, o.length, a.length) - 1; 0 <= i; --i) u = n[i], 
                l = r[i], s = o[i], c = a[i], e[i] = u * s - l * c, t[i] = u * c + l * s; else for (i = Math.min(e.length, t.length, o.length, a.length) - 1; 0 <= i; --i) s = o[i], 
                c = a[i], e[i] = n * s - r * c, t[i] = n * c + r * s;
            },
            div: function(e, t, n) {
                var r;
                if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = t[r] / n[r]; else for (r = Math.min(e.length, n.length) - 1; 0 <= r; --r) e[r] = t / n[r];
            },
            divCplx: function(e, t, n, r, o, a) {
                var i, u, l, s, c, f;
                if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, r.length, o.length, a.length) - 1; 0 <= i; --i) u = n[i], 
                l = r[i], f = 1 / ((s = o[i]) * s + (c = a[i]) * c), e[i] = (u * s + l * c) * f, 
                t[i] = (l * s - u * c) * f; else for (i = Math.min(e.length, t.length, o.length, a.length) - 1; 0 <= i; --i) f = 1 / ((s = o[i]) * s + (c = a[i]) * c), 
                e[i] = (n * s + r * c) * f, t[i] = (r * s - n * c) * f;
            },
            madd: function(e, t, n, r) {
                var o;
                if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length, r.length) - 1; 0 <= o; --o) e[o] = t[o] * n[o] + r[o]; else for (o = Math.min(e.length, n.length, r.length) - 1; 0 <= o; --o) e[o] = t * n[o] + r[o];
            },
            abs: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.abs(t[n]);
            },
            absCplx: function(e, t, n) {
                for (var r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = Math.sqrt(t[r] * t[r] + n[r] * n[r]);
            },
            acos: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.acos(t[n]);
            },
            asin: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.asin(t[n]);
            },
            atan: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.atan(t[n]);
            },
            atan2: function(e, t, n) {
                for (var r = Math.min(e.length, n.length, t.length) - 1; 0 <= r; --r) e[r] = Math.atan2(t[r], n[r]);
            },
            ceil: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.ceil(t[n]);
            },
            cos: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.cos(t[n]);
            },
            exp: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.exp(t[n]);
            },
            floor: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.floor(t[n]);
            },
            log: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.log(t[n]);
            },
            max: function(e) {
                for (var t = -1 / 0, n = e.length - 1; 0 <= n; --n) {
                    var r = e[n];
                    t < r && (t = r);
                }
                return t;
            },
            min: function(e) {
                for (var t = 1 / 0, n = e.length - 1; 0 <= n; --n) {
                    var r = e[n];
                    r < t && (t = r);
                }
                return t;
            },
            pow: function(e, t, n) {
                var r;
                if (n instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = Math.pow(t[r], n[r]); else for (r = Math.min(e.length, t.length) - 1; 0 <= r; --r) e[r] = Math.pow(t[r], n);
            },
            random: function(e, t, n) {
                t || (t = 0), isNaN(parseFloat(n)) && (n = 1);
                for (var r = n - t, o = e.length - 1; 0 <= o; --o) e[o] = Math.random() * r + t;
            },
            round: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.round(t[n]);
            },
            sin: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.sin(t[n]);
            },
            sqrt: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.sqrt(t[n]);
            },
            tan: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.tan(t[n]);
            },
            clamp: function(e, t, n, r) {
                for (var o = Math.min(e.length, t.length) - 1; 0 <= o; --o) {
                    var a = t[o];
                    e[o] = a < n ? n : r < a ? r : a;
                }
            },
            fract: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) {
                    var r = t[n];
                    e[n] = r - Math.floor(r);
                }
            },
            fill: function(e, t) {
                for (var n = e.length - 1; 0 <= n; --n) e[n] = t;
            },
            ramp: function(e, t, n) {
                var r = e.length - 1;
                if (0 <= r && (e[0] = t), 0 < r) for (var o = (n - t) / r, a = 1; a <= r; ++a) e[a] = t + o * a;
            },
            sign: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = t[n] < 0 ? -1 : 1;
            },
            sum: function(e) {
                for (var t = 0, n = e.length - 1; 0 <= n; --n) t += e[n];
                return t;
            },
            sampleLinear: function(e, t, n) {
                for (var r = t.length - 1, o = Math.min(e.length, n.length) - 1; 0 <= o; --o) {
                    var a = n[o];
                    a = a < 0 ? 0 : r < a ? r : a;
                    var i = Math.floor(a), u = a - i, l = t[i], s = t[i < r ? i + 1 : r];
                    e[o] = l + u * (s - l);
                }
            },
            sampleLinearRepeat: function(e, t, n) {
                for (var r = t.length, o = r - 1, a = Math.min(e.length, n.length) - 1; 0 <= a; --a) {
                    var i = n[a];
                    i -= Math.floor(i / r) * r;
                    var u = Math.floor(i), l = i - u, s = t[u], c = t[u < o ? u + 1 : 0];
                    e[a] = s + l * (c - s);
                }
            },
            sampleCubic: function(e, t, n) {
                for (var r = t.length - 1, o = Math.min(e.length, n.length) - 1; 0 <= o; --o) {
                    var a = n[o];
                    a = a < 0 ? 0 : r < a ? r : a;
                    var i = Math.floor(a), u = a - i, l = u * u, s = l * u, c = -2 * s + 3 * l, f = 1 - c, d = s - l, p = d - l + u, m = t[0 < i ? i - 1 : 0], g = t[i], h = t[i < r ? i + 1 : r], v = t[i < r - 1 ? i + 2 : r];
                    e[o] = f * g + c * h + .5 * (p * (h - m) + d * (v - g));
                }
            },
            sampleCubicRepeat: function(e, t, n) {
                for (var r = t.length, o = r - 1, a = Math.min(e.length, n.length) - 1; 0 <= a; --a) {
                    var i = n[a];
                    i -= Math.floor(i / r) * r;
                    var u = Math.floor(i), l = i - u, s = l * l, c = s * l, f = -2 * c + 3 * s, d = 1 - f, p = c - s, m = p - s + l, g = t[0 < u ? u - 1 : o], h = t[u], v = t[u < o ? u + 1 : 0], y = t[u < o - 1 ? u + 2 : u + 2 - Math.floor((u + 2) / r) * r];
                    e[a] = d * h + f * v + .5 * (m * (v - g) + p * (y - h));
                }
            },
            pack: function(e, t, n, r, o, a, i) {
                var u = Math.floor(Math.max(0, e.length - t) / n), l = Math.min(u, r.length);
                if (o) {
                    l = Math.min(l, o.length);
                    if (a) {
                        l = Math.min(l, a.length);
                        if (i) {
                            l = Math.min(l, i.length);
                            for (var s = 0; s < l; ++s) e[t] = r[s], e[t + 1] = o[s], e[t + 2] = a[s], e[t + 3] = i[s], 
                            t += n;
                        } else for (s = 0; s < l; ++s) e[t] = r[s], e[t + 1] = o[s], e[t + 2] = a[s], t += n;
                    } else for (s = 0; s < l; ++s) e[t] = r[s], e[t + 1] = o[s], t += n;
                } else for (s = 0; s < l; ++s) e[t] = r[s], t += n;
            },
            unpack: function(e, t, n, r, o, a, i) {
                var u = Math.floor(Math.max(0, e.length - t) / n), l = Math.min(u, r.length);
                if (o) {
                    l = Math.min(l, o.length);
                    if (a) {
                        l = Math.min(l, a.length);
                        if (i) {
                            l = Math.min(l, i.length);
                            for (var s = 0; s < l; ++s) r[s] = e[t], o[s] = e[t + 1], a[s] = e[t + 2], i[s] = e[t + 3], 
                            t += n;
                        } else for (s = 0; s < l; ++s) r[s] = e[t], o[s] = e[t + 1], a[s] = e[t + 2], t += n;
                    } else for (s = 0; s < l; ++s) r[s] = e[t], o[s] = e[t + 1], t += n;
                } else for (s = 0; s < l; ++s) r[s] = e[t], t += n;
            }
        };
        e.ArrayMath = t;
    }
}(), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.Filter) {
        var t = function(e, t) {
            !isNaN(parseFloat(e)) && isFinite(e) || (e = 1), t || (t = 0), this._b = new Float32Array(e), 
            this._b[0] = 1, this._a = new Float32Array(t), this._bHist = new Float32Array(e), 
            this._aHist = new Float32Array(t);
        };
        t.prototype.filter = function(e, t) {
            var n, r = this._a, o = r.length, a = this._b, i = a.length, u = this._aHist, l = this._bHist, s = t.length, c = e.length, f = i - 1, d = o;
            for (n = 0; (f || d) && n < s; ++n) {
                var p;
                p = i - f, f && f--;
                var m = a[0] * t[n];
                for (N = 1; N < p; ++N) m += a[N] * t[n - N];
                for (;N < i; ++N) m += a[N] * l[N - p];
                for (p = o - d, d && d--, N = 0; N < p; ++N) m -= r[N] * e[n - 1 - N];
                for (;N < o; ++N) m -= r[N] * u[N - p];
                e[n] = m;
            }
            if (3 == i && 2 == o) for (var g, h, v = a[0], y = a[1], k = a[2], b = r[0], x = r[1], S = t[n - 1], w = t[n - 2], C = e[n - 1], A = e[n - 2]; n < s; ++n) g = w, 
            w = S, h = A, C = v * (S = t[n]) + y * w + k * g - b * (A = C) - x * h, e[n] = C; else for (;n < s; ++n) {
                var N;
                m = a[0] * t[n];
                for (N = 1; N < i; ++N) m += a[N] * t[n - N];
                for (N = 0; N < o; ++N) m -= r[N] * e[n - 1 - N];
                e[n] = m;
            }
            var T = Math.min(i - 1, s);
            for (n = i - 2; T <= n; --n) l[n] = l[n - T];
            for (n = 0; n < T; ++n) l[n] = t[s - 1 - n];
            for (T = Math.min(o, c), n = o - 1; T <= n; --n) u[n] = u[n - T];
            for (n = 0; n < T; ++n) u[n] = e[s - 1 - n];
        }, t.prototype.clearHistory = function() {
            for (var e = this._bHist.length - 1; 0 <= e; --e) this._bHist[e] = 0;
            for (e = this._aHist.length - 1; 0 <= e; --e) this._aHist[e] = 0;
        }, t.prototype.setB = function(e) {
            for (var t = Math.min(this._b.length, e.length), n = 0; n < t; ++n) this._b[n] = e[n];
        }, t.prototype.setA = function(e) {
            for (var t = Math.min(this._a.length, e.length), n = 0; n < t; ++n) this._a[n] = e[n];
        }, e.Filter = t;
    }
}(), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.FFT) {
        var k = function(e, t, n, r, o, a, i, u, l, s, c, f, d, p) {
            var m = l[s++], g = l[s++], h = n, v = n + m * g, y = i * u;
            if (1 == g) for (;e[n] = r[a], t[n] = o[a], a += y, ++n != v; ) ; else for (;k(e, t, n, r, o, a, i * m, u, l, s, c, f, d, p), 
            a += y, (n += g) != v; ) ;
            switch (n = h, m) {
              case 2:
                !function(e, t, n, r, o, a, i) {
                    for (var u, l, s, c, f, d, p, m, g = 0, h = n, v = n + i, y = .7071067811865475, k = h + i; h < k; ) s = e[h] * y, 
                    c = t[h] * y, f = e[v] * y, d = t[v] * y, u = f * (p = o[g]) - d * (m = a[g]), l = f * m + d * p, 
                    e[v] = s - u, t[v] = c - l, e[h] = s + u, t[h] = c + l, g += r, ++h, ++v;
                }(e, t, n, i, c, f, g);
                break;

              case 3:
                !function(e, t, n, r, o, a, i) {
                    for (var u, l, s, c, f, d, p, m, g, h, v, y, k, b, x, S, w = 0, C = 0, A = 2 * r, N = n, T = n + i, I = n + 2 * i, M = a[r * i], P = .5773502691896258, O = N + i; N < O; ) g = e[N] * P, 
                    h = t[N] * P, v = e[T] * P, y = t[T] * P, k = e[I] * P, b = t[I] * P, x = o[w], 
                    c = v * (S = a[w]) + y * x, u = (s = v * x - y * S) - (f = k * (x = o[C]) - b * (S = a[C])), 
                    l = c - (d = k * S + b * x), v = g - .5 * (p = s + f), y = h - .5 * (m = c + d), 
                    u *= M, l *= M, e[N] = g + p, t[N] = h + m, e[I] = v + l, t[I] = y - u, e[T] = v - l, 
                    t[T] = y + u, w += r, C += A, ++N, ++T, ++I;
                }(e, t, n, i, c, f, g);
                break;

              case 4:
                !function(e, t, n, r, o, a, i, u) {
                    for (var l, s, c, f, d, p, m, g, h, v, y, k, b, x, S, w, C, A, N, T, I, M, P = 0, O = 0, D = 0, L = 2 * r, E = 3 * r, R = n, V = n + i, F = n + 2 * i, B = n + 3 * i, q = R + i; R < q; ) b = .5 * e[R], 
                    x = .5 * t[R], S = .5 * e[V], w = .5 * t[V], C = .5 * e[F], A = .5 * t[F], N = .5 * e[B], 
                    T = .5 * t[B], l = S * (I = o[P]) - w * (M = a[P]), s = S * M + w * I, y = b - (c = C * (I = o[O]) - A * (M = a[O])), 
                    k = x - (f = C * M + A * I), b += c, x += f, m = l + (d = N * (I = o[D]) - T * (M = a[D])), 
                    g = s + (p = N * M + T * I), h = l - d, v = s - p, e[F] = b - m, t[F] = x - g, e[R] = b + m, 
                    t[R] = x + g, u ? (e[V] = y - v, t[V] = k + h, e[B] = y + v, t[B] = k - h) : (e[V] = y + v, 
                    t[V] = k - h, e[B] = y - v, t[B] = k + h), P += r, O += L, D += E, ++R, ++V, ++F, 
                    ++B;
                }(e, t, n, i, c, f, g, p);
                break;

              case 5:
                !function(e, t, n, r, o, a, i) {
                    for (var u, l, s, c, f, d, p, m, g, h, v, y, k, b, x, S, w, C, A, N, T, I, M, P, O, D, L, E, R, V, F, B, q, _, G, j, U, H, W = 0, z = 0, $ = 0, K = 0, J = 2 * r, X = 3 * r, Q = 4 * r, Y = n, Z = n + i, ee = n + 2 * i, te = n + 3 * i, ne = n + 4 * i, re = o[r * i], oe = a[r * i], ae = o[2 * r * i], ie = a[2 * r * i], ue = .4472135954999579, le = Y + i; Y < le; ) L = e[Y] * ue, 
                    E = t[Y] * ue, R = e[Z] * ue, V = t[Z] * ue, F = e[ee] * ue, B = t[ee] * ue, q = e[te] * ue, 
                    _ = t[te] * ue, G = e[ne] * ue, j = t[ne] * ue, u = L, l = E, s = R * (U = o[W]) - V * (H = a[W]), 
                    c = R * H + V * U, f = F * (U = o[z]) - B * (H = a[z]), d = F * H + B * U, p = q * (U = o[$]) - _ * (H = a[$]), 
                    m = q * H + _ * U, x = s + (g = G * (U = o[K]) - j * (H = a[K])), S = c + (h = G * H + j * U), 
                    T = s - g, I = c - h, w = f + p, C = d + m, A = f - p, N = d - m, e[Y] = L + x + w, 
                    t[Y] = E + S + C, v = u + x * re + w * ae, y = l + S * re + C * ae, k = I * oe + N * ie, 
                    b = -T * oe - A * ie, e[Z] = v - k, t[Z] = y - b, e[ne] = v + k, t[ne] = y + b, 
                    M = u + x * ae + w * re, P = l + S * ae + C * re, O = -I * ie + N * oe, D = T * ie - A * oe, 
                    e[ee] = M + O, t[ee] = P + D, e[te] = M - O, t[te] = P - D, W += r, z += J, $ += X, 
                    K += Q, ++Y, ++Z, ++ee, ++te, ++ne;
                }(e, t, n, i, c, f, g);
                break;

              default:
                !function(e, t, n, r, o, a, i, u, l) {
                    var s, c, f, d, p, m, g, h, v, y, k = new Float32Array(u), b = new Float32Array(u), x = Math.sqrt(1 / u);
                    for (s = 0; s < i; ++s) {
                        for (d = n + s, c = 0; c < u; ++c) k[c] = e[d] * x, b[c] = t[d] * x, d += i;
                        d = n + s;
                        var S = r * s;
                        for (c = 0; c < u; ++c) {
                            p = k[0], m = b[0];
                            var w = 0;
                            for (f = 1; f < u; ++f) l <= (w += S) && (w -= l), g = k[f], h = b[f], p += g * (v = o[w]) - h * (y = a[w]), 
                            m += g * y + h * v;
                            e[d] = p, t[d] = m, d += i, S += r;
                        }
                    }
                }(e, t, n, i, c, f, g, m, d);
            }
        }, t = function(e) {
            e || (e = 256), Object.defineProperty(this, "size", {
                configurable: !1,
                writable: !1,
                value: e
            }), this._twiddlesFwdRe = new Float32Array(e), this._twiddlesFwdIm = new Float32Array(e), 
            this._twiddlesInvRe = this._twiddlesFwdRe, this._twiddlesInvIm = new Float32Array(e);
            for (var t = 0; t < e; ++t) {
                var n = -2 * Math.PI * t / e, r = Math.cos(n), o = Math.sin(n);
                this._twiddlesFwdRe[t] = r, this._twiddlesFwdIm[t] = o, this._twiddlesInvIm[t] = -o;
            }
            this._factors = new Int32Array(64), function(e, t) {
                var n = 4, r = Math.floor(Math.sqrt(e)), o = 0;
                do {
                    for (;e % n; ) {
                        switch (n) {
                          case 4:
                            n = 2;
                            break;

                          case 2:
                            n = 3;
                            break;

                          default:
                            n += 2;
                        }
                        r < n && (n = e);
                    }
                    e = Math.floor(e / n), t[o++] = n, t[o++] = e;
                } while (1 < e);
            }(e, this._factors);
        };
        t.prototype.forwardCplx = function(e, t, n, r) {
            var o = this._twiddlesFwdRe, a = this._twiddlesFwdIm;
            k(e, t, 0, n, r, 0, 1, 1, this._factors, 0, o, a, this.size, !1);
        }, t.prototype.forward = function(e, t, n) {
            this.forwardCplx(e, t, n, new Float32Array(this.size));
        }, t.prototype.inverseCplx = function(e, t, n, r) {
            var o = this._twiddlesInvRe, a = this._twiddlesInvIm;
            k(e, t, 0, n, r, 0, 1, 1, this._factors, 0, o, a, this.size, !0);
        }, t.prototype.inverse = function(e, t, n) {
            this.inverseCplx(e, new Float32Array(this.size), t, n);
        }, e.FFT = t;
    }
}();

var Random = function(e) {
    if ("number" != typeof (e = void 0 === e ? new Date().getTime() : e) || Math.ceil(e) != Math.floor(e)) throw new TypeError("seed value must be an integer");
    this.N = 624, this.M = 397, this.MATRIX_A = 2567483615, this.UPPER_MASK = 2147483648, 
    this.LOWER_MASK = 2147483647, this.mt = new Array(this.N), this.mti = this.N + 1, 
    this.init_by_array([ e ], 1);
};

Random.prototype.init_genrand = function(e) {
    for (this.mt[0] = e >>> 0, this.mti = 1; this.mti < this.N; this.mti++) {
        e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
        this.mt[this.mti] = (1812433253 * ((4294901760 & e) >>> 16) << 16) + 1812433253 * (65535 & e) + this.mti, 
        this.mt[this.mti] >>>= 0;
    }
}, Random.prototype.init_by_array = function(e, t) {
    var n, r, o;
    for (this.init_genrand(19650218), n = 1, r = 0, o = this.N > t ? this.N : t; o; o--) {
        var a = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
        this.mt[n] = (this.mt[n] ^ (1664525 * ((4294901760 & a) >>> 16) << 16) + 1664525 * (65535 & a)) + e[r] + r, 
        this.mt[n] >>>= 0, r++, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1), 
        t <= r && (r = 0);
    }
    for (o = this.N - 1; o; o--) {
        a = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
        this.mt[n] = (this.mt[n] ^ (1566083941 * ((4294901760 & a) >>> 16) << 16) + 1566083941 * (65535 & a)) - n, 
        this.mt[n] >>>= 0, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1);
    }
    this.mt[0] = 2147483648;
}, Random.prototype.genrand_int32 = function() {
    var e, t = new Array(0, this.MATRIX_A);
    if (this.mti >= this.N) {
        var n;
        for (this.mti == this.N + 1 && this.init_genrand(5489), n = 0; n < this.N - this.M; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
        this.mt[n] = this.mt[n + this.M] ^ e >>> 1 ^ t[1 & e];
        for (;n < this.N - 1; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
        this.mt[n] = this.mt[n + (this.M - this.N)] ^ e >>> 1 ^ t[1 & e];
        e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[1 & e], 
        this.mti = 0;
    }
    return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, 
    (e ^= e >>> 18) >>> 0;
}, Random.prototype.genrand_int31 = function() {
    return this.genrand_int32() >>> 1;
}, Random.prototype.genrand_real1 = function() {
    return this.genrand_int32() * (1 / 4294967295);
}, Random.prototype.random = function() {
    return this.pythonCompatibility && (this.skip && this.genrand_int32(), this.skip = !0), 
    this.genrand_int32() * (1 / 4294967296);
}, Random.prototype.genrand_real3 = function() {
    return (this.genrand_int32() + .5) * (1 / 4294967296);
}, Random.prototype.genrand_res53 = function() {
    return (67108864 * (this.genrand_int32() >>> 5) + (this.genrand_int32() >>> 6)) * (1 / 9007199254740992);
}, Random.prototype.LOG4 = Math.log(4), Random.prototype.SG_MAGICCONST = 1 + Math.log(4.5), 
Random.prototype.exponential = function(e) {
    if (1 != arguments.length) throw new SyntaxError("exponential() must  be called with 'lambda' parameter");
    var t = this.random();
    return -Math.log(t) / e;
}, Random.prototype.gamma = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("gamma() must be called with alpha and beta parameters");
    if (!(1 < e)) {
        if (1 == e) {
            for (var n = this.random(); n <= 1e-7; ) n = this.random();
            return -Math.log(n) * t;
        }
        for (;;) {
            n = this.random();
            var r = (Math.E + e) / Math.E, o = r * n;
            if (o <= 1) s = Math.pow(o, 1 / e); else s = -Math.log((r - o) / e);
            l = this.random();
            if (1 < o) {
                if (l <= Math.pow(s, e - 1)) break;
            } else if (l <= Math.exp(-s)) break;
        }
        return s * t;
    }
    for (var a = Math.sqrt(2 * e - 1), i = e - this.LOG4, u = e + a; ;) {
        var l;
        if (!((l = this.random()) < 1e-7 || .9999999 < n)) {
            var s, c = 1 - this.random(), f = Math.log(l / (1 - l)) / a, d = l * l * c, p = i + u * f - (s = e * Math.exp(f));
            if (0 <= p + this.SG_MAGICCONST - 4.5 * d || p >= Math.log(d)) return s * t;
        }
    }
}, Random.prototype.normal = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("normal() must be called with mu and sigma parameters");
    var n = this.lastNormal;
    if (this.lastNormal = NaN, !n) {
        var r = 2 * this.random() * Math.PI, o = Math.sqrt(-2 * Math.log(1 - this.random()));
        n = Math.cos(r) * o, this.lastNormal = Math.sin(r) * o;
    }
    return e + n * t;
}, Random.prototype.pareto = function(e) {
    if (1 != arguments.length) throw new SyntaxError("pareto() must be called with alpha parameter");
    var t = this.random();
    return 1 / Math.pow(1 - t, 1 / e);
}, Random.prototype.triangular = function(e, t, n) {
    if (3 != arguments.length) throw new SyntaxError("triangular() must be called with lower, upper and mode parameters");
    var r = (n - e) / (t - e), o = this.random();
    return o <= r ? e + Math.sqrt(o * (t - e) * (n - e)) : t - Math.sqrt((1 - o) * (t - e) * (t - n));
}, Random.prototype.uniform = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("uniform() must be called with lower and upper parameters");
    return e + this.random() * (t - e);
}, Random.prototype.weibull = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("weibull() must be called with alpha and beta parameters");
    var n = 1 - this.random();
    return e * Math.pow(-Math.log(n), 1 / t);
}, "undefined" == typeof window && "undefined" != typeof module && module.exports && (module.exports = Random);

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var a = fluid.registerNamespace("jQuery");
    if (flock.fluid = fluid, flock.init = function(e) {
        var t = e ? {
            components: {
                audioSystem: {
                    options: {
                        model: e
                    }
                }
            }
        } : void 0;
        return flock.enviro(t);
    }, flock.ALL_CHANNELS = 32, flock.OUT_UGEN_ID = "flocking-out", flock.PI = Math.PI, 
    flock.TWOPI = 2 * Math.PI, flock.HALFPI = Math.PI / 2, flock.LOG01 = Math.log(.1), 
    flock.LOG001 = Math.log(.001), flock.ROOT2 = Math.sqrt(2), flock.rates = {
        AUDIO: "audio",
        CONTROL: "control",
        SCHEDULED: "scheduled",
        DEMAND: "demand",
        CONSTANT: "constant"
    }, fluid.registerNamespace("flock.debug"), flock.debug.failHard = !0, flock.browser = function() {
        if ("undefined" == typeof navigator) return {};
        var e, t, n = navigator.userAgent.toLowerCase(), r = {};
        return (t = {
            browser: (e = /(chrome)[ \/]([\w.]+)/.exec(n) || /(webkit)[ \/]([\w.]+)/.exec(n) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(n) || /(msie) ([\w.]+)/.exec(n) || n.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(n) || [])[1] || "",
            version: e[2] || "0"
        }).browser && (r[t.browser] = !0, r.version = t.version), r.chrome ? r.webkit = !0 : r.webkit && (r.safari = !0), 
        r;
    }, fluid.registerNamespace("flock.platform"), flock.platform.isBrowser = "undefined" != typeof window, 
    flock.platform.hasRequire = "undefined" != typeof require, flock.platform.os = flock.platform.isBrowser ? window.navigator.platform : require("os").platform(), 
    flock.platform.isLinux = -1 < flock.platform.os.indexOf("Linux"), flock.platform.isAndroid = flock.platform.isLinux && -1 < flock.platform.os.indexOf("arm"), 
    flock.platform.isIOS = "iPhone" === flock.platform.os || "iPad" === flock.platform.os || "iPod" === flock.platform.os, 
    flock.platform.isMobile = flock.platform.isAndroid || flock.platform.isIOS, flock.platform.browser = flock.browser(), 
    flock.platform.isWebAudio = "undefined" != typeof AudioContext || "undefined" != typeof webkitAudioContext, 
    flock.platform.audioEngine = flock.platform.isBrowser ? "webAudio" : "nodejs", flock.platform.browser && void 0 !== flock.platform.browser.version) {
        var e = flock.platform.browser.version.indexOf(".");
        flock.platform.browser.majorVersionNumber = Number(e < 0 ? flock.platform.browser.version : flock.platform.browser.version.substring(0, e));
    }
    flock.shim = {
        URL: flock.platform.isBrowser ? window.URL || window.webkitURL || window.msURL : void 0
    }, flock.requireModule = function(e, t) {
        if (flock.platform.isBrowser) return window[t || e];
        if (flock.platform.hasRequire) {
            var n = flock.requireModule.paths[e] || e, r = require(n);
            return t ? r[t] : r;
        }
    }, flock.requireModule.paths = {
        webarraymath: "../third-party/webarraymath/js/webarraymath.js",
        Random: "../third-party/simjs/js/random-0.26.js"
    }, flock.noOp = function() {}, flock.isIterable = function(e) {
        var t = typeof e;
        return e && void 0 !== e.length && "string" !== t && "function" !== t;
    }, flock.hasValue = function(e, t) {
        var n = !1;
        for (var r in e) if (e[r] === t) {
            n = !0;
            break;
        }
        return n;
    }, flock.hasTag = function(e, t) {
        return !(!e || !t) && (e.tags && -1 < e.tags.indexOf(t));
    }, flock.randomValue = function(e, t) {
        var n = t - e;
        return Math.random() * n + e;
    }, flock.randomAudioValue = function() {
        return 2 * Math.random() - 1;
    }, flock.fillBuffer = function(e, t) {
        for (var n = 0; n < e.length; n++) e[n] = t(n, e);
        return e;
    }, flock.fillBufferWithValue = function(e, t) {
        for (var n = 0; n < e.length; n++) e[n] = t;
        return e;
    }, flock.generateBuffer = function(e, t) {
        var n = new Float32Array(e);
        return flock.fillBuffer(n, t);
    }, flock.generateBufferWithValue = function(e, t) {
        var n = new Float32Array(e);
        return flock.fillBufferWithValue(n, t);
    }, flock.generate = function(e, t) {
        var n = "number" == typeof e;
        return ("function" == typeof t ? n ? flock.generateBuffer : flock.fillBuffer : n ? flock.generateBufferWithValue : flock.fillBufferWithValue)(e, t);
    }, flock.generate.silence = function(e) {
        return new Float32Array(e);
    }, flock.clearBuffer = function(e) {
        for (var t = 0; t < e.length; t++) e[t] = 0;
        return e;
    }, flock.reverse = function(e) {
        if (!e || !flock.isIterable(e) || e.length < 2) return e;
        if ("function" == typeof e.reverse) return e.reverse();
        for (var t, n = 0, r = e.length - 1; n < r; n++, r--) t = e[n], e[n] = e[r], e[r] = t;
        return e;
    }, flock.randomIndex = function(e) {
        var t = e.length - 1;
        return Math.round(Math.random() * t);
    }, flock.arrayChoose = function(e, t) {
        return t = t || flock.randomIndex, (e = fluid.makeArray(e))[t(e)];
    }, flock.choose = function(e, t) {
        return flock.isIterable(e) ? flock.arrayChoose(e, t) : e[flock.arrayChoose(e.keys, t)];
    }, flock.shuffle = function(e) {
        for (var t = e.length - 1; 0 < t; t -= 1) {
            var n = Math.floor(Math.random() * (t + 1)), r = e[t];
            e[t] = e[n], e[n] = r;
        }
        return e;
    }, flock.normalize = function(e, t, n) {
        n = n || e;
        var r, o, a, i = 0;
        for (t = void 0 === t ? 1 : t, r = 0; r < e.length; r++) i < (o = Math.abs(e[r])) && (i = o);
        if (0 < i) for (r = 0; r < e.length; r++) a = e[r], n[r] = a / i * t;
        return n;
    }, flock.generateFourierTable = function(e, a, i, u, l) {
        return u *= flock.TWOPI, flock.generateBuffer(e, function(e) {
            var t, n, r, o = 0;
            for (t = 0; t < i; t++) n = l ? l[t] : 1, r = (t + 1) * (e * a), o += n * Math.cos(r + u);
            return o;
        });
    }, flock.generateNormalizedFourierTable = function(e, t, n, r, o) {
        var a = flock.generateBuffer(n, function(e) {
            return o(e + 1);
        }), i = flock.generateFourierTable(e, t, n, r, a);
        return flock.normalize(i);
    }, flock.fillTable = function(e, t) {
        var n = "number" == typeof e ? e : e.length;
        return t(e, flock.TWOPI / n);
    }, flock.tableGenerators = {
        sin: function(e, t) {
            return flock.generateBuffer(e, function(e) {
                return Math.sin(e * t);
            });
        },
        tri: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 1e3, 1, function(e) {
                return e % 2 == 0 ? 0 : 1 / (e * e);
            });
        },
        saw: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                return 1 / e;
            });
        },
        square: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                return e % 2 == 0 ? 0 : 1 / e;
            });
        },
        hann: function(n) {
            return flock.generateBuffer(n, function(e) {
                var t = Math.sin(Math.PI * e / n);
                return t * t;
            });
        },
        sinWindow: function(t) {
            return flock.generateBuffer(t, function(e) {
                return Math.sin(Math.PI * e / t);
            });
        }
    }, flock.range = function(e) {
        var t, n, r = {
            max: Number.NEGATIVE_INFINITY,
            min: 1 / 0
        };
        for (t = 0; t < e.length; t++) (n = e[t]) > r.max && (r.max = n), n < r.min && (r.min = n);
        return r;
    }, flock.scale = function(e) {
        if (e) {
            var t, n = flock.range(e), r = (n.max - n.min) / 2, o = (n.max + n.min) / 2;
            for (t = 0; t < e.length; t++) e[t] = (e[t] - o) / r;
            return e;
        }
    }, flock.copyBuffer = function(e, t, n) {
        void 0 === n && (n = e.length);
        var r, o, a = new Float32Array(n - t);
        for (r = t, o = 0; r < n; r++, o++) a[o] = e[r];
        return a;
    }, flock.copyToBuffer = function(e, t) {
        for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) t[r] = e[r];
    }, flock.parseMidiString = function(e) {
        if (!e || e.length < 2) return NaN;
        var t = (e = e.toLowerCase()).charAt(1), n = "#" === t || "b" === t ? 2 : 1, r = e.substring(0, n);
        return 12 * Number(e.substring(n)) + flock.midiFreq.noteNames[r];
    }, flock.midiFreq = function(e, t, n, r) {
        return t = void 0 === t ? 440 : t, n = void 0 === n ? 69 : n, r = r || 12, "string" == typeof e && (e = flock.parseMidiString(e)), 
        t * Math.pow(2, 1 * (e - n) / r);
    }, flock.midiFreq.noteNames = {
        "b#": 0,
        c: 0,
        "c#": 1,
        db: 1,
        d: 2,
        "d#": 3,
        eb: 3,
        e: 4,
        "e#": 5,
        f: 5,
        "f#": 6,
        gb: 6,
        g: 7,
        "g#": 8,
        ab: 8,
        a: 9,
        "a#": 10,
        bb: 10,
        b: 11,
        cb: 11
    }, flock.interpolate = {
        none: function(e, t) {
            return t[0 | (e %= t.length)];
        },
        linear: function(e, t) {
            var n = t.length, r = 0 | (e %= n), o = (r + 1) % n, a = e - r, i = t[r];
            return i + a * (t[o] - i);
        },
        hermite: function(e, t) {
            var n = t.length, r = Math.floor(e), o = r % n, a = e - r, i = (o + 1) % n, u = (o + 2) % n, l = t[0 < o ? o - 1 : n - 1], s = t[o], c = t[i], f = .5 * (c - l), d = s - c, p = f + d, m = p + d + .5 * (t[u] - s);
            return ((m * a - (p + m)) * a + f) * a + s;
        }
    }, flock.interpolate.cubic = flock.interpolate.hermite, flock.log = {
        fail: function(e) {
            fluid.log(fluid.logLevel.FAIL, e);
        },
        warn: function(e) {
            fluid.log(fluid.logLevel.WARN, e);
        },
        debug: function(e) {
            fluid.log(fluid.logLevel.INFO, e);
        }
    }, flock.fail = function(e) {
        if (flock.debug.failHard) throw e = e instanceof Error ? e : new Error(e);
        flock.log.fail(e);
    }, flock.pathParseError = function(e, t, n) {
        var r = "Error parsing path '" + t + "'. Segment '" + n + "' could not be resolved.";
        flock.fail(r);
    }, flock.get = function(e, t) {
        if (!e) return fluid.getGlobalValue(t);
        if (1 === arguments.length && "string" == typeof e) return fluid.getGlobalValue(e);
        if (t && "" !== t) {
            var n, r = "" === t ? [] : String(t).split("."), o = e[r[0]];
            for (n = 1; n < r.length; n++) {
                if (null == o) return void flock.pathParseError(e, t, r[n - 1]);
                o = o[r[n]];
            }
            return o;
        }
    }, flock.set = function(e, t, n) {
        if (e && t && "" !== t) {
            var r, o = String(t).split("."), a = o.length, i = o[0];
            for (r = 1; r < a; r++) {
                if ("object" !== typeof (e = e[i])) return void flock.fail("Error while setting a value at path '" + t + "'. A non-container object was found at segment '" + i + "'. Value: " + e);
                void 0 === e[i = o[r]] && (e[i] = {});
            }
            return e[i] = n;
        }
    }, flock.invoke = function(e, t, n) {
        var r = "function" == typeof e ? e : flock.get(e, t);
        if ("function" == typeof r) return r.apply(null, n);
        flock.fail("Path '" + t + "' does not resolve to a function.");
    }, flock.input = {}, flock.input.shouldExpand = function(e) {
        return flock.parse.specialInputs.indexOf(e) < 0;
    }, flock.input.pathExpander = function(e) {
        var t, n = fluid.model.parseEL(e), r = n.length - 1, o = [];
        for (t = 0; t < r; t++) {
            var a = n[t], i = n[t + 1];
            if (o.push(a), "model" === i || "options" === i) {
                o = o.concat(n.slice(t + 1, r));
                break;
            }
            isNaN(Number(i)) && o.push("inputs");
        }
        return o.push(n[r]), o.join(".");
    }, flock.input.expandPaths = function(e) {
        var t, n, r, o = {};
        for (t in e) n = flock.input.pathExpander(t), r = e[t], o[n] = r;
        return o;
    }, flock.input.expandPath = function(e) {
        return "string" == typeof e ? flock.input.pathExpander(e) : flock.input.expandPaths(e);
    }, flock.input.getValueForPath = function(e, t) {
        t = flock.input.expandPath(t);
        var n = flock.get(e, t);
        return flock.hasTag(n, "flock.ugen.valueType") ? n.inputs.value : n;
    }, flock.input.getValuesForPathArray = function(e, t) {
        var n, r, o = {};
        for (n = 0; n < t.length; n++) o[r = t[n]] = flock.input.get(e, r);
        return o;
    }, flock.input.getValuesForPathObject = function(e, t) {
        var n;
        for (n in t) t[n] = flock.input.get(e, n);
        return t;
    }, flock.input.get = function(e, t) {
        return "string" == typeof t ? flock.input.getValueForPath(e, t) : flock.isIterable(t) ? flock.input.getValuesForPathArray(e, t) : flock.input.getValuesForPathObject(e, t);
    }, flock.input.resolveValue = function(e, t, n, r, o, a, i) {
        if ("string" == typeof n) {
            var u = fluid.extractEL(n, flock.input.valueExpressionSpec);
            if (u) {
                var l = flock.input.getValueForPath(e, u);
                return void 0 === l && flock.log.debug("The value expression '" + n + "' resolved to undefined. If this isn't expected, check to ensure that your path is valid."), 
                l;
            }
        }
        return flock.input.shouldExpand(o) && i ? i(n, t, r, a) : n;
    }, flock.input.valueExpressionSpec = {
        ELstyle: "${}"
    }, flock.input.setValueForPath = function(e, t, n, r, o) {
        t = flock.input.expandPath(t);
        var a = flock.get(e, t), i = t.lastIndexOf("."), u = t.slice(i + 1), l = -1 < i ? flock.get(e, t.slice(0, t.lastIndexOf(".inputs"))) : r, s = flock.input.resolveValue(e, t, n, l, u, a, o);
        return flock.set(e, t, s), l && l.onInputChanged && l.onInputChanged(u), s;
    }, flock.input.setValuesForPaths = function(e, t, n, r) {
        var o, a, i, u = {};
        for (o in t) a = t[o], i = flock.input.set(e, o, a, n, r), u[o] = i;
        return u;
    }, flock.input.set = function(e, t, n, r, o) {
        return "string" == typeof t ? flock.input.setValueForPath(e, t, n, r, o) : flock.input.setValuesForPaths(e, t, r, o);
    }, fluid.defaults("flock.audioSystem", {
        gradeNames: [ "fluid.modelComponent" ],
        channelRange: {
            min: 1,
            max: 32
        },
        outputBusRange: {
            min: 2,
            max: 1024
        },
        inputBusRange: {
            min: 1,
            max: 32
        },
        model: {
            rates: {
                audio: 44100,
                control: 689.0625,
                scheduled: 0,
                demand: 0,
                constant: 0
            },
            blockSize: 64,
            numBlocks: 16,
            chans: 2,
            numInputBuses: 2,
            numBuses: 8,
            bufferSize: "@expand:flock.audioSystem.defaultBufferSize()"
        },
        modelRelay: [ {
            target: "rates.control",
            singleTransform: {
                type: "fluid.transforms.binaryOp",
                left: "{that}.model.rates.audio",
                operator: "/",
                right: "{that}.model.blockSize"
            }
        }, {
            target: "numBlocks",
            singleTransform: {
                type: "fluid.transforms.binaryOp",
                left: "{that}.model.bufferSize",
                operator: "/",
                right: "{that}.model.blockSize"
            }
        }, {
            target: "chans",
            singleTransform: {
                type: "fluid.transforms.limitRange",
                input: "{that}.model.chans",
                min: "{that}.options.channelRange.min",
                max: "{that}.options.channelRange.max"
            }
        }, {
            target: "numInputBuses",
            singleTransform: {
                type: "fluid.transforms.limitRange",
                input: "{that}.model.numInputBuses",
                min: "{that}.options.inputBusRange.min",
                max: "{that}.options.inputBusRange.max"
            }
        }, {
            target: "numBuses",
            singleTransform: {
                type: "fluid.transforms.free",
                func: "flock.audioSystem.clampNumBuses",
                args: [ "{that}.model.numBuses", "{that}.options.outputBusRange", "{that}.model.chans" ]
            }
        } ]
    }), flock.audioSystem.clampNumBuses = function(e, t, n) {
        return e = Math.max(e, Math.max(n, t.min)), e = Math.min(e, t.max);
    }, flock.audioSystem.defaultBufferSize = function() {
        return flock.platform.isMobile ? 8192 : flock.platform.browser.mozilla ? 2048 : 1024;
    }, fluid.defaults("flock.busManager", {
        gradeNames: [ "fluid.modelComponent" ],
        model: {
            nextAvailableBus: {
                input: 0,
                interconnect: 0
            }
        },
        members: {
            buses: {
                expander: {
                    funcName: "flock.enviro.createAudioBuffers",
                    args: [ "{audioSystem}.model.numBuses", "{audioSystem}.model.blockSize" ]
                }
            }
        },
        invokers: {
            acquireNextBus: {
                funcName: "flock.busManager.acquireNextBus",
                args: [ "{arguments}.0", "{that}.buses", "{that}.applier", "{that}.model", "{audioSystem}.model.chans", "{audioSystem}.model.numInputBuses" ]
            },
            reset: {
                changePath: "nextAvailableBus",
                value: {
                    input: 0,
                    interconnect: 0
                }
            }
        },
        listeners: {
            "onDestroy.reset": "{that}.reset()"
        }
    }), flock.busManager.acquireNextBus = function(e, t, n, r, o, a) {
        var i = r.nextAvailableBus[e];
        if (void 0 !== i) {
            var u = i + o, l = o + a;
            if ("interconnect" === e && (u += a, l = t.length), !(l <= u)) return n.change("nextAvailableBus." + e, ++i), 
            u;
            flock.fail("Unable to aquire a bus. There are insufficient buses available. Please use an existing bus or configure additional buses using the enviroment's numBuses and numInputBuses parameters.");
        } else flock.fail("An invalid bus type was specified when invoking flock.busManager.acquireNextBus(). Type was: " + e);
    }, fluid.defaults("flock.outputManager", {
        gradeNames: [ "fluid.modelComponent" ],
        model: {
            audioSettings: "{audioSystem}.model"
        },
        invokers: {
            start: "{that}.events.onStart.fire()",
            stop: "{that}.events.onStop.fire()",
            reset: "{that}.events.onReset.fire"
        },
        events: {
            onStart: "{enviro}.events.onStart",
            onStop: "{enviro}.events.onStop",
            onReset: "{enviro}.events.onReset"
        }
    }), fluid.defaults("flock.nodeListComponent", {
        gradeNames: "fluid.component",
        members: {
            nodeList: "@expand:flock.nodeList()"
        },
        invokers: {
            insert: "flock.nodeList.insert({that}.nodeList, {arguments}.0, {arguments}.1)",
            head: "flock.nodeList.head({that}.nodeList, {arguments}.0)",
            tail: "flock.nodeList.tail({that}.nodeList, {arguments}.0)",
            before: "flock.nodeList.before({that}.nodeList, {arguments}.0, {arguments}.1)",
            after: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)",
            remove: "flock.nodeList.remove({that}.nodeList, {arguments}.0)",
            replace: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)"
        }
    }), fluid.defaults("flock.enviro", {
        gradeNames: [ "fluid.modelComponent", "flock.nodeListComponent", "fluid.resolveRootSingle" ],
        singleRootType: "flock.enviro",
        isGlobalSingleton: !0,
        members: {
            buffers: {},
            bufferSources: {}
        },
        components: {
            asyncScheduler: {
                type: "flock.scheduler.async"
            },
            audioSystem: {
                type: "flock.audioSystem"
            },
            busManager: {
                type: "flock.busManager"
            }
        },
        model: {
            isPlaying: !1
        },
        invokers: {
            gen: {
                funcName: "flock.enviro.gen",
                args: [ "{busManager}.buses", "{audioSystem}.model", "{that}.nodeList.nodes" ]
            },
            start: "flock.enviro.start({that}.model, {that}.events.onStart.fire)",
            play: "{that}.start",
            stop: "flock.enviro.stop({that}.model, {that}.events.onStop.fire)",
            reset: "{that}.events.onReset.fire()",
            registerBuffer: "flock.enviro.registerBuffer({arguments}.0, {that}.buffers)",
            releaseBuffer: "flock.enviro.releaseBuffer({arguments}.0, {that}.buffers)",
            saveBuffer: {
                funcName: "flock.enviro.saveBuffer",
                args: [ "{arguments}.0", "{that}.buffers", "{audioSystem}" ]
            }
        },
        events: {
            onStart: null,
            onPlay: "{that}.events.onStart",
            onStop: null,
            onReset: null
        },
        listeners: {
            onCreate: [ "flock.enviro.registerGlobalSingleton({that})" ],
            onStart: [ "{that}.applier.change(isPlaying, true)" ],
            onStop: [ "{that}.applier.change(isPlaying, false)" ],
            onReset: [ "{that}.stop()", "{asyncScheduler}.clearAll()", "flock.nodeList.clearAll({that}.nodeList)", "{busManager}.reset()", "fluid.clear({that}.buffers)" ]
        }
    }), flock.enviro.registerGlobalSingleton = function(e) {
        e.options.isGlobalSingleton && (flock.environment = flock.enviro.shared = e);
    }, flock.enviro.registerBuffer = function(e, t) {
        e.id && (t[e.id] = e);
    }, flock.enviro.releaseBuffer = function(e, t) {
        e && delete t["string" == typeof e ? e : e.id];
    }, flock.enviro.saveBuffer = function(e, t, n) {
        if ("string" == typeof e && (e = {
            buffer: e
        }), "string" == typeof e.buffer) {
            var r = e.buffer;
            e.buffer = t[r], e.buffer.id = r;
        }
        return e.type = e.type || "wav", e.path = e.path || e.buffer.id + "." + e.type, 
        e.format = e.format || "int16", n.bufferWriter.save(e, e.buffer);
    }, flock.enviro.gen = function(e, t, n) {
        flock.evaluate.clearBuses(e, t.numBuses, t.blockSize), flock.evaluate.synths(n);
    }, flock.enviro.start = function(e, t) {
        e.isPlaying || t();
    }, flock.enviro.stop = function(e, t) {
        e.isPlaying && t();
    }, flock.enviro.createAudioBuffers = function(e, t) {
        var n, r = [];
        for (n = 0; n < e; n++) r[n] = new Float32Array(t);
        return r;
    }, fluid.defaults("flock.autoEnviro", {
        gradeNames: [ "fluid.component" ],
        members: {
            enviro: "@expand:flock.autoEnviro.initEnvironment()"
        }
    }), flock.autoEnviro.initEnvironment = function() {
        return flock.environment ? flock.environment : flock.init();
    }, fluid.defaults("flock.silentEnviro", {
        gradeNames: "flock.enviro",
        listeners: {
            onCreate: [ "flock.silentEnviro.insertOutputGainNode({that})" ]
        }
    }), flock.silentEnviro.insertOutputGainNode = function(e) {
        e.audioSystem.nativeNodeManager && e.audioSystem.nativeNodeManager.createOutputNode({
            node: "Gain",
            params: {
                gain: 0
            }
        });
    }, fluid.defaults("flock.node", {
        gradeNames: [ "flock.autoEnviro", "fluid.modelComponent" ],
        addToEnvironment: "tail",
        model: {},
        components: {
            enviro: "{flock.enviro}"
        },
        invokers: {
            play: {
                funcName: "flock.node.play",
                args: [ "{that}", "{that}.enviro", "{that}.addToEnvironment" ]
            },
            pause: "{that}.removeFromEnvironment()",
            addToEnvironment: {
                funcName: "flock.node.addToEnvironment",
                args: [ "{that}", "{arguments}.0", "{that}.enviro.nodeList" ]
            },
            removeFromEnvironment: {
                funcName: "flock.node.removeFromEnvironment",
                args: [ "{that}", "{that}.enviro.nodeList" ]
            },
            isPlaying: {
                funcName: "flock.nodeList.isNodeActive",
                args: [ "{that}.enviro.nodeList", "{that}" ]
            }
        },
        listeners: {
            onCreate: [ "{that}.addToEnvironment({that}.options.addToEnvironment)" ],
            onDestroy: [ "{that}.removeFromEnvironment()" ]
        }
    }), flock.node.addToEnvironment = function(e, t, n) {
        if (void 0 === t && (t = e.options.addToEnvironment), null != t && !1 !== t) {
            var r = typeof t;
            "string" === r && "head" === t || "tail" === t ? flock.nodeList[t](n, e) : "number" === r ? flock.nodeList.insert(n, e, t) : flock.nodeList.tail(n, e);
        }
    }, flock.node.removeFromEnvironment = function(e, t) {
        flock.nodeList.remove(t, e);
    }, flock.node.play = function(e, t, n) {
        -1 === t.nodeList.nodes.indexOf(e) && n(e.options.addToEnvironment || "tail");
        t.model.isPlaying || t.play();
    }, fluid.defaults("flock.noteTarget", {
        gradeNames: "fluid.component",
        noteChanges: {
            on: {
                "env.gate": 1
            },
            off: {
                "env.gate": 0
            }
        },
        invokers: {
            set: {
                funcName: "fluid.notImplemented"
            },
            noteOn: {
                func: "{that}.events.noteOn.fire"
            },
            noteOff: {
                func: "{that}.events.noteOff.fire"
            },
            noteChange: {
                funcName: "flock.noteTarget.change",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            }
        },
        events: {
            noteOn: null,
            noteOff: null
        },
        listeners: {
            "noteOn.handleChange": [ "{that}.noteChange(on, {arguments}.0)" ],
            "noteOff.handleChange": [ "{that}.noteChange(off, {arguments}.0)" ]
        }
    }), flock.noteTarget.change = function(e, t, n) {
        var r = e.options.noteChanges[t], o = a.extend({}, r, n);
        e.set(o);
    }, fluid.defaults("flock.synth", {
        gradeNames: [ "flock.node", "flock.noteTarget" ],
        rate: flock.rates.AUDIO,
        addToEnvironment: !0,
        mergePolicy: {
            ugens: "nomerge"
        },
        ugens: {
            expander: {
                funcName: "flock.makeUGens",
                args: [ "{that}.options.synthDef", "{that}.rate", "{that}.nodeList", "{that}.enviro", "{that}.audioSettings" ]
            }
        },
        members: {
            rate: "{that}.options.rate",
            audioSettings: "{that}.enviro.audioSystem.model",
            nodeList: "@expand:flock.nodeList()",
            out: "{that}.options.ugens",
            genFn: "@expand:fluid.getGlobalValue(flock.evaluate.ugens)"
        },
        model: {
            blockSize: "@expand:flock.synth.calcBlockSize({that}.rate, {that}.enviro.audioSystem.model)"
        },
        invokers: {
            set: {
                funcName: "flock.synth.set",
                args: [ "{that}", "{that}.nodeList.namedNodes", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            get: {
                funcName: "flock.input.get",
                args: [ "{that}.nodeList.namedNodes", "{arguments}.0" ]
            },
            input: {
                funcName: "flock.synth.input",
                args: [ "{arguments}", "{that}.get", "{that}.set" ]
            }
        }
    }), flock.synth.createUGenTree = function(e, t, n) {
        return new flock.UGenTree(e, t, n);
    }, flock.synth.calcBlockSize = function(e, t) {
        return e === flock.rates.AUDIO ? t.blockSize : 1;
    }, flock.synth.set = function(o, e, t, n, a) {
        return flock.input.set(e, t, n, void 0, function(e, t, n, r) {
            return flock.synth.ugenValueParser(o, e, r, a);
        });
    }, flock.synth.input = function(e, t, n) {
        var r = e[0];
        return r ? "string" == typeof r ? e.length < 2 ? t(r) : n.apply(null, e) : flock.isIterable(r) ? t(r) : n.apply(null, e) : void 0;
    }, flock.synth.ugenValueParser = function(e, t, n, r) {
        if (null == t) return n;
        var o, a, i, u = flock.parse.ugenDef(t, e.enviro, {
            audioSettings: e.audioSettings,
            buses: e.enviro.busManager.buses,
            buffers: e.enviro.buffers
        }), l = flock.isIterable(u) ? u : void 0 !== u ? [ u ] : [], s = flock.isIterable(n) ? n : void 0 !== n ? [ n ] : [], c = Math.min(l.length, s.length), f = r ? "swapTree" : "replaceTree";
        for (o = 0; o < c; o++) a = flock.ugenNodeList[f](e.nodeList, l[o], s[o]);
        for (i = o; i < l.length; i++) a++, flock.ugenNodeList.insertTree(e.nodeList, l[i], a);
        for (i = o; i < s.length; i++) flock.ugenNodeList.removeTree(e.nodeList, s[i]);
        return u;
    }, fluid.defaults("flock.synth.value", {
        gradeNames: [ "flock.synth" ],
        rate: "demand",
        addToEnvironment: !1,
        invokers: {
            value: {
                funcName: "flock.evaluate.synthValue",
                args: [ "{that}" ]
            }
        }
    }), fluid.defaults("flock.synth.frameRate", {
        gradeNames: [ "flock.synth.value" ],
        rate: "scheduled",
        fps: 60,
        members: {
            audioSettings: {
                rates: {
                    scheduled: "{that}.options.fps"
                }
            }
        }
    }), flock.bufferDesc = function() {
        throw new Error("flock.bufferDesc is not defined. Did you forget to include the buffers.js file?");
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.nodeList = function() {
        return {
            nodes: [],
            namedNodes: {}
        };
    }, flock.nodeList.insert = function(e, t, n) {
        return n < 0 && (n = 0), e.nodes.splice(n, 0, t), flock.nodeList.registerNode(e, t), 
        n;
    }, flock.nodeList.registerNode = function(e, t) {
        var n = t.name || t.id;
        n && (e.namedNodes[n] = t);
    }, flock.nodeList.head = function(e, t) {
        return flock.nodeList.insert(e, t, 0);
    }, flock.nodeList.before = function(e, t, n) {
        var r = e.nodes.indexOf(n);
        return flock.nodeList.insert(e, t, r);
    }, flock.nodeList.after = function(e, t, n) {
        var r = e.nodes.indexOf(n) + 1;
        return flock.nodeList.insert(e, t, r);
    }, flock.nodeList.tail = function(e, t) {
        var n = e.nodes.length;
        return flock.nodeList.insert(e, t, n);
    }, flock.nodeList.unregisterNode = function(e, t) {
        var n = t.name || t.id;
        n && delete e.namedNodes[n];
    }, flock.nodeList.isNodeActive = function(e, t) {
        return -1 < e.nodes.indexOf(t);
    }, flock.nodeList.remove = function(e, t) {
        if (e) {
            var n = e.nodes.indexOf(t);
            return -1 < n && (e.nodes.splice(n, 1), flock.nodeList.unregisterNode(e, t)), n;
        }
    }, flock.nodeList.replace = function(e, t, n) {
        var r = e.nodes.indexOf(n);
        return r < 0 ? flock.nodeList.tail(e, t) : (e.nodes[r] = t, flock.nodeList.unregisterNode(e, n), 
        flock.nodeList.registerNode(e, t), r);
    }, flock.nodeList.clearAll = function(e) {
        for (var t in e.nodes.length = 0, e.namedNodes) delete e.namedNodes[t];
    }, flock.ugenNodeList = function() {
        return flock.nodeList();
    }, flock.ugenNodeList.insertTree = function(e, t, n) {
        var r, o, a = t.inputs;
        for (r in a) o = a[r], flock.isUGen(o) && (n = flock.ugenNodeList.insertTree(e, o, n), 
        n++);
        return flock.nodeList.insert(e, t, n);
    }, flock.ugenNodeList.removeTree = function(e, t) {
        var n, r, o = t.inputs;
        for (n in o) r = o[n], flock.isUGen(r) && flock.ugenNodeList.removeTree(e, r);
        return flock.nodeList.remove(e, t);
    }, flock.ugenNodeList.tailTree = function(e, t) {
        var n = e.nodes.length;
        return flock.ugenNodeList.insertTree(e, t, n);
    }, flock.ugenNodeList.replaceTree = function(e, t, n) {
        if (!n) return flock.ugenNodeList.tailTree(e, t);
        var r = flock.ugenNodeList.removeTree(e, n);
        return flock.ugenNodeList.insertTree(e, t, r), r;
    }, flock.ugenNodeList.swapTree = function(e, t, n, r) {
        return r ? (flock.ugenNodeList.reattachInputs(e, t, n, r), flock.ugenNodeList.replaceInputs(e, t, n, r)) : t.inputs = n.inputs, 
        flock.nodeList.replace(e, t, n);
    }, flock.ugenNodeList.reattachInputs = function(e, t, n, r) {
        for (var o in n.inputs) r.indexOf(o) < 0 ? flock.ugenNodeList.removeTree(e, n.inputs[o]) : t.inputs[o] = n.inputs[o];
    }, flock.ugenNodeList.replaceInputs = function(e, t, n, r) {
        for (var o in t.inputs) r.indexOf(o) < 0 && flock.ugenNodeList.replaceTree(e, t.inputs[o], n.inputs[o]);
    }, flock.makeUGens = function(e, t, n, r, o) {
        e || fluid.log(fluid.logLevel.IMPORTANT, "Warning: An empy synthDef was found while instantiating a unit generator tree.Did you forget to include a 'synthDef' option for your Synth?");
        var a = t === flock.rates.SCHEDULED || t === flock.rates.DEMAND;
        return flock.parse.synthDef(e, r, {
            rate: t,
            overrideRate: a,
            visitors: [ flock.makeUGens.visitor(n) ],
            buffers: r.buffers,
            buses: r.busManager.buses,
            audioSettings: o || r.audioSystem.model
        });
    }, flock.makeUGens.visitor = function(t) {
        return function(e) {
            flock.nodeList.tail(t, e);
        };
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.evaluate = {
        synth: function(e) {
            e.genFn(e.nodeList.nodes), e.out && (e.model.value = e.out.model.value);
        },
        synthValue: function(e) {
            return flock.evaluate.synth(e), e.model.value;
        },
        synths: function(e) {
            for (var t = 0; t < e.length; t++) flock.evaluate.synth(e[t]);
        },
        clearBuses: function(e, t, n) {
            for (var r = 0; r < t; r++) for (var o = e[r], a = 0; a < n; a++) o[a] = 0;
        },
        ugens: function(e) {
            for (var t, n = 0; n < e.length; n++) void 0 !== (t = e[n]).gen && t.gen(t.model.blockSize);
        }
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.modelSynth", {
        gradeNames: "flock.synth",
        model: {
            inputs: {}
        },
        modelListeners: {
            inputs: [ {
                funcName: "flock.modelSynth.updateUGens",
                args: [ "{that}.set", "{that}.options.ugens", "{change}" ]
            } ]
        },
        invokers: {
            value: "{that}.events.onEvaluate.fire()"
        },
        events: {
            onEvaluate: null
        },
        listeners: {
            onEvaluate: [ "{that}.genFn({that}.nodeList.nodes)", {
                changePath: "value",
                value: "{that}.out.model.value"
            } ]
        }
    }), flock.modelSynth.updateUGens = function(e, t, n) {
        var r = {};
        flock.modelSynth.flattenModel("", n.value, r), e(r);
    }, flock.modelSynth.shouldFlattenValue = function(e) {
        return fluid.isPrimitive(e) || flock.isIterable(e) || e.ugen;
    }, flock.modelSynth.flattenModel = function(e, t, n) {
        for (var r in t) {
            var o = t[r], a = fluid.pathUtil.composePath(e, r.toString());
            flock.modelSynth.shouldFlattenValue(o) ? n[a] = o : flock.modelSynth.flattenModel(a, o, n);
        }
        return n;
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.synth.group", {
        gradeNames: [ "flock.node", "flock.noteTarget" ],
        methodEventMap: {
            onSet: "set"
        },
        members: {
            nodeList: "@expand:flock.nodeList()",
            genFn: "@expand:fluid.getGlobalValue(flock.evaluate.synths)"
        },
        invokers: {
            play: "{that}.events.onPlay.fire",
            pause: "{that}.events.onPause.fire",
            set: "{that}.events.onSet.fire",
            get: "flock.synth.group.get({arguments}, {that}.nodeList.nodes)",
            head: "flock.synth.group.head({arguments}.0, {that})",
            tail: "flock.synth.group.tail({arguments}.0, {that})",
            insert: "flock.synth.group.insert({arguments}.0, {arguments}.1, {that})",
            before: "flock.synth.group.before({arguments}.0, {arguments}.1, {that})",
            after: "flock.synth.group.after({arguments}.0, {arguments}.1, {that})",
            remove: "{that}.events.onRemove.fire",
            input: {
                funcName: "flock.synth.group.input",
                args: [ "{arguments}", "{that}.get", "{that}.events.onSet.fire" ]
            }
        },
        events: {
            onSet: null,
            onGen: null,
            onPlay: null,
            onPause: null,
            onInsert: null,
            onRemove: null
        },
        listeners: {
            onInsert: [ {
                funcName: "flock.synth.group.bindMethods",
                args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "addListener" ]
            }, "flock.synth.group.removeNodeFromEnvironment({arguments}.0)" ],
            onRemove: [ {
                funcName: "flock.synth.group.bindMethods",
                args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "removeListener" ]
            }, {
                this: "{that}.nodeList",
                method: "remove",
                args: [ "{arguments}.0" ]
            } ]
        }
    }), flock.synth.group.head = function(e, t) {
        flock.nodeList.head(t.nodeList, e), t.events.onInsert.fire(e);
    }, flock.synth.group.tail = function(e, t) {
        flock.nodeList.tail(t.nodeList, e), t.events.onInsert.fire(e);
    }, flock.synth.group.insert = function(e, t, n) {
        flock.nodeList.insert(n.nodeList, e, t), n.events.onInsert.fire(e);
    }, flock.synth.group.before = function(e, t, n) {
        flock.nodeList.before(n.nodeList, e, t), n.events.onInsert.fire(e);
    }, flock.synth.group.after = function(e, t, n) {
        flock.nodeList.after(n.nodeList, e, t), n.events.onInsert.fire(e);
    }, flock.synth.group.removeNodeFromEnvironment = function(e) {
        e.removeFromEnvironment();
    }, flock.synth.group.get = function(e, t) {
        var n = t[t.length - 1];
        return n.get.apply(n, e);
    }, flock.synth.group.input = function(e, t, n) {
        return (1 < e.length ? n : t).apply(null, e);
    }, flock.synth.group.bindMethods = function(e, t, n, r) {
        for (var o in t) {
            var a = e[t[o]];
            (0, n[o][r])(a);
        }
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var i = fluid.registerNamespace("jQuery");
    fluid.defaults("flock.synth.polyphonic", {
        gradeNames: [ "flock.synth.group" ],
        maxVoices: 16,
        amplitudeNormalizer: "static",
        amplitudeKey: "env.sustain",
        noteSpecs: "{that}.options.noteChanges",
        distributeOptions: {
            source: "{that}.options.voiceAllocatorOptions",
            target: "{that flock.synth.voiceAllocator}.options",
            removeSource: !0
        },
        voiceAllocatorOptions: {
            synthDef: "{polyphonic}.options.synthDef",
            maxVoices: "{polyphonic}.options.maxVoices",
            amplitudeNormalizer: "{polyphonic}.options.amplitudeNormalizer",
            amplitudeKey: "{polyphonic}.options.amplitudeKey",
            listeners: {
                onCreateVoice: {
                    funcName: "flock.nodeList.tail",
                    args: [ "{polyphonic}.nodeList", "{arguments}.0" ]
                }
            }
        },
        components: {
            voiceAllocator: {
                type: "flock.synth.voiceAllocator.lazy"
            }
        },
        invokers: {
            noteChange: {
                funcName: "flock.synth.polyphonic.noteChange",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            createVoice: {
                func: "{voiceAllocator}.createVoice",
                args: [ "{that}.options", "{that}.insert" ]
            }
        },
        listeners: {
            "noteOn.handleChange": [ {
                funcName: "flock.synth.polyphonic.noteOn",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            } ],
            "noteOff.handleChange": [ {
                funcName: "flock.synth.polyphonic.noteOff",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            } ]
        }
    }), flock.synth.polyphonic.noteChange = function(e, t, n, r) {
        var o = e.options.noteChanges[t], a = i.extend({}, o, r);
        n.set(a);
    }, flock.synth.polyphonic.noteOn = function(e, t, n) {
        var r = e.voiceAllocator.getFreeVoice();
        return e.voiceAllocator.activeVoices[t] && e.noteOff(t), e.voiceAllocator.activeVoices[t] = r, 
        e.noteChange("on", r, n), r;
    }, flock.synth.polyphonic.noteOff = function(e, t, n) {
        var r = e.voiceAllocator.activeVoices[t];
        return r ? (e.noteChange("off", r, n), delete e.voiceAllocator.activeVoices[t], 
        e.voiceAllocator.freeVoices.push(r), r) : null;
    }, fluid.defaults("flock.synth.voiceAllocator", {
        gradeNames: [ "fluid.component" ],
        maxVoices: 16,
        amplitudeNormalizer: "static",
        amplitudeKey: "env.sustain",
        members: {
            activeVoices: {},
            freeVoices: []
        },
        invokers: {
            createVoice: {
                funcName: "flock.synth.voiceAllocator.createVoice",
                args: [ "{that}.options", "{that}.events.onCreateVoice.fire" ]
            }
        },
        events: {
            onCreateVoice: null
        }
    }), flock.synth.voiceAllocator.createVoice = function(e, t) {
        var n, r = flock.synth({
            synthDef: e.synthDef,
            addToEnvironment: !1
        }), o = e.amplitudeNormalizer, a = e.amplitudeKey;
        return o && ("function" == typeof o ? o(r, a) : "static" === o && (n = 1 / e.maxVoices, 
        r.input(a, n))), t(r), r;
    }, fluid.defaults("flock.synth.voiceAllocator.lazy", {
        gradeNames: [ "flock.synth.voiceAllocator" ],
        invokers: {
            getFreeVoice: {
                funcName: "flock.synth.voiceAllocator.lazy.get",
                args: [ "{that}.freeVoices", "{that}.activeVoices", "{that}.createVoice", "{that}.options.maxVoices" ]
            }
        }
    }), flock.synth.voiceAllocator.lazy.get = function(e, t, n, r) {
        return 1 < e.length ? e.pop() : Object.keys(t).length > r ? null : n();
    }, fluid.defaults("flock.synth.voiceAllocator.pool", {
        gradeNames: [ "flock.synth.voiceAllocator" ],
        invokers: {
            getFreeVoice: "flock.synth.voiceAllocator.pool.get({that}.freeVoices)"
        }
    }), flock.synth.voiceAllocator.pool.get = function(e) {
        if (0 < e.length) return e.pop();
    }, flock.synth.voiceAllocator.pool.allocateVoices = function(e, t, n) {
        for (var r = 0; r < n; r++) e[r] = t();
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.band", {
        gradeNames: [ "fluid.component" ],
        synthGrade: "flock.noteTarget",
        invokers: {
            play: {
                func: "{that}.events.onPlay.fire"
            },
            pause: {
                func: "{that}.events.onPause.fire"
            },
            set: {
                func: "{that}.events.onSet.fire"
            },
            getSynths: {
                funcName: "fluid.queryIoCSelector",
                args: [ "{that}", "{that}.options.synthGrade" ]
            }
        },
        events: {
            onPlay: null,
            onPause: null,
            onSet: null
        },
        distributeOptions: [ {
            source: "{that}.options.synthListeners",
            removeSource: !0,
            target: "{that flock.synth}.options.listeners"
        } ],
        synthListeners: {
            "{band}.events.onPlay": {
                func: "{that}.play"
            },
            "{band}.events.onPause": {
                func: "{that}.pause"
            },
            "{band}.events.onSet": {
                func: "{that}.set"
            }
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    function e() {
        var o = [], r = {
            state: "pending",
            value: void 0,
            resolve: function(e) {
                t("resolve", e), r.state = "fulfilled";
            },
            reject: function(e) {
                t("reject", e), r.state = "rejected";
            },
            then: function(e, t) {
                o ? o.push({
                    resolve: e,
                    reject: t
                }) : ("fulfilled" === r.state ? e : t)(r.value);
                return this;
            },
            safe: {
                then: function(e, t) {
                    return r.then(e, t), this;
                }
            }
        };
        function t(e, n) {
            r.value = n, r.then = "reject" === e ? function(e, t) {
                return t(n), this;
            } : function(e) {
                return e(n), this;
            }, r.resolve = r.reject = function() {
                throw new Error("Promise already completed");
            }, function(e, t) {
                var n, r;
                for (n = 0; n < o.length; n++) (r = o[n])[e] && r[e](t);
                o = null;
            }(e, n);
        }
        return r;
    }
    fluid.defaults("flock.promise", {
        gradeNames: [ "fluid.component" ],
        members: {
            promise: {
                expander: {
                    funcName: "flock.promise.make"
                }
            }
        }
    }), flock.promise.make = function() {
        return new e();
    }, flock.bufferDesc = function(e, t, n) {
        return (flock.platform.isWebAudio && e instanceof AudioBuffer ? flock.bufferDesc.fromAudioBuffer : flock.isIterable(e) ? flock.bufferDesc.fromChannelArray : flock.bufferDesc.expand)(e, t, n);
    }, flock.bufferDesc.inferFormat = function(e, t, n) {
        var r = e.format, o = e.data;
        return r.sampleRate = t || r.sampleRate || 44100, r.numChannels = n || r.numChannels || e.data.channels.length, 
        r.numSampleFrames = r.numSampleFrames || 0 < o.channels.length ? o.channels[0].length : 0, 
        r.duration = r.numSampleFrames / r.sampleRate, e;
    }, flock.bufferDesc.fromChannelArray = function(e, t, n) {
        e instanceof Float32Array && (e = [ e ]);
        var r = {
            container: {},
            format: {
                numChannels: n,
                sampleRate: t,
                numSampleFrames: e[0].length
            },
            data: {
                channels: e
            }
        };
        return flock.bufferDesc.inferFormat(r, t, n);
    }, flock.bufferDesc.expand = function(e, t, n) {
        if ((e = e || {
            data: {
                channels: []
            }
        }).container = e.container || {}, e.format = e.format || {}, e.format.numChannels = n || e.format.numChannels || e.data.channels.length, 
        e.data && e.data.channels && (1 === e.format.numChannels && 1 !== e.data.channels.length && (e.data.channels = [ e.data.channels ]), 
        e.format.numChannels !== e.data.channels.length)) throw new Error("The specified number of channels does not match the actual channel data. numChannels was: " + e.format.numChannels + " but the sample data contains " + e.data.channels.length + " channels.");
        return flock.bufferDesc.inferFormat(e, t, n);
    }, flock.bufferDesc.fromAudioBuffer = function(e) {
        var t, n = {
            container: {},
            format: {
                sampleRate: e.sampleRate,
                numChannels: e.numberOfChannels,
                numSampleFrames: e.length,
                duration: e.duration
            },
            data: {
                channels: []
            }
        };
        for (t = 0; t < e.numberOfChannels; t++) n.data.channels.push(e.getChannelData(t));
        return n;
    }, flock.bufferDesc.toAudioBuffer = function(e, t) {
        for (var n = e.createBuffer(t.format.numChannels, t.format.numSampleFrames, t.format.sampleRate), r = 0; r < t.format.numChannels; r++) n.copyToChannel(t.data.channels[r], r);
        return n;
    }, fluid.defaults("flock.bufferSource", {
        gradeNames: [ "fluid.modelComponent" ],
        sampleRate: "{enviro}.audioSystem.model.sampleRate",
        model: {
            state: "start",
            src: null
        },
        components: {
            bufferPromise: {
                createOnEvent: "onRefreshPromise",
                type: "flock.promise",
                options: {
                    listeners: {
                        onCreate: {
                            this: "{that}.promise",
                            method: "then",
                            args: [ "{bufferSource}.events.afterFetch.fire", "{bufferSource}.events.onError.fire" ]
                        }
                    }
                }
            }
        },
        invokers: {
            get: {
                funcName: "flock.bufferSource.get",
                args: [ "{that}", "{arguments}.0" ]
            },
            set: {
                funcName: "flock.bufferSource.set",
                args: [ "{that}", "{arguments}.0" ]
            },
            error: {
                funcName: "flock.bufferSource.error",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        listeners: {
            onCreate: {
                funcName: "{that}.events.onRefreshPromise.fire"
            },
            onRefreshPromise: {
                changePath: "state",
                value: "start"
            },
            onFetch: {
                changePath: "state",
                value: "in-progress"
            },
            afterFetch: [ {
                changePath: "state",
                value: "fetched"
            }, {
                funcName: "{that}.events.onBufferUpdated.fire",
                args: [ "{arguments}.0" ]
            } ],
            onBufferUpdated: "{enviro}.registerBuffer({arguments}.0)",
            onError: {
                changePath: "state",
                value: "error"
            }
        },
        events: {
            onRefreshPromise: null,
            onError: null,
            onFetch: null,
            afterFetch: null,
            onBufferUpdated: null
        }
    }), flock.bufferSource.get = function(t, n) {
        return "in-progress" === t.model.state || n.src === t.model.src && !n.replace || n.src && ("fetched" !== t.model.state && "errored" !== t.model.state || t.model.src === n.src && !n.replace || t.events.onRefreshPromise.fire(), 
        "start" === t.model.state && (t.model.src = n.src, t.events.onFetch.fire(n), flock.audio.decode({
            src: n.src,
            sampleRate: t.options.sampleRate,
            success: function(e) {
                n.id && (e.id = n.id), t.set(e);
            },
            error: t.error
        }))), t.bufferPromise.promise;
    }, flock.bufferSource.set = function(e, t) {
        var n = e.model.state;
        return "start" !== n && "in-progress" !== n || e.bufferPromise.promise.resolve(t), 
        e.bufferPromise.promise;
    }, flock.bufferSource.error = function(e, t) {
        return e.bufferPromise.promise.reject(t), e.bufferPromise.promise;
    }, fluid.defaults("flock.bufferLoader", {
        gradeNames: [ "fluid.component" ],
        bufferDefs: [],
        members: {
            buffers: [],
            bufferDefs: "@expand:flock.bufferLoader.expandBufferDefs({that}.options.bufferDefs)"
        },
        components: {
            enviro: "{flock.enviro}"
        },
        events: {
            afterBuffersLoaded: null,
            onError: null
        },
        listeners: {
            "onCreate.loadBuffers": {
                funcName: "flock.bufferLoader.loadBuffers",
                args: [ "{that}" ]
            },
            "onError.logError": {
                funcName: "flock.log.fail"
            }
        }
    }), flock.bufferLoader.idFromURL = function(e) {
        var t = e.lastIndexOf("/"), n = -1 < t ? t + 1 : 0, r = e.lastIndexOf("."), o = -1 < r ? r : e.length;
        return e.substring(n, o);
    }, flock.bufferLoader.idsFromURLs = function(e) {
        return fluid.transform(e, flock.bufferLoader.idFromURL);
    }, flock.bufferLoader.expandFileSequence = function(e) {
        e = e || [];
        var t, n, r, o = [];
        for (t = 0; t < e.length; t++) n = e[t], r = flock.bufferLoader.idFromURL(n), o.push({
            id: r,
            url: n
        });
        return o;
    }, flock.bufferLoader.expandBufferDef = function(e) {
        return "string" == typeof e && (e = {
            url: e
        }), void 0 === e.id && void 0 !== e.url && (e.id = flock.bufferLoader.idFromURL(e.url)), 
        e;
    }, flock.bufferLoader.expandBufferDefs = function(e) {
        return e ? (e = fluid.makeArray(e), fluid.transform(e, flock.bufferLoader.expandBufferDef)) : [];
    }, flock.bufferLoader.loadBuffer = function(e, t, n) {
        try {
            flock.parse.bufferForDef(e, t, n.enviro);
        } catch (e) {
            n.events.onError.fire(e.message);
        }
    }, flock.bufferLoader.loadBuffers = function(n) {
        var r = 1, o = {
            setBuffer: function(e) {
                if (n.buffers.push(e), n.buffers.length === n.options.bufferDefs.length) n.events.afterBuffersLoaded.fire(n.buffers); else if (r < n.bufferDefs.length) {
                    var t = n.bufferDefs[r];
                    flock.bufferLoader.loadBuffer(t, o, n), r++;
                }
            }
        };
        flock.bufferLoader.loadBuffer(n.bufferDefs[0], o, n);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var p = fluid.registerNamespace("jQuery");
    fluid.registerNamespace("flock.parse"), flock.parse.synthDef = function(e, t, n) {
        return e || (e = []), flock.parse.synthDef.hasOutUGen(e) || (e = flock.parse.synthDef.makeOutUGenDef(e, n)), 
        flock.parse.ugenForDef(e, t, n);
    }, flock.parse.synthDef.hasOutUGen = function(e) {
        return !flock.isIterable(e) && (e.id === flock.OUT_UGEN_ID || "flock.ugen.out" === e.ugen || "flock.ugen.valueOut" === e.ugen);
    }, flock.parse.synthDef.makeOutUGenDef = function(e, t) {
        return e = {
            id: flock.OUT_UGEN_ID,
            ugen: "flock.ugen.valueOut",
            inputs: {
                sources: e
            }
        }, t.rate === flock.rates.AUDIO && (e.ugen = "flock.ugen.out", e.inputs.bus = 0, 
        e.inputs.expand = t.audioSettings.chans), e;
    }, flock.parse.makeUGen = function(e, t, n, r) {
        var o, a = r.audioSettings.rates, i = r.audioSettings.blockSize;
        if (e.rate || (e.rate = flock.rates.AUDIO), !flock.hasValue(flock.rates, e.rate) && (flock.fail("An invalid rate was specified for a unit generator. ugenDef was: " + fluid.prettyPrintJSON(e)), 
        !flock.debug.failHard)) {
            var u = e.rate;
            e.rate = flock.rates.AUDIO, flock.log.warn("Overriding invalid unit generator rate. Rate is now '" + e.rate + "'; was: " + fluid.prettyPrintJSON(u));
        }
        o = e.options && void 0 !== e.options.sampleRate ? e.options.sampleRate : a[e.rate], 
        e.options = p.extend(!0, {}, e.options, {
            sampleRate: o,
            rate: e.rate,
            audioSettings: {
                rates: a,
                blockSize: i
            }
        });
        var l, s = e.rate === flock.rates.AUDIO ? i : 1;
        if (flock.hasTag(e.options, "flock.ugen.multiChannelOutput")) {
            var c = e.options.numOutputs || 1;
            l = [];
            for (var f = 0; f < c; f++) l.push(new Float32Array(s));
        } else l = new Float32Array(s);
        var d = fluid.copy(e.options);
        return d.buffers = r.buffers, d.buses = r.buses, d.enviro = n, flock.invoke(void 0, e.ugen, [ t, l, d ]);
    }, flock.parse.reservedWords = [ "id", "ugen", "rate", "inputs", "options" ], flock.parse.specialInputs = [ "value", "buffer", "list", "table", "envelope", "durations", "values" ], 
    flock.parse.expandInputs = function(e) {
        if (e.inputs) return e;
        var t, n = {};
        for (t in e) -1 === flock.parse.reservedWords.indexOf(t) && (n[t] = e[t], delete e[t]);
        return e.inputs = n, e;
    }, flock.parse.ugenDefForConstantValue = function(e) {
        return {
            ugen: "flock.ugen.value",
            rate: flock.rates.CONSTANT,
            inputs: {
                value: e
            }
        };
    }, flock.parse.expandValueDef = function(e) {
        var t = typeof e;
        if ("number" === t) return flock.parse.ugenDefForConstantValue(e);
        if ("object" === t) return e;
        throw new Error("Invalid value type found in ugen definition. UGenDef was: " + fluid.prettyPrintJSON(e));
    }, flock.parse.rateMap = {
        ar: flock.rates.AUDIO,
        kr: flock.rates.CONTROL,
        sr: flock.rates.SCHEDULED,
        dr: flock.rates.DEMAND,
        cr: flock.rates.CONSTANT
    }, flock.parse.expandRate = function(e, t) {
        return e.rate = flock.parse.rateMap[e.rate] || e.rate, t.overrideRate && e.rate !== flock.rates.CONSTANT && (e.rate = t.rate), 
        e;
    }, flock.parse.ugenDef = function(e, t, n) {
        return (flock.isIterable(e) ? flock.parse.ugensForDefs : flock.parse.ugenForDef)(e, t, n);
    }, flock.parse.ugenDef.mergeOptions = function(e) {
        var t = flock.ugenDefaults(e.ugen) || {};
        return (t = fluid.copy(t)).options = t.ugenOptions, delete t.ugenOptions, p.extend(!0, {}, t, e);
    }, flock.parse.ugensForDefs = function(e, t, n) {
        var r, o = [];
        for (r = 0; r < e.length; r++) o[r] = flock.parse.ugenForDef(e[r], t, n);
        return o;
    }, flock.parse.ugenForDef = function(e, t, n) {
        t = t || flock.environment;
        var r = n = p.extend(!0, {
            audioSettings: t.audioSystem.model,
            buses: t.busManager.buses,
            buffers: t.buffers
        }, n), o = r.visitors, a = r.audioSettings.rates;
        if (e = flock.parse.expandValueDef(e), flock.isIterable(e)) return flock.parse.ugensForDefs(e, t, n);
        e = flock.parse.expandInputs(e), flock.parse.expandRate(e, n);
        var i, u = (e = flock.parse.ugenDef.mergeOptions(e, n)).inputs, l = {};
        for (i in u) {
            var s = u[i];
            null !== s && (l[i] = flock.input.shouldExpand(i, e) ? flock.parse.ugenForDef(s, t, n) : s);
        }
        if (!e.ugen) throw new Error("Unit generator definition lacks a 'ugen' property; can't initialize the synth graph. Value: " + fluid.prettyPrintJSON(e));
        var c = flock.parse.makeUGen(e, l, t, n);
        if (e.id && (c.id = e.id), c.options.ugenDef = e, o) for (var f = 0; f < o.length; f++) o[f](c, e, a);
        return c;
    }, flock.parse.expandBufferDef = function(e) {
        return "string" == typeof e ? {
            id: e
        } : flock.isIterable(e) || e.data || e.format ? flock.bufferDesc(e) : e;
    }, flock.parse.bufferForDef = function(e, t, n) {
        (e = flock.parse.expandBufferDef(e)).data && e.data.channels ? (e = flock.bufferDesc(e), 
        flock.parse.bufferForDef.resolveBuffer(e, t, n)) : flock.parse.bufferForDef.resolveDef(e, t, n);
    }, flock.parse.bufferForDef.createBufferSource = function(e) {
        return flock.bufferSource({
            sampleRate: e.audioSystem.model.sampleRate
        });
    }, flock.parse.bufferForDef.findSource = function(e, t) {
        var n;
        return t && e.id ? (n = t.bufferSources[e.id]) || (n = flock.parse.bufferForDef.createBufferSource(t), 
        t.bufferSources[e.id] = n) : n = flock.parse.bufferForDef.createBufferSource(t), 
        n;
    }, flock.parse.bufferForDef.bindToPromise = function(e, t, n) {
        var r = function(e) {
            t.events.onBufferUpdated.addListener(r), n && n.setBuffer(e);
        };
        e.then(r, function(e) {
            throw !e && t.model.src && t.model.src.indexOf(".aif") && (e = "if this is an AIFF file, you might need to include flocking-audiofile-compatibility.js in some browsers."), 
            new Error("Error while resolving buffer " + t.model.src + ": " + e);
        });
    }, flock.parse.bufferForDef.resolveDef = function(e, t, n) {
        var r, o = flock.parse.bufferForDef.findSource(e, n);
        e.src = e.url || e.src, e.selector && "undefined" != typeof document && (e.src = document.querySelector(e.selector).files[0]), 
        r = o.get(e), flock.parse.bufferForDef.bindToPromise(r, o, t);
    }, flock.parse.bufferForDef.resolveBuffer = function(e, t, n) {
        var r = flock.parse.bufferForDef.findSource(e, n), o = r.set(e);
        flock.parse.bufferForDef.bindToPromise(o, r, t);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var c = "undefined" != typeof window ? window.atob : require("atob");
    flock.applyDeferred = function(e, t, n) {
        e && (n = void 0 === n ? 0 : n, setTimeout(function() {
            e.apply(null, t);
        }, n));
    }, fluid.registerNamespace("flock.net"), flock.net.readBufferFromUrl = function(e) {
        var t = e.src, n = new XMLHttpRequest();
        n.onreadystatechange = function() {
            if (4 === n.readyState) if (flock.net.isXHRSuccessful(n)) e.success(n.response, flock.file.parseFileExtension(t)); else {
                if (!e.error) throw new Error(n.statusText);
                e.error(n.statusText);
            }
        }, n.open(e.method || "GET", t, !0), n.responseType = e.responseType || "arraybuffer", 
        n.send(e.data);
    }, flock.net.isXHRSuccessful = function(e) {
        return 200 === e.status || 0 === e.responseURL.indexOf("file://") && 0 === e.status && e.response;
    }, fluid.registerNamespace("flock.file"), flock.file.mimeTypes = {
        "audio/wav": "wav",
        "audio/x-wav": "wav",
        "audio/wave": "wav",
        "audio/x-aiff": "aiff",
        "audio/aiff": "aiff",
        "sound/aiff": "aiff"
    }, flock.file.typeAliases = {
        aif: "aiff",
        wave: "wav"
    }, flock.file.parseFileExtension = function(e) {
        var t, n = e.lastIndexOf(".");
        if (!(n < 0)) return t = (t = e.substring(n + 1)).toLowerCase(), flock.file.typeAliases[t] || t;
    }, flock.file.parseMIMEType = function(e) {
        return flock.file.mimeTypes[e];
    }, flock.file.stringToBuffer = function(e) {
        var t, n = e.length, r = new ArrayBuffer(n), o = new Uint8Array(r);
        for (t = 0; t < n; t++) o[t] = e.charCodeAt(t);
        return o.buffer;
    }, flock.file.readBufferFromDataUrl = function(t) {
        var e = t.src, n = e.indexOf(","), r = e.substring(0, n), o = e.substring(n + 1), a = r.indexOf(";base64"), i = -1 < a, u = e.indexOf("data:") + 5, l = i ? a : n, s = e.substring(u, l);
        i && (o = c(o)), flock.applyDeferred(function() {
            var e = flock.file.stringToBuffer(o);
            t.success(e, flock.file.parseMIMEType(s));
        });
    }, flock.file.readBufferFromFile = function(t) {
        var e = new FileReader();
        return e.onload = function(e) {
            t.success(e.target.result, flock.file.parseFileExtension(t.src.name));
        }, e.readAsArrayBuffer(t.src), e;
    }, fluid.registerNamespace("flock.audio"), flock.audio.loadBuffer = function(e) {
        var t = e.src || e.url;
        t && (t instanceof ArrayBuffer && flock.applyDeferred(e.success, [ t, e.type ]), 
        flock.audio.loadBuffer.readerForSource(t)(e));
    }, flock.audio.loadBuffer.readerForSource = function(e) {
        return "undefined" != typeof File && e instanceof File ? flock.file.readBufferFromFile : 0 === e.indexOf("data:") ? flock.file.readBufferFromDataUrl : flock.net.readBufferFromUrl;
    }, flock.audio.decode = function(o) {
        var a = o.success;
        o.success = function(e, t) {
            var n = flock.audio.decoderStrategies, r = n[t] || n.default;
            o.decoder && (r = "string" == typeof o.decoder ? fluid.getGlobalValue(o.decoder) : o.decoder), 
            r({
                rawData: e,
                type: t,
                success: a,
                error: o.error,
                sampleRate: o.sampleRate
            });
        }, flock.audio.loadBuffer(o);
    }, flock.audio.decode.webAudio = function(n) {
        flock.webAudio.audioSystem.audioContextSingleton.decodeAudioData(n.rawData, function(e) {
            var t = flock.bufferDesc.fromAudioBuffer(e);
            n.success(t);
        }, n.error);
    }, flock.audio.decoderStrategies = {
        default: flock.audio.decode.webAudio
    }, flock.audio.registerDecoderStrategy = function(e, t) {
        if (e) if ("object" != typeof e) "string" == typeof t && (t = fluid.getGlobalValue(t)), 
        flock.audio.decoderStrategies[e] = t; else for (var n in e) flock.audio.decoderStrategies[n] = e[n];
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var u = "undefined" != typeof window ? window : "undefined" != typeof self ? self : global;
    for (var e in fluid.registerNamespace("flock.audio.convert"), flock.audio.convert.maxFloatValue = function(e) {
        return 1 - 1 / e.scale;
    }, flock.audio.convert.pcm = {
        int8: {
            scale: 128,
            setter: "setInt8",
            width: 1
        },
        int16: {
            scale: 32768,
            setter: "setInt16",
            width: 2
        },
        int32: {
            scale: 2147483648,
            setter: "setInt32",
            width: 4
        },
        float32: {
            scale: 1,
            setter: "setFloat32",
            width: 4
        }
    }, flock.audio.convert.pcm) {
        var t = flock.audio.convert.pcm[e];
        t.maxFloatValue = flock.audio.convert.maxFloatValue(t);
    }
    flock.audio.convert.specForPCMType = function(e) {
        var t = "string" == typeof e ? flock.audio.convert.pcm[e] : e;
        return t || flock.fail("Flocking does not support " + e + " format PCM wave files."), 
        t;
    }, flock.audio.convert.floatToInt = function(e, t) {
        var n = Math.min(t.maxFloatValue, e);
        return n = Math.max(-1, n), n *= t.scale, n = Math.round(n);
    }, flock.audio.convert.floatsToInts = function(e, t) {
        if (e) {
            for (var n = "Int" + 8 * t.width + "Array", r = new u[n](e.length), o = 0; o < e.length; o++) {
                var a = e[o], i = flock.audio.convert.floatToInt(a, t);
                r[o] = i;
            }
            return r;
        }
    }, flock.audio.convert.intToFloat = function(e, t) {
        return e / t.scale;
    }, flock.audio.convert.intsToFloats = function(e, t) {
        if (e) {
            for (var n = new Float32Array(e.length), r = 0; r < e.length; r++) {
                var o = e[r], a = flock.audio.convert.intToFloat(o, t);
                n[r] = a;
            }
            return n;
        }
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.registerNamespace("flock.audio.encode"), flock.audio.interleave = function(e) {
        var t, n, r = e.format.numSampleFrames, o = e.data.channels, a = e.format.numChannels, i = new Float32Array(r * a), u = 0;
        for (t = 0; t < r; t++) for (n = 0; n < a; n++) i[u] = o[n][t], u++;
        return i;
    }, flock.audio.encode = function(e, t, n) {
        return "wav" !== (t = t || "wav").toLowerCase() && flock.fail("Flocking currently only supports encoding WAVE files."), 
        flock.audio.encode.wav(e, n);
    }, flock.audio.encode.writeFloat32Array = function(e, t, n) {
        for (var r = 0; r < n.length; r++) t.setFloat32(e, n[r], !0), e += 4;
        return t;
    }, flock.audio.encode.setString = function(e, t, n) {
        for (var r = 0; r < n.length; r++) e.setUint8(t + r, n.charCodeAt(r));
    }, flock.audio.encode.setBytes = function(e, t, n) {
        for (var r = 0; r < n.length; r++) e.setUint8(t + r, n[r]);
    }, flock.audio.encode.writeAsPCM = function(e, t, n, r) {
        if ("setFloat32" === e.setter && r instanceof Float32Array) return flock.audio.encode.writeFloat32Array(t, n, r);
        for (var o = 0; o < r.length; o++) {
            var a = flock.audio.convert.floatToInt(r[o], e);
            n[e.setter](t, a, !0), t += e.width;
        }
        return n;
    }, flock.audio.encode.wav = function(e, t) {
        t = t || flock.audio.convert.pcm.int16;
        var n = flock.audio.convert.specForPCMType(t), r = flock.audio.interleave(e), o = e.format.numChannels, a = e.format.sampleRate, i = "setFloat32" !== n.setter, u = 16, l = 1, s = r.length * n.width, c = 8 + s, f = n.width * o, d = 8 * n.width;
        if (2 < o || !i) {
            u += 12, 2 < o ? (u += 24, l = 65534) : (u += 2, l = 3);
        }
        var p = 12 + u + c, m = new ArrayBuffer(8 + p), g = new DataView(m);
        flock.audio.encode.setString(g, 0, "RIFF"), g.setUint32(4, p, !0), flock.audio.encode.setString(g, 8, "WAVE"), 
        flock.audio.encode.setString(g, 12, "fmt "), g.setUint32(16, u, !0), g.setUint16(20, l, !0), 
        g.setUint16(22, o, !0), g.setUint32(24, a, !0), g.setUint32(28, a * f, !0), g.setUint16(32, f, !0), 
        g.setUint16(34, d, !0);
        var h = 36;
        return 3 === l ? (g.setUint16(h, 0, !0), h += 2, h = flock.audio.encode.wav.writeFactChunk(g, h, e.format.numSampleFrames)) : 65534 === l && (g.setUint16(h, 22, !0), 
        h += 2, h = flock.audio.encode.wav.additionalFormat(h, g, d, i), h = flock.audio.encode.wav.writeFactChunk(g, h, e.format.numSampleFrames)), 
        flock.audio.encode.wav.writeDataChunk(n, h, g, r, s), g.buffer;
    }, flock.audio.encode.wav.subformats = {
        pcm: new Uint8Array([ 1, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ]),
        float: new Uint8Array([ 3, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ])
    }, flock.audio.encode.wav.additionalFormat = function(e, t, n, r) {
        t.setUint16(e, n, !0), e += 2, t.setUint32(e, 2147483648, !0), e += 4;
        var o = flock.audio.encode.wav.subformats[r ? "pcm" : "float"];
        return flock.audio.encode.setBytes(t, e, o), e += 16;
    }, flock.audio.encode.wav.writeFactChunk = function(e, t, n) {
        return flock.audio.encode.setString(e, t, "fact"), t += 4, e.setUint32(t, 4, !0), 
        t += 4, e.setUint32(t, n, !0), t += 4;
    }, flock.audio.encode.wav.writeDataChunk = function(e, t, n, r, o) {
        flock.audio.encode.setString(n, t, "data"), t += 4, n.setUint32(t, o, !0), t += 4, 
        flock.audio.encode.writeAsPCM(e, t, n, r);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.shim = {
        URL: "undefined" != typeof window ? window.URL || window.webkitURL || window.msURL : void 0
    }, flock.worker = function(e) {
        var t, n, r = typeof e;
        if ("function" === r) e = "(" + e.toString() + ")();"; else if ("string" !== r) throw new Error("A flock.worker must be initialized with a String or a Function.");
        return window.Blob ? (n = new Blob([ e ], {
            type: "text/javascript"
        }), t = flock.shim.URL.createObjectURL(n)) : t = "data:text/javascript;base64," + window.btoa(e), 
        new Worker(t);
    }, fluid.registerNamespace("flock.scheduler"), fluid.defaults("flock.scheduler.clock", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            end: "fluid.mustBeOverridden"
        },
        events: {
            tick: null
        },
        listeners: {
            "onDestroy.end": "{that}.end()"
        }
    }), fluid.defaults("flock.scheduler.intervalClock", {
        gradeNames: [ "flock.scheduler.clock" ],
        members: {
            scheduled: {}
        },
        invokers: {
            schedule: {
                funcName: "flock.scheduler.intervalClock.schedule",
                args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.tick.fire", "{that}.events.onClear.fire" ]
            },
            clear: {
                funcName: "flock.scheduler.intervalClock.clear",
                args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.onClear.fire" ]
            },
            clearAll: {
                funcName: "flock.scheduler.intervalClock.clearAll",
                args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
            },
            end: "{that}.clearAll"
        }
    }), flock.scheduler.intervalClock.schedule = function(e, t, n) {
        var r = setInterval(function() {
            n(e);
        }, e);
        t[e] = r;
    }, flock.scheduler.intervalClock.clear = function(e, t) {
        var n = t[e];
        clearInterval(n), delete t[e];
    }, flock.scheduler.intervalClock.clearAll = function(e, t) {
        for (var n in e) flock.scheduler.intervalClock.clear(n, e, t);
    }, fluid.defaults("flock.scheduler.scheduleClock", {
        gradeNames: [ "flock.scheduler.clock" ],
        members: {
            scheduled: []
        },
        invokers: {
            schedule: {
                funcName: "flock.scheduler.scheduleClock.schedule",
                args: [ "{arguments}.0", "{that}.scheduled", "{that}.events" ]
            },
            clear: {
                funcName: "flock.scheduler.scheduleClock.clear",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.scheduled", "{that}.events.onClear.fire" ]
            },
            clearAll: {
                funcName: "flock.scheduler.scheduleClock.clearAll",
                args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
            },
            end: "{that}.clearAll"
        }
    }), flock.scheduler.scheduleClock.schedule = function(e, t, n) {
        var r;
        r = setTimeout(function() {
            clearTimeout(r), n.tick.fire(e);
        }, e), t.push(r);
    }, flock.scheduler.scheduleClock.clear = function(e, t, n) {
        -1 < (t = void 0 === t ? n.indexOf(e) : t) && (n.splice(t, 1), clearTimeout(e));
    }, flock.scheduler.scheduleClock.clearAll = function(e) {
        for (var t = 0; t < e.length; t++) {
            var n = e[t];
            clearTimeout(n);
        }
        e.length = 0;
    }, fluid.defaults("flock.scheduler.webWorkerClock", {
        gradeNames: [ "fluid.component" ],
        members: {
            worker: {
                expander: {
                    funcName: "flock.worker",
                    args: "@expand:fluid.getGlobalValue(flock.scheduler.webWorkerClock.workerImpl)"
                }
            }
        },
        invokers: {
            postToWorker: {
                funcName: "flock.scheduler.webWorkerClock.postToWorker",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.options.messages", "{that}.worker" ]
            },
            schedule: "{that}.postToWorker(schedule, {arguments}.0)",
            clear: "{that}.postToWorker(clear, {arguments}.0)",
            clearAll: "{that}.postToWorker(clearAll)",
            end: "{that}.postToWorker(end)"
        },
        events: {
            tick: null
        },
        listeners: {
            onCreate: {
                funcName: "flock.scheduler.webWorkerClock.init",
                args: [ "{that}" ]
            },
            "onDestroy.clearAllScheduled": "{that}.clearAll",
            "onDestroy.endWorker": {
                priority: "after:clearAllScheduled",
                func: "{that}.end"
            }
        },
        startMsg: {
            msg: "start",
            value: "{that}.options.clockType"
        },
        messages: {
            schedule: {
                msg: "schedule"
            },
            clear: {
                msg: "clear"
            },
            clearAll: {
                msg: "clearAll"
            },
            end: {
                msg: "end"
            }
        }
    }), flock.scheduler.webWorkerClock.init = function(t) {
        t.worker.addEventListener("message", function(e) {
            t.events.tick.fire(e.data.value);
        }, !1), t.worker.postMessage(t.options.startMsg);
    }, flock.scheduler.webWorkerClock.postToWorker = function(e, t, n, r) {
        var o = n[e];
        void 0 !== t && (o.value = t), r.postMessage(o);
    }, flock.scheduler.webWorkerClock.workerImpl = function() {
        var t = t || {};
        t.worker = t.worker || {}, t.worker.clock = function() {
            var e = {
                tick: function(e) {
                    self.postMessage({
                        msg: "tick",
                        value: e
                    });
                }
            };
            return e;
        }, t.worker.intervalClock = function() {
            var n = t.worker.clock();
            return n.scheduled = {}, n.schedule = function(e) {
                var t = setInterval(function() {
                    n.tick(e);
                }, e);
                n.scheduled[e] = t;
            }, n.clear = function(e) {
                var t = n.scheduled[e];
                clearInterval(t), delete n.scheduled[e];
            }, n.clearAll = function() {
                for (var e in n.scheduled) n.clear(e);
            }, n;
        }, t.worker.scheduleClock = function() {
            var n = t.worker.clock();
            return n.scheduled = [], n.schedule = function(e) {
                var t;
                t = setTimeout(function() {
                    n.clear(t), n.tick(e);
                }, e), n.scheduled.push(t);
            }, n.clear = function(e, t) {
                -1 < (t = void 0 === t ? n.scheduled.indexOf(e) : t) && n.scheduled.splice(t, 1), 
                clearTimeout(e);
            }, n.clearAll = function() {
                for (var e = 0; e < n.scheduled.length; e++) {
                    var t = n.scheduled[e];
                    clearTimeout(t);
                }
                n.scheduled.length = 0;
            }, n;
        }, self.addEventListener("message", function(e) {
            "start" === e.data.msg ? t.clock = t.worker[e.data.value]() : "end" === e.data.msg ? t.clock && (t.clock.clearAll(), 
            self.close()) : t.clock && t.clock[e.data.msg](e.data.value);
        }, !1);
    }, fluid.defaults("flock.scheduler.webWorkerIntervalClock", {
        gradeNames: [ "flock.scheduler.webWorkerClock" ],
        clockType: "intervalClock"
    }), fluid.defaults("flock.scheduler.webWorkerScheduleClock", {
        gradeNames: [ "flock.scheduler.webWorkerClock" ],
        clockType: "scheduleClock"
    }), fluid.defaults("flock.scheduler", {
        gradeNames: [ "fluid.component" ],
        events: {
            onScheduled: null,
            onFinished: null,
            onClearAll: null
        },
        listeners: {
            "onClearAll.clearClock": [ "{that}.clock.clearAll()" ]
        }
    }), flock.scheduler.addListener = function(e, t, n) {
        return t.push(e), n(e), e;
    }, flock.scheduler.removeListener = function(e, t, n) {
        if (e) {
            var r = t.indexOf(e);
            -1 < r ? (t.splice(r, 1), n(e)) : e.wrappedListener && flock.scheduler.removeListener(e.wrappedListener, t, n);
        }
    }, fluid.defaults("flock.scheduler.repeat", {
        gradeNames: [ "flock.scheduler" ],
        members: {
            listeners: {}
        },
        components: {
            clock: {
                type: "flock.scheduler.webWorkerIntervalClock"
            }
        },
        invokers: {
            schedule: {
                funcName: "flock.scheduler.repeat.schedule",
                args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.listeners", "{that}.events.onScheduled.fire" ]
            },
            clear: "{that}.events.onFinished.fire",
            clearAll: {
                funcName: "flock.scheduler.repeat.clearAll",
                args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
            },
            clearInterval: {
                funcName: "flock.scheduler.repeat.clearInterval",
                args: [ "{arguments}.0", "{that}.listeners", "{that}.events.onFinished.fire" ]
            },
            addIntervalListener: {
                funcName: "flock.scheduler.repeat.addIntervalListener",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
            },
            removeIntervalListener: {
                funcName: "flock.scheduler.repeat.removeIntervalListener",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
            }
        },
        listeners: {
            onScheduled: [ "{that}.addIntervalListener({arguments}.0, {arguments}.1)", "{that}.clock.schedule({arguments}.0)" ],
            onFinished: [ "{that}.removeIntervalListener({arguments}.0, {arguments}.1)" ]
        }
    }), flock.scheduler.repeat.intervalListeners = function(e, t) {
        return t[e];
    }, flock.scheduler.repeat.addIntervalListener = function(e, t, n, r) {
        var o = flock.scheduler.repeat.intervalListeners(e, n);
        flock.scheduler.addListener(t, o, r);
    }, flock.scheduler.repeat.removeIntervalListener = function(e, t, n, r) {
        var o = flock.scheduler.repeat.intervalListeners(e, n);
        flock.scheduler.removeListener(t, o, r);
    }, flock.scheduler.repeat.schedule = function(e, t, n, r, o, a) {
        e = n.value(e), t = flock.scheduler.async.prepareListener(t, r);
        var i = flock.scheduler.repeat.wrapValueListener(e, t);
        return flock.scheduler.repeat.addInterval(e, o), a(e, i), i;
    }, flock.scheduler.repeat.wrapValueListener = function(t, n) {
        var e = function(e) {
            e === t && n(e);
        };
        return e.wrappedListener = n, e;
    }, flock.scheduler.repeat.addInterval = function(e, t) {
        var n = t[e];
        n || (n = t[e] = []);
    }, flock.scheduler.repeat.clearAll = function(e, t, n) {
        for (var r in e) flock.scheduler.repeat.clearInterval(r, e, t);
        n();
    }, flock.scheduler.repeat.clearInterval = function(e, t, n) {
        var r = t[e];
        if (r) for (var o = 0; o < r.length; o++) {
            n(e, r[o]);
        }
    }, fluid.defaults("flock.scheduler.once", {
        gradeNames: [ "flock.scheduler" ],
        members: {
            listeners: []
        },
        components: {
            clock: {
                type: "flock.scheduler.webWorkerScheduleClock"
            }
        },
        invokers: {
            schedule: {
                funcName: "flock.scheduler.once.schedule",
                args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.clear", "{that}.events.onScheduled.fire" ]
            },
            clear: "{that}.events.onFinished.fire",
            clearAll: {
                funcName: "flock.scheduler.once.clearAll",
                args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
            }
        },
        listeners: {
            onScheduled: [ {
                funcName: "flock.scheduler.addListener",
                args: [ "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
            }, {
                func: "{that}.clock.schedule",
                args: [ "{arguments}.0" ]
            } ],
            onFinished: {
                funcName: "flock.scheduler.removeListener",
                args: [ "{arguments}.0", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
            }
        }
    }), flock.scheduler.once.wrapValueListener = function(t, n, r) {
        var o = function(e) {
            e === t && (n(e), r(o));
        };
        return o.wrappedListener = n, o;
    }, flock.scheduler.once.schedule = function(e, t, n, r, o, a) {
        e = n.value(e), t = flock.scheduler.async.prepareListener(t, r);
        var i = flock.scheduler.once.wrapValueListener(e, t, o);
        return a(e, i), i;
    }, flock.scheduler.once.clearAll = function(e, t, n) {
        for (var r = 0; r < e.length; r++) t(e[r]);
        n();
    }, fluid.defaults("flock.scheduler.async", {
        gradeNames: [ "fluid.component" ],
        subSchedulerOptions: {
            components: {
                timeConverter: "{async}.timeConverter"
            },
            listeners: {
                "{async}.events.onClear": "{that}.clear()",
                "{async}.events.onClearAll": "{that}.clearAll()",
                "{async}.events.onEnd": "{that}.clock.end()"
            }
        },
        distributeOptions: {
            source: "{that}.options.subSchedulerOptions",
            removeSource: !0,
            target: "{that flock.scheduler}.options"
        },
        components: {
            timeConverter: {
                type: "flock.convert.seconds"
            },
            onceScheduler: {
                type: "flock.scheduler.once"
            },
            repeatScheduler: {
                type: "flock.scheduler.repeat"
            },
            synthContext: void 0
        },
        invokers: {
            repeat: {
                func: "{repeatScheduler}.schedule",
                args: [ "{arguments}.0", "{arguments}.1" ]
            },
            once: {
                func: "{onceScheduler}.schedule",
                args: [ "{arguments}.0", "{arguments}.1" ]
            },
            sequence: {
                funcName: "flock.scheduler.async.sequence",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.once" ]
            },
            schedule: {
                funcName: "flock.scheduler.async.schedule",
                args: [ "{arguments}.0", "{that}" ]
            },
            clear: "{that}.events.onClear.fire",
            clearAll: "{that}.events.onClearAll.fire",
            end: "{that}.events.onEnd.fire"
        },
        events: {
            onClear: null,
            onClearAll: null,
            onEnd: null
        },
        listeners: {
            onCreate: "{that}.schedule({that}.options.score)",
            onEnd: "{that}.clearAll"
        }
    }), flock.scheduler.async.sequence = function(e, t, n) {
        for (var r = [], o = 0; o < e.length; o++) {
            var a = n(e[o], t);
            r.push(a);
        }
        return r;
    }, flock.scheduler.async.schedule = function(e, t) {
        if (e) {
            e = flock.isIterable(e) ? e : [ e ];
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                flock.invoke(t, r.interval, [ r.time, r.change ]);
            }
        }
    }, flock.scheduler.async.prepareListener = function(e, t) {
        return "function" == typeof e ? e : flock.scheduler.async.evaluateChangeSpec(e, t);
    }, flock.scheduler.async.getTargetSynth = function(e, t) {
        var n = e.synth;
        return n ? "string" != typeof n ? n : fluid.get(t, n) : t;
    }, flock.scheduler.async.makeSynthUpdater = function(r, o, a, i) {
        return function() {
            for (var e in r) {
                var t = r[e];
                a[e] = flock.evaluate.synthValue(t);
            }
            var n = flock.scheduler.async.getTargetSynth(o, i);
            n ? n.set(a) : flock.fail("A target synth named " + o.synth + " could not be found in the specified synthContext. Synth context was: " + i);
        };
    }, flock.scheduler.async.evaluateChangeSpec = function(e, t) {
        var n = {}, r = {};
        for (var o in e.values) {
            var a = e.values[o];
            a.synthDef ? n[o] = flock.synth.value(a) : r[o] = a;
        }
        return flock.scheduler.async.makeSynthUpdater(n, e, r, t);
    }, fluid.defaults("flock.scheduler.async.tempo", {
        gradeNames: [ "flock.scheduler.async" ],
        bpm: 60,
        components: {
            timeConverter: {
                type: "flock.convert.beats",
                options: {
                    bpm: "{tempo}.options.bpm"
                }
            }
        }
    }), fluid.registerNamespace("flock.convert"), fluid.defaults("flock.convert.ms", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            value: "fluid.identity({arguments}.0)"
        }
    }), fluid.defaults("flock.convert.seconds", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            value: "flock.convert.seconds.toMillis({arguments}.0)"
        }
    }), flock.convert.seconds.toMillis = function(e) {
        return 1e3 * e;
    }, fluid.defaults("flock.convert.beats", {
        gradeNames: [ "fluid.component" ],
        bpm: 60,
        invokers: {
            value: "flock.convert.beats.toMillis({arguments}.0, {that}.options.bpm)"
        }
    }), flock.convert.beats.toMillis = function(e, t) {
        return t <= 0 ? 0 : e / t * 6e4;
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.registerNamespace("flock.webAudio"), flock.webAudio.createNode = function(e, t) {
        var n = t.args ? fluid.makeArray(t.args) : void 0, r = "create" + t.node, o = r.indexOf("Node");
        -1 < o && (r = r.substring(0, o));
        var a = e[r].apply(e, n);
        return flock.webAudio.initNodeParams(e, a, t), flock.webAudio.initNodeProperties(a, t), 
        flock.webAudio.initNodeInputs(a, t), a;
    }, flock.webAudio.setAudioParamValue = function(e, t, n, r) {
        r = r || 0;
        var o = e.currentTime + r;
        t.setValueAtTime(n, o);
    }, flock.webAudio.initNodeParams = function(e, t, n) {
        var r = n.params;
        if (t && r) {
            for (var o in r) {
                var a = t[o], i = r[o];
                flock.webAudio.setAudioParamValue(e, a, i);
            }
            return t;
        }
    }, flock.webAudio.safariPropertyProhibitions = [ "channelCount", "channelCountMode" ], 
    flock.webAudio.shouldSetProperty = function(e) {
        return !flock.platform.browser.safari || flock.webAudio.safariPropertyProhibitions.indexOf(e) < 0;
    }, flock.webAudio.initNodeProperties = function(e, t) {
        var n = t.props;
        if (n) {
            for (var r in n) {
                var o = n[r];
                flock.webAudio.shouldSetProperty(r) && (e[r] = o);
            }
            return e;
        }
    }, flock.webAudio.connectInput = function(e, t, n, r) {
        n.connect(e, r, t);
    }, flock.webAudio.initNodeInputs = function(e, t) {
        var n = t.inputs;
        for (var r in n) {
            var o = n[r], a = parseInt(r, 10);
            o = fluid.makeArray(o);
            for (var i = 0; i < o.length; i++) {
                var u = o[i];
                flock.webAudio.connectInput(e, a, u);
            }
        }
    }, fluid.defaults("flock.webAudio.node", {
        gradeNames: [ "fluid.modelComponent" ],
        members: {
            node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
        },
        nodeSpec: {
            args: [],
            params: {},
            properties: {}
        }
    }), fluid.defaults("flock.webAudio.gain", {
        gradeNames: [ "flock.webAudio.node" ],
        members: {
            node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
        },
        nodeSpec: {
            node: "Gain"
        }
    }), fluid.defaults("flock.webAudio.scriptProcessor", {
        gradeNames: [ "flock.webAudio.node" ],
        nodeSpec: {
            node: "ScriptProcessor",
            args: [ "{audioSystem}.model.bufferSize", "{audioSystem}.model.numInputBuses", "{audioSystem}.model.chans" ],
            params: {},
            properties: {
                channelCountMode: "explicit"
            }
        }
    }), fluid.defaults("flock.webAudio.channelMerger", {
        gradeNames: [ "flock.webAudio.node" ],
        nodeSpec: {
            node: "ChannelMerger",
            args: [ "{audioSystem}.model.numInputBuses" ],
            properties: {
                channelCountMode: "discrete"
            }
        }
    }), fluid.defaults("flock.webAudio.outputFader", {
        gradeNames: [ "fluid.component" ],
        fadeDuration: .5,
        gainSpec: {
            node: "Gain",
            params: {
                gain: 0
            },
            properties: {
                channelCount: "{flock.enviro}.audioSystem.model.chans",
                channelCountMode: "explicit"
            }
        },
        members: {
            gainNode: "@expand:flock.webAudio.outputFader.createGainNode({flock.enviro}.audioSystem.nativeNodeManager, {that}.options.gainSpec)",
            context: "{flock.enviro}.audioSystem.context"
        },
        invokers: {
            fadeIn: {
                funcName: "flock.webAudio.outputFader.fadeIn",
                args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
            },
            fadeTo: {
                funcName: "flock.webAudio.outputFader.fadeTo",
                args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
            }
        }
    }), flock.webAudio.outputFader.createGainNode = function(e, t) {
        return e.createOutputNode(t);
    }, flock.webAudio.outputFader.fade = function(e, t, n, r, o) {
        o = o || 0;
        var a = e.currentTime + o;
        flock.webAudio.setAudioParamValue(e, t.gain, n), t.gain.linearRampToValueAtTime(r, a);
    }, flock.webAudio.outputFader.fadeTo = function(e, t, n, r) {
        flock.webAudio.outputFader.fade(e, t, t.gain.value, n, r);
    }, flock.webAudio.outputFader.fadeIn = function(e, t, n, r) {
        flock.webAudio.outputFader.fade(e, t, 0, n, r);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.webAudio.audioSystem", {
        gradeNames: [ "flock.audioSystem" ],
        channelRange: {
            min: "@expand:flock.webAudio.audioSystem.calcMinChannels()",
            max: "@expand:flock.webAudio.audioSystem.calcMaxChannels({that}.context.destination)"
        },
        members: {
            context: "@expand:flock.webAudio.audioSystem.createContext()"
        },
        model: {
            rates: {
                audio: "{that}.context.sampleRate"
            }
        },
        components: {
            outputManager: {
                type: "flock.webAudio.outputManager"
            },
            nativeNodeManager: {
                type: "flock.webAudio.nativeNodeManager"
            },
            inputDeviceManager: {
                type: "flock.webAudio.inputDeviceManager"
            },
            bufferWriter: {
                type: "flock.webAudio.bufferWriter"
            }
        },
        listeners: {
            onCreate: [ "flock.webAudio.audioSystem.configureDestination({that}.context, {that}.model.chans)" ]
        }
    }), flock.webAudio.audioSystem.createContext = function() {
        var e = flock.webAudio.audioSystem;
        return e.audioContextSingleton || (e.audioContextSingleton = new flock.shim.AudioContext()), 
        e.audioContextSingleton;
    }, flock.webAudio.audioSystem.calcMaxChannels = function(e) {
        return flock.platform.browser.safari ? e.channelCount : e.maxChannelCount;
    }, flock.webAudio.audioSystem.calcMinChannels = function() {
        return flock.platform.browser.safari ? 2 : 1;
    }, flock.webAudio.audioSystem.configureDestination = function(e, t) {
        flock.platform.browser.safari || (e.destination.channelCount = t, e.destination.channelCountMode = "explicit", 
        e.destination.channelInterpretation = "discrete");
    }, fluid.defaults("flock.webAudio.enviroContextDistributor", {
        gradeNames: [ "fluid.component" ],
        distributeOptions: [ {
            target: "{/ flock.enviro > audioSystem}.options",
            record: {
                gradeNames: "flock.webAudio.audioSystem"
            }
        } ]
    }), fluid.constructSingle([], {
        singleRootType: "flock.enviroContextDistributor",
        type: "flock.webAudio.enviroContextDistributor"
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.webAudio.bufferWriter", {
        gradeNames: "fluid.component",
        invokers: {
            save: "flock.webAudio.bufferWriter.saveBuffer({arguments}.0)"
        }
    }), flock.webAudio.bufferWriter.saveBuffer = function(t) {
        try {
            var e = flock.audio.encode.wav(t.buffer, t.format), n = new Blob([ e ], {
                type: "audio/wav"
            });
            return flock.webAudio.bufferWriter.download(t.path, n), t.success && t.success(e), 
            e;
        } catch (e) {
            t.error ? t.error(e) : flock.fail("There was an error while trying to download the buffer named " + t.buffer.id + ". Error: " + e);
        }
    }, flock.webAudio.bufferWriter.download = function(e, t) {
        var n = flock.shim.URL.createObjectURL(t), r = window.document.createElement("a"), o = document.createEvent("Event");
        r.href = n, r.download = e, o.initEvent("click", !0, !0), r.dispatchEvent(o);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.registerNamespace("flock.webAudio.chrome"), flock.webAudio.chrome.getSources = function(n) {
        return MediaStreamTrack.getSources(function(e) {
            var t = fluid.transform(e, function(e) {
                return e.deviceId = e.id, e;
            });
            n(t);
        });
    }, flock.webAudio.mediaStreamFailure = function(e) {
        var t = "This browser does not support getUserMedia() or the Media Streams API.";
        e ? e(new Error(t)) : fluid.log(fluid.logLevel.IMPORTANT, t);
    };
    var e = {
        AudioContext: window.AudioContext || window.webkitAudioContext,
        getUserMedia: function(e, t, n) {
            navigator.mediaDevices ? navigator.mediaDevices.getUserMedia(e).then(t).catch(n) : navigator.getUserMedia ? navigator.getUserMedia(e, t, n) : flock.webAudio.mediaStreamFailure(n);
        },
        getMediaDevicesImpl: navigator.getMediaDevices ? navigator.getMediaDevices : void 0 !== window.MediaStreamTrack ? flock.webAudio.chrome.getSources : flock.webAudio.mediaStreamFailure,
        getMediaDevice: function() {
            flock.shim.getMediaDevicesImpl.apply(navigator, arguments);
        }
    };
    jQuery.extend(flock.shim, e), fluid.defaults("flock.webAudio.inputDeviceManager", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            openAudioDevice: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDevice",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithId", "{that}.openFirstAudioDeviceWithLabel", "{that}.openAudioDeviceWithConstraints" ]
            },
            openAudioDeviceWithConstraints: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints",
                args: [ "{audioSystem}.context", "{enviro}", "{nativeNodeManager}.createMediaStreamInput", "{arguments}.0" ]
            },
            openAudioDeviceWithId: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithId",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithConstraints" ]
            },
            openFirstAudioDeviceWithLabel: {
                funcName: "flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithId" ]
            }
        }
    }), flock.webAudio.inputDeviceManager.openAudioDevice = function(e, t, n, r) {
        if (e) {
            if (e.id) return t(e.id);
            if (e.label) return n(e.label);
        }
        return r();
    }, flock.webAudio.inputDeviceManager.openAudioDeviceWithId = function(e, t) {
        t({
            audio: {
                optional: [ {
                    sourceId: e
                } ]
            }
        });
    }, flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel = function(n, r) {
        n && flock.shim.getMediaDevices(function(e) {
            var t = e.filter(function(e) {
                if (e.label.toLowerCase() === n.toLowerCase()) return !0;
            });
            0 < t.length ? r(t[0].deviceId) : fluid.log(fluid.logLevel.IMPORTANT, "An audio device named '" + n + "' could not be found.");
        });
    }, flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints = function(e, t, n, r) {
        r = r || {
            audio: !0
        };
        var o = t.busManager.acquireNextBus("input");
        return flock.shim.getUserMedia(r, function(e) {
            n(e, o);
        }, function(e) {
            fluid.log(fluid.logLevel.IMPORTANT, "An error occurred while trying to access the user's microphone. " + e);
        }), o;
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.registerNamespace("flock.midi"), flock.midi.requestAccess = function(e, t, n) {
        if (!navigator.requestMIDIAccess) {
            var r = "The Web MIDI API is not available. You may need to enable it in your browser's settings.";
            return fluid.log(fluid.logLevel.WARN, r), void n(r);
        }
        navigator.requestMIDIAccess({
            sysex: e
        }).then(t, n);
    }, flock.midi.getPorts = function(e) {
        var t = {};
        return flock.midi.collectPorts("inputs", e, t), flock.midi.collectPorts("outputs", e, t), 
        t;
    }, flock.midi.requestPorts = function(n, e) {
        flock.midi.requestAccess(!1, function(e) {
            var t = flock.midi.getPorts(e);
            n(t);
        }, e);
    }, flock.midi.createPortViews = function(e) {
        return fluid.transform(e, function(e) {
            return {
                id: e.id,
                name: e.name,
                manufacturer: e.manufacturer,
                state: e.state,
                connection: e.connection
            };
        });
    }, flock.midi.prettyPrintPorts = function(e) {
        return fluid.prettyPrintJSON({
            inputs: flock.midi.createPortViews(e.inputs),
            outputs: flock.midi.createPortViews(e.outputs)
        });
    }, flock.midi.logPorts = function() {
        flock.midi.requestPorts(function(e) {
            var t = flock.midi.prettyPrintPorts(e);
            console.log(t);
        }, function(e) {
            console.log(e);
        });
    }, flock.midi.collectPorts = function(e, t, n) {
        for (var r = n[e] = n[e] || [], o = t[e].values(), a = o.next(); !a.done; ) r.push(a.value), 
        a = o.next();
        return n;
    }, flock.midi.read = function(e) {
        var t, n = e[0], r = 15 & n;
        switch (n >> 4) {
          case 8:
            t = flock.midi.read.noteOff;
            break;

          case 9:
            t = 0 < e[2] ? flock.midi.read.noteOn : flock.midi.read.noteOff;
            break;

          case 10:
            t = flock.midi.read.polyAftertouch;
            break;

          case 11:
            t = flock.midi.read.controlChange;
            break;

          case 12:
            t = flock.midi.read.programChange;
            break;

          case 13:
            t = flock.midi.read.channelAftertouch;
            break;

          case 14:
            t = flock.midi.read.pitchbend;
            break;

          case 15:
            t = flock.midi.read.system;
            break;

          default:
            return flock.fail("Received an unrecognized MIDI message: " + fluid.prettyPrintJSON(e));
        }
        return t(r, e);
    }, flock.midi.read.note = function(e, t, n) {
        return {
            type: e,
            channel: t,
            note: n[1],
            velocity: n[2]
        };
    }, flock.midi.read.noteOn = function(e, t) {
        return flock.midi.read.note("noteOn", e, t);
    }, flock.midi.read.noteOff = function(e, t) {
        return flock.midi.read.note("noteOff", e, t);
    }, flock.midi.read.polyAftertouch = function(e, t) {
        return {
            type: "aftertouch",
            channel: e,
            note: t[1],
            pressure: t[2]
        };
    }, flock.midi.read.controlChange = function(e, t) {
        return {
            type: "control",
            channel: e,
            number: t[1],
            value: t[2]
        };
    }, flock.midi.read.programChange = function(e, t) {
        return {
            type: "program",
            channel: e,
            program: t[1]
        };
    }, flock.midi.read.channelAftertouch = function(e, t) {
        return {
            type: "aftertouch",
            channel: e,
            pressure: t[1]
        };
    }, flock.midi.read.twoByteValue = function(e) {
        return e[2] << 7 | e[1];
    }, flock.midi.read.pitchbend = function(e, t) {
        return {
            type: "pitchbend",
            channel: e,
            value: flock.midi.read.twoByteValue(t)
        };
    }, flock.midi.read.system = function(e, t) {
        if (1 === e) return flock.midi.messageFailure("quarter frame MTC");
        var n;
        switch (e) {
          case 0:
            n = flock.midi.read.sysex;
            break;

          case 2:
            n = flock.midi.read.songPointer;
            break;

          case 3:
            n = flock.midi.read.songSelect;
            break;

          case 6:
            n = flock.midi.read.tuneRequest;
            break;

          case 8:
            n = flock.midi.read.clock;
            break;

          case 10:
            n = flock.midi.read.start;
            break;

          case 11:
            n = flock.midi.read.continue;
            break;

          case 12:
            n = flock.midi.read.stop;
            break;

          case 14:
            n = flock.midi.read.activeSense;
            break;

          case 15:
            n = flock.midi.read.reset;
            break;

          default:
            return flock.fail("Received an unrecognized MIDI system message: " + fluid.prettyPrintJSON(t));
        }
        return n(t);
    }, flock.midi.messageFailure = function(e) {
        flock.fail("Flocking does not currently support MIDI " + e + " messages.");
    }, flock.midi.read.sysex = function(e) {
        var t = 240 === e[0] ? 1 : 0, n = e.length - (247 === e[e.length - 1] ? 1 : 0);
        return {
            type: "sysex",
            data: e instanceof Uint8Array ? e.subarray(t, n) : e.slice(t, n)
        };
    }, flock.midi.read.valueMessage = function(e, t) {
        return {
            type: e,
            value: t
        };
    }, flock.midi.read.songPointer = function(e) {
        var t = flock.midi.read.twoByteValue(e);
        return flock.midi.read.valueMessage("songPointer", t);
    }, flock.midi.read.songSelect = function(e) {
        return flock.midi.read.valueMessage("songSelect", e[1]);
    }, flock.midi.read.tuneRequest = function() {
        return {
            type: "tuneRequest"
        };
    }, flock.midi.systemRealtimeMessages = [ "tuneRequest", "clock", "start", "continue", "stop", "activeSense", "reset" ], 
    flock.midi.createSystemRealtimeMessageReaders = function(e) {
        fluid.each(e, function(e) {
            flock.midi.read[e] = function() {
                return {
                    type: e
                };
            };
        });
    }, flock.midi.createSystemRealtimeMessageReaders(flock.midi.systemRealtimeMessages), 
    fluid.defaults("flock.midi.system", {
        gradeNames: [ "fluid.component" ],
        sysex: !1,
        members: {
            access: void 0,
            ports: void 0
        },
        invokers: {
            requestAccess: {
                funcName: "flock.midi.requestAccess",
                args: [ "{that}.options.sysex", "{that}.events.onAccessGranted.fire", "{that}.events.onAccessError.fire" ]
            },
            refreshPorts: {
                funcName: "flock.midi.system.refreshPorts",
                args: [ "{that}", "{that}.access", "{that}.events.onPortsAvailable.fire" ]
            }
        },
        events: {
            onAccessGranted: null,
            onAccessError: null,
            onReady: null,
            onPortsAvailable: null
        },
        listeners: {
            onCreate: {
                func: "{that}.requestAccess"
            },
            onAccessGranted: [ "flock.midi.system.setAccess({that}, {arguments}.0)", "{that}.refreshPorts()", "{that}.events.onReady.fire({that}.ports)" ],
            onAccessError: {
                funcName: "fluid.log",
                args: [ fluid.logLevel.WARN, "MIDI Access Error: ", "{arguments}.0" ]
            }
        }
    }), flock.midi.system.setAccess = function(e, t) {
        e.access = t;
    }, flock.midi.system.refreshPorts = function(e, t, n) {
        e.ports = flock.midi.getPorts(t), n(e.ports);
    }, fluid.defaults("flock.midi.receiver", {
        gradeNames: [ "fluid.component" ],
        events: {
            raw: null,
            message: null,
            note: null,
            noteOn: null,
            noteOff: null,
            control: null,
            program: null,
            aftertouch: null,
            pitchbend: null,
            sysex: null,
            songPointer: null,
            songSelect: null,
            tuneRequest: null,
            clock: null,
            start: null,
            continue: null,
            stop: null,
            activeSense: null,
            reset: null
        }
    }), fluid.defaults("flock.midi.connection", {
        gradeNames: [ "flock.midi.receiver" ],
        openImmediately: !1,
        sysex: !1,
        distributeOptions: {
            source: "{that}.options.sysex",
            target: "{that > system}.options.sysex"
        },
        ports: 0,
        invokers: {
            sendRaw: {
                func: "{that}.events.onSendRaw.fire"
            },
            send: {
                funcName: "flock.midi.connection.send",
                args: [ "{that}", "{arguments}.0" ]
            },
            open: {
                funcName: "flock.midi.connection.bind",
                args: [ "{that}.system.ports", "{that}.options.ports", "{that}.events.onReady.fire", "{that}.events.raw.fire", "{that}.events.onSendRaw" ]
            },
            close: {
                funcName: "flock.midi.connection.close",
                args: [ "{that}.system.ports", "{that}.events.raw.fire" ]
            }
        },
        components: {
            system: {
                type: "flock.midi.system",
                options: {
                    events: {
                        onReady: "{connection}.events.onPortsAvailable"
                    }
                }
            }
        },
        events: {
            onPortsAvailable: null,
            onReady: null,
            onError: null,
            onSendRaw: null
        },
        listeners: {
            onPortsAvailable: {
                funcName: "flock.midi.connection.autoOpen",
                args: [ "{that}.options.openImmediately", "{that}.open" ]
            },
            onError: {
                funcName: "fluid.log",
                args: [ fluid.logLevel.WARN, "{arguments}.0" ]
            },
            raw: {
                funcName: "flock.midi.connection.fireEvent",
                args: [ "{arguments}.0", "{that}.events" ]
            },
            onDestroy: [ "{that}.close()" ]
        }
    }), flock.midi.write = function(e) {
        if ("sysex" === e.type) return flock.midi.write.sysex(e);
        switch (e.type) {
          case "noteOn":
            return flock.midi.write.note(9, e);

          case "noteOff":
            return flock.midi.write.note(8, e);

          case "aftertouch":
            return flock.midi.write.aftertouch(e);

          case "control":
            return flock.midi.write.controlChange(e);

          case "program":
            return flock.midi.write.programChange(e);

          case "pitchbend":
            return flock.midi.write.largeValueMessage(14, e.channel, e);

          case "songPointer":
            return flock.midi.write.largeValueMessage(15, 2, e);

          case "songSelect":
            return flock.midi.write.largeValueMessage(15, 3, e);

          case "tuneRequest":
            return flock.midi.write.singleByteMessage(15, 6);

          case "clock":
            return flock.midi.write.singleByteMessage(15, 8);

          case "start":
            return flock.midi.write.singleByteMessage(15, 10);

          case "continue":
            return flock.midi.write.singleByteMessage(15, 11);

          case "stop":
            return flock.midi.write.singleByteMessage(15, 12);

          case "activeSense":
            return flock.midi.write.singleByteMessage(15, 14);

          case "reset":
            return flock.midi.write.singleByteMessage(15, 15);

          default:
            flock.fail("Cannot write an unrecognized MIDI message of type '" + e.type + "'.");
        }
    }, flock.midi.write.note = function(e, t) {
        return flock.midi.write.threeByteMessage(e, t.channel, t.note, t.velocity);
    }, flock.midi.write.controlChange = function(e) {
        return flock.midi.write.threeByteMessage(11, e.channel, e.number, e.value);
    }, flock.midi.write.programChange = function(e) {
        return flock.midi.write.twoByteMessage(12, e.channel, e.program);
    }, flock.midi.write.aftertouch = function(e) {
        return e.note ? flock.midi.write.note(10, e) : flock.midi.write.twoByteMessage(13, e.channel, e.pressure);
    }, flock.midi.write.singleByteMessage = function(e, t) {
        var n = new Uint8Array(1);
        return n[0] = flock.midi.write.statusByte(e, t), n;
    }, flock.midi.write.twoByteMessage = function(e, t, n) {
        var r = new Uint8Array(2);
        return r[0] = flock.midi.write.statusByte(e, t), r[1] = n, r;
    }, flock.midi.write.threeByteMessage = function(e, t, n, r) {
        var o = new Uint8Array(3);
        return o[0] = flock.midi.write.statusByte(e, t), o[1] = n, o[2] = r, o;
    }, flock.midi.write.largeValueMessage = function(e, t, n) {
        var r = new Uint8Array(3);
        return r[0] = flock.midi.write.statusByte(e, t), flock.midi.write.twoByteValue(n.value, r, 1), 
        r;
    }, flock.midi.write.statusByte = function(e, t) {
        return (e << 4) + t;
    }, flock.midi.write.twoByteValue = function(e, t, n) {
        t[n = n || 0] = 127 & e, t[n + 1] = e >> 7 & 127;
    }, flock.midi.write.sysex = function(e) {
        240 !== e.data[0] && 247 !== e.data[e.data.length - 1] || flock.fail("Sysex payloads should not include framing bytes.");
        var t = e.data, n = t.length, r = new Uint8Array(n + 2);
        return r[0] = 240, r[n + 1] = 247, r.set(t, 1), r;
    }, flock.midi.connection.send = function(e, t) {
        var n = flock.midi.write(t);
        e.events.onSendRaw.fire(n);
    }, flock.midi.connection.autoOpen = function(e, t) {
        e && t();
    }, flock.midi.findPorts = function(n, e) {
        e = fluid.makeArray(e);
        var r = [];
        return fluid.each(e, function(e) {
            var t = flock.midi.findPorts.portFinder(e)(n);
            r = r.concat(t);
        }), r;
    }, flock.midi.findPorts.portFinder = function(e) {
        if ("number" == typeof e) return flock.midi.findPorts.byIndex(e);
        "string" == typeof e && (e = {
            name: e
        });
        var t = e.id ? flock.midi.findPorts.idMatcher(e.id) : e.manufacturer && e.name ? flock.midi.findPorts.bothMatcher(e.manufacturer, e.name) : e.manufacturer ? flock.midi.findPorts.manufacturerMatcher(e.manufacturer) : flock.midi.findPorts.nameMatcher(e.name);
        return function(e) {
            return e.filter(t);
        };
    }, flock.midi.findPorts.byIndex = function(n) {
        return function(e) {
            var t = e[n];
            return t ? [ t ] : [];
        };
    }, flock.midi.findPorts.lowerCaseContainsMatcher = function(a) {
        return function(e) {
            var t;
            for (var n in a) {
                var r = e[n], o = a[n];
                if (!(t = "*" === o || r && -1 < r.toLowerCase().indexOf(o.toLowerCase()))) break;
            }
            return t;
        };
    }, flock.midi.findPorts.idMatcher = function(t) {
        return function(e) {
            return e.id === t;
        };
    }, flock.midi.findPorts.bothMatcher = function(e, t) {
        return flock.midi.findPorts.lowerCaseContainsMatcher({
            manufacturer: e,
            name: t
        });
    }, flock.midi.findPorts.manufacturerMatcher = function(e) {
        return flock.midi.findPorts.lowerCaseContainsMatcher({
            manufacturer: e
        });
    }, flock.midi.findPorts.nameMatcher = function(e) {
        return flock.midi.findPorts.lowerCaseContainsMatcher({
            name: e
        });
    }, flock.midi.findPorts.eachPortOfType = function(e, t, n) {
        var r = fluid.makeArray(e);
        fluid.each(r, function(e) {
            e.type === t && n(e);
        });
    }, flock.midi.connection.openPort = function(e, t) {
        if (e.open) {
            var n = e.open();
            t.push(n);
        }
        return t;
    }, flock.midi.connection.listen = function(e, t, n) {
        return flock.midi.findPorts.eachPortOfType(e, "input", function(e) {
            flock.midi.connection.openPort(e, n), e.addEventListener("midimessage", t, !1);
        }), n;
    }, flock.midi.connection.stopListening = function(e, t) {
        flock.midi.findPorts.eachPortOfType(e, "input", function(e) {
            e.close(), e.removeEventListener("midimessage", t, !1);
        });
    }, flock.midi.connection.bindSender = function(e, t, n) {
        var r = fluid.makeArray(e);
        return fluid.each(r, function(e) {
            flock.midi.connection.openPort(e, n), t.addListener(e.send.bind(e));
        }), n;
    }, flock.midi.connection.fireReady = function(e, t) {
        !e || e.length < 1 || Promise.all(e).then(t);
    }, flock.midi.connection.bind = function(e, t, n, r, o) {
        t = flock.midi.connection.expandPortSpec(t);
        var a = flock.midi.findPorts(e.inputs, t.input), i = flock.midi.findPorts(e.outputs, t.output), u = [];
        a && 0 < a.length ? flock.midi.connection.listen(a, r, u) : void 0 !== t.input && flock.midi.connection.logNoMatchedPorts("input", t), 
        i && 0 < i.length ? flock.midi.connection.bindSender(i, o, u) : void 0 !== t.output && flock.midi.connection.logNoMatchedPorts("output", t), 
        flock.midi.connection.fireReady(u, n);
    }, flock.midi.connection.close = function(e, t) {
        flock.midi.connection.stopListening(e.inputs, t);
    }, flock.midi.connection.logNoMatchedPorts = function(e, t) {
        fluid.log(fluid.logLevel.WARN, "No matching " + e + " ports were found for port specification: ", t[e]);
    }, flock.midi.connection.expandPortSpec = function(e) {
        if (void 0 !== e.input || void 0 !== e.output) return e;
        var t = {
            input: {},
            output: {}
        };
        return "number" == typeof e ? t.input = t.output = e : (flock.midi.connection.expandPortSpecProperty("manufacturer", e, t), 
        flock.midi.connection.expandPortSpecProperty("name", e, t)), t;
    }, flock.midi.connection.expandPortSpecProperty = function(e, t, n) {
        return n.input[e] = n.output[e] = t[e], n;
    }, flock.midi.connection.fireEvent = function(e, t) {
        var n = flock.midi.read(e.data), r = n.type ? t[n.type] : void 0;
        t.message.fire(n, e), "noteOn" !== n.type && "noteOff" !== n.type || t.note.fire(n, e), 
        r && r.fire(n, e);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.midi.controller", {
        gradeNames: [ "fluid.component" ],
        members: {
            controlMap: {
                expander: {
                    funcName: "flock.midi.controller.optimizeMIDIMap",
                    args: [ "{that}.options.controlMap" ]
                }
            },
            noteMap: {
                expander: {
                    funcName: "flock.midi.controller.optimizeNoteMap",
                    args: [ "{that}.options.noteMap" ]
                }
            }
        },
        controlMap: {},
        noteMap: {},
        components: {
            synthContext: {
                type: "flock.band"
            },
            connection: {
                type: "flock.midi.connection",
                options: {
                    ports: {
                        input: "*"
                    },
                    openImmediately: !0
                }
            }
        },
        invokers: {
            mapControl: {
                funcName: "flock.midi.controller.mapControl",
                args: [ "{arguments}.0", "{that}.synthContext", "{that}.controlMap" ]
            },
            mapNote: {
                funcName: "flock.midi.controller.mapNote",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.synthContext", "{that}.noteMap" ]
            }
        },
        events: {
            control: "{that}.connection.events.control",
            note: "{that}.connection.events.note",
            noteOn: "{that}.connection.events.noteOn",
            noteOff: "{that}.connection.events.noteOff"
        },
        listeners: {
            control: "{that}.mapControl({arguments}.0)",
            note: "{that}.mapNote(note, {arguments}.0)",
            noteOn: "{that}.mapNote(noteOn, {arguments}.0)",
            noteOff: "{that}.mapNote(noteOff, {arguments}.0)"
        }
    }), flock.midi.controller.optimizeMIDIMap = function(e) {
        var r = new Array(127);
        return fluid.each(e, function(e, t) {
            var n = Number(t);
            r[n] = fluid.makeArray(e);
        }), r;
    }, flock.midi.controller.optimizeNoteMap = function(e) {
        return {
            note: fluid.makeArray(e.note),
            noteOn: fluid.makeArray(e.noteOn),
            noteOff: fluid.makeArray(e.noteOff),
            velocity: fluid.makeArray(e.velocity)
        };
    }, flock.midi.controller.expandControlMapSpec = function(e, t) {
        return t.transform.id = e, t.valuePath = t.valuePath || "value", t.transform.ugen || (t.transform.ugen = "flock.ugen.value"), 
        t;
    }, flock.midi.controller.makeValueSynth = function(e, t, n) {
        var r = (n = flock.midi.controller.expandControlMapSpec(t, n)).transform, o = n.valuePath;
        flock.set(r, o, e);
        var a = flock.synth.value({
            synthDef: r
        });
        return n.valuePath = t + "." + o, a;
    }, flock.midi.controller.transformValue = function(e, t) {
        var n = t.transform;
        return "function" === typeof n ? n(e) : (t.transformSynth ? t.transformSynth.set(t.valuePath, e) : t.transformSynth = flock.midi.controller.makeValueSynth(e, "flock-midi-controller-in", t), 
        t.transformSynth.value());
    }, flock.midi.controller.setMappedValue = function(e, t, n) {
        e = void 0 !== t.value ? t.value : t.transform ? flock.midi.controller.transformValue(e, t) : e, 
        (n[t.synth] || n).set(t.input, e);
    }, flock.midi.controller.mapMIDIValue = function(e, t, n) {
        if (t && !(t.length < 1)) for (var r = 0; r < t.length; r++) {
            var o = t[r];
            flock.midi.controller.setMappedValue(e, o, n);
        }
    }, flock.midi.controller.mapControl = function(e, t, n) {
        var r = n[e.number], o = e.value;
        flock.midi.controller.mapMIDIValue(o, r, t);
    }, flock.midi.controller.mapNote = function(e, t, n, r) {
        var o = r[e], a = t.note, i = r.velocity, u = t.velocity;
        flock.midi.controller.mapMIDIValue(a, o, n), flock.midi.controller.mapMIDIValue(u, i, n);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.webAudio.nativeNodeManager", {
        gradeNames: [ "fluid.component" ],
        members: {
            outputNode: void 0,
            inputNodes: []
        },
        components: {
            scriptProcessor: {
                createOnEvent: "onCreateScriptProcessor",
                type: "flock.webAudio.scriptProcessor",
                options: {
                    nodeSpec: {
                        inputs: {
                            0: "{inputMerger}"
                        }
                    }
                }
            },
            merger: {
                type: "flock.webAudio.channelMerger"
            }
        },
        invokers: {
            connect: "{that}.events.onConnect.fire",
            disconnect: "{that}.events.onDisconnect.fire",
            createNode: {
                funcName: "flock.webAudio.createNode",
                args: [ "{audioSystem}.context", "{arguments}.0" ]
            },
            createInputNode: {
                funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            },
            createMediaStreamInput: {
                funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                args: [ "{that}", {
                    node: "MediaStreamSource",
                    args: [ "{arguments}.0" ]
                }, "{arguments}.1" ]
            },
            createMediaElementInput: {
                funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                args: [ "{that}", {
                    node: "MediaElementSource",
                    args: [ "{arguments}.0" ]
                }, "{arguments}.1" ]
            },
            createOutputNode: {
                funcName: "flock.webAudio.nativeNodeManager.createOutputNode",
                args: [ "{that}", "{arguments}.0" ]
            },
            insertInput: {
                funcName: "flock.webAudio.nativeNodeManager.insertInput",
                args: [ "{that}", "{audioSystem}.model", "{enviro}", "{arguments}.0", "{arguments}.1" ]
            },
            removeInput: {
                funcName: "flock.webAudio.nativeNodeManager.removeInput",
                args: [ "{arguments}.0", "{that}.inputNodes" ]
            },
            removeAllInputs: {
                funcName: "flock.webAudio.nativeNodeManager.removeAllInputs",
                args: "{that}.inputNodes"
            },
            insertOutput: {
                funcName: "flock.webAudio.nativeNodeManager.insertOutput",
                args: [ "{that}", "{arguments}.0" ]
            },
            removeOutput: {
                funcName: "flock.webAudio.nativeNodeManager.removeOutput",
                args: [ "{scriptProcessor}.node" ]
            }
        },
        events: {
            onStart: "{enviro}.events.onStart",
            onStop: "{enviro}.events.onStop",
            onReset: "{enviro}.events.onReset",
            onCreateScriptProcessor: null,
            onConnect: null,
            onDisconnectNodes: null,
            onDisconnect: null
        },
        listeners: {
            onCreate: [ "{that}.events.onCreateScriptProcessor.fire()", {
                func: "{that}.insertOutput",
                args: "{scriptProcessor}.node"
            } ],
            onStart: [ "{that}.connect()" ],
            onConnect: [ {
                this: "{merger}.node",
                method: "connect",
                args: [ "{scriptProcessor}.node" ]
            }, {
                this: "{that}.outputNode",
                method: "connect",
                args: [ "{audioSystem}.context.destination" ]
            }, {
                funcName: "flock.webAudio.nativeNodeManager.connectOutput",
                args: [ "{scriptProcessor}.node", "{that}.outputNode" ]
            } ],
            onStop: [ "{that}.disconnect()" ],
            onDisconnectNodes: [ {
                this: "{merger}.node",
                method: "disconnect",
                args: [ 0 ]
            }, {
                this: "{scriptProcessor}.node",
                method: "disconnect",
                args: [ 0 ]
            }, {
                this: "{that}.outputNode",
                method: "disconnect",
                args: [ 0 ]
            } ],
            "onDisconnect.onDisconnectNodes": {
                func: "{that}.events.onDisconnectNodes.fire"
            },
            onReset: [ "{that}.removeAllInputs()", "{that}.events.onCreateScriptProcessor.fire()" ],
            onDestroy: [ "{that}.events.onDisconnectNodes.fire()", "{that}.removeAllInputs()", "flock.webAudio.nativeNodeManager.disconnectOutput({that})" ]
        }
    }), flock.webAudio.nativeNodeManager.createInputNode = function(e, t, n) {
        var r = e.createNode(t);
        return e.insertInput(r, n);
    }, flock.webAudio.nativeNodeManager.createOutputNode = function(e, t) {
        var n = e.createNode(t);
        return e.insertOutput(n);
    }, flock.webAudio.nativeNodeManager.connectOutput = function(e, t) {
        e !== t && e.connect(t);
    }, flock.webAudio.nativeNodeManager.disconnectOutput = function(e) {
        e.outputNode && e.outputNode.disconnect(0);
    }, flock.webAudio.nativeNodeManager.removeAllInputs = function(e) {
        for (var t = 0; t < e.length; t++) {
            e[t].disconnect(0);
        }
        e.length = 0;
    }, flock.webAudio.nativeNodeManager.insertInput = function(e, t, n, r, o) {
        var a = t.numInputBuses;
        if (!(e.inputNodes.length >= a)) {
            var i = (o = void 0 === o ? n.busManager.acquireNextBus("input") : o) - t.chans;
            return e.inputNodes.push(r), r.connect(e.merger.node, 0, i), o;
        }
        flock.fail("There are too many input nodes connected to Flocking. The maximum number of input buses is currently set to " + a + ". Either remove an existing input node or increase Flockings numInputBuses option.");
    }, flock.webAudio.nativeNodeManager.removeInput = function(e, t) {
        var n = t.indexOf(e);
        -1 < n && t.splice(n, 1), e.disconnect(0);
    }, flock.webAudio.nativeNodeManager.insertOutput = function(e, t) {
        return flock.webAudio.nativeNodeManager.disconnectOutput(e), e.outputNode = t;
    }, flock.webAudio.nativeNodeManager.removeOutput = function(e) {
        flock.webAudio.nativeNodeManager.insertOutput(e);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.webAudio.outputManager", {
        gradeNames: [ "flock.outputManager" ],
        model: {
            isGenerating: !1,
            shouldInitSafari: flock.platform.browser.safari,
            audioSettings: {}
        },
        invokers: {
            bindAudioProcess: {
                funcName: "flock.webAudio.outputManager.bindAudioProcess",
                args: [ "{enviro}.nodeList", "{busManager}.buses", "{nativeNodeManager}", "{that}.model" ]
            },
            unbindAudioProcess: {
                funcName: "flock.webAudio.outputManager.unbindAudioProcess",
                args: [ "{nativeNodeManager}" ]
            }
        },
        listeners: {
            "{nativeNodeManager}.events.onConnect": [ "{that}.bindAudioProcess()" ],
            "{nativeNodeManager}.events.onDisconnect": [ "{that}.unbindAudioProcess()" ],
            onStart: [ {
                func: "{that}.applier.change",
                args: [ "isGenerating", !0 ]
            }, {
                priority: "last",
                funcName: "flock.webAudio.outputManager.safariStart",
                args: [ "{that}", "{audioSystem}.context", "{nativeNodeManager}.scriptProcessor.node" ]
            } ],
            onStop: [ {
                func: "{that}.applier.change",
                args: [ "isGenerating", !1 ]
            } ],
            "onDestroy.unbindAudioProcess": "{that}.unbindAudioProcess()"
        }
    }), flock.webAudio.outputManager.bindAudioProcess = function(e, t, n, r) {
        var o = n.scriptProcessor.node;
        o.model = r, o.nodeList = e, o.buses = t, o.inputNodes = n.inputNodes, o.onaudioprocess = flock.webAudio.outputManager.writeSamples;
    }, flock.webAudio.outputManager.unbindAudioProcess = function(e) {
        e.scriptProcessor.node.onaudioprocess = void 0;
    }, flock.webAudio.outputManager.writeSamples = function(e) {
        var t, n, r, o = this.inputNodes ? this.inputNodes.length : 0, a = this.nodeList.nodes, i = this.model.audioSettings, u = e.inputBuffer, l = e.outputBuffer, s = i.numBlocks, c = this.buses, f = i.numBuses, d = i.blockSize, p = i.chans, m = u.numberOfChannels;
        if (a.length < 1) for (t = 0; t < p; t++) flock.clearBuffer(l.getChannelData(t)); else for (n = 0; n < s; n++) {
            var g = n * d;
            if (flock.evaluate.clearBuses(c, f, d), 0 < o) for (t = 0; t < m; t++) {
                var h = u.getChannelData(t), v = c[p + t];
                for (r = 0; r < d; r++) v[r] = h[r + g];
            }
            for (flock.evaluate.synths(a), t = 0; t < p; t++) {
                var y = c[t], k = l.getChannelData(t);
                for (r = 0; r < d; r++) k[r + g] = y[r];
            }
        }
    }, flock.webAudio.outputManager.safariStart = function(e, t, n) {
        e.model.shouldInitSafari && (t.resume(), e.applier.change("shouldInitSafari", !1));
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var a = fluid.registerNamespace("jQuery");
    flock.ugenDefaults = function(e, t) {
        return 1 === arguments.length ? flock.ugenDefaults.store[e] : flock.ugenDefaults.store[e] = t;
    }, flock.ugenDefaults.store = {}, flock.isUGen = function(e) {
        return e && e.tags && -1 < e.tags.indexOf("flock.ugen");
    }, flock.aliasUGen = function(e, t, n, r) {
        var o = flock.get(e);
        flock.set(o, t, function(e, t, n) {
            return n = a.extend(!0, {}, r, n), o(e, t, n);
        }), flock.ugenDefaults(e + "." + t, n);
    }, flock.aliasUGens = function(e, t) {
        var n, r;
        for (n in t) r = t[n], flock.aliasUGen(e, n, {
            inputs: r.inputDefaults
        }, r.options);
    }, flock.copyUGenDefinition = function(e, t) {
        var n = flock.ugenDefaults(e), r = fluid.getGlobalValue(e);
        fluid.setGlobalValue(t, r), flock.ugenDefaults(t, fluid.copy(n));
    }, flock.krMul = function(e, t, n) {
        var r, o = n.output[0];
        for (r = 0; r < e; r++) t[r] = t[r] * o;
    }, flock.mul = function(e, t, n) {
        var r, o = n.output;
        for (r = 0; r < e; r++) t[r] = t[r] * o[r];
    }, flock.krAdd = function(e, t, n, r) {
        var o, a = r.output[0];
        for (o = 0; o < e; o++) t[o] = t[o] + a;
    }, flock.add = function(e, t, n, r) {
        var o, a = r.output;
        for (o = 0; o < e; o++) t[o] = t[o] + a[o];
    }, flock.krMulAdd = function(e, t, n, r) {
        var o, a = n.output[0], i = r.output;
        for (o = 0; o < e; o++) t[o] = t[o] * a + i[o];
    }, flock.mulKrAdd = function(e, t, n, r) {
        var o, a = n.output, i = r.output[0];
        for (o = 0; o < e; o++) t[o] = t[o] * a[o] + i;
    }, flock.krMulKrAdd = function(e, t, n, r) {
        var o, a = n.output[0], i = r.output[0];
        for (o = 0; o < e; o++) t[o] = t[o] * a + i;
    }, flock.mulAdd = function(e, t, n, r) {
        var o, a = n.output, i = r.output;
        for (o = 0; o < e; o++) t[o] = t[o] * a[o] + i[o];
    }, flock.onMulAddInputChanged = function(t) {
        var e, n = t.inputs.mul, r = t.inputs.add;
        n || r ? (e = n ? r ? n.rate !== flock.rates.AUDIO ? r.rate !== flock.rates.AUDIO ? flock.krMulKrAdd : flock.krMulAdd : r.rate !== flock.rates.AUDIO ? flock.mulKrAdd : flock.mulAdd : n.rate !== flock.rates.AUDIO ? flock.krMul : flock.mul : r.rate !== flock.rates.AUDIO ? flock.krAdd : flock.add, 
        t.mulAddFn = e, t.mulAdd = function(e) {
            t.mulAddFn(e, t.output, t.inputs.mul, t.inputs.add);
        }) : t.mulAdd = t.mulAddFn = flock.noOp;
    }, flock.ugen = function(e, t, n) {
        var u = {
            enviro: (n = n || {}).enviro || flock.environment,
            rate: n.rate || flock.rates.AUDIO,
            inputs: e,
            output: t,
            options: n,
            model: n.model || {
                unscaledValue: 0,
                value: 0
            },
            multiInputs: {},
            tags: [ "flock.ugen" ]
        };
        return u.lastOutputIdx = u.output.length - 1, u.get = function(e) {
            return flock.input.get(u.inputs, e);
        }, u.set = function(e, t) {
            return flock.input.set(u.inputs, e, t, u, function(e) {
                if (null != e) return flock.parse.ugenDef(e, u.enviro, {
                    audioSettings: u.options.audioSettings,
                    buses: u.buses,
                    buffers: u.buffers
                });
            });
        }, u.input = function(e, t) {
            return e ? "string" == typeof e ? arguments.length < 2 ? u.get(e) : u.set(e, t) : flock.isIterable(e) ? u.get(e) : u.set(e, t) : void 0;
        }, u.calculateStrides = function() {
            var e, t, n, r = u.model, o = u.options.strideInputs, a = u.inputs;
            if (r.strides = r.strides || {}, o) for (e = 0; e < o.length; e++) (n = a[t = o[e]]) ? r.strides[t] = n.rate === flock.rates.AUDIO ? 1 : 0 : fluid.log(fluid.logLevel.WARN, "An invalid input ('" + t + "') was found on a unit generator: " + u);
        }, u.collectMultiInputs = function() {
            var e, t, n, r, o = u.options.multiInputNames, a = u.multiInputs;
            for (e = 0; e < o.length; e++) (n = a[t = o[e]]) ? n.length = 0 : n = a[t] = [], 
            r = u.inputs[t], flock.ugen.collectMultiInputs(r, n);
        }, u.onInputChanged = function(e) {
            var t = u.options.multiInputNames;
            flock.onMulAddInputChanged(u), u.options.strideInputs && u.calculateStrides(), !t || e && !t.indexOf(e) || u.collectMultiInputs();
        }, u.init = function() {
            var e, t, n, r = fluid.makeArray(u.options.tags), o = u.model, a = u.options;
            for (e = 0; e < r.length; e++) u.tags.push(r[e]);
            if (t = a.audioSettings = a.audioSettings || u.enviro.audioSystem.model, o.sampleRate = a.sampleRate || t.rates[u.rate], 
            o.nyquistRate = o.sampleRate, o.blockSize = u.rate === flock.rates.AUDIO ? t.blockSize : 1, 
            o.sampleDur = 1 / o.sampleRate, u.interpolate = flock.interpolate.none, a.interpolation) {
                var i = flock.interpolate[a.interpolation];
                i ? u.interpolate = i : fluid.log(fluid.logLevel.IMPORTANT, "An invalid interpolation type of '" + a.interpolation + "' was specified. Defaulting to none.");
            }
            u.rate === flock.rates.DEMAND && u.inputs.freq && (n = flock.parse.ugenDefForConstantValue(1), 
            u.inputs.freq = flock.parse.ugenDef(n, u.enviro));
        }, u.init(), u;
    }, flock.ugen.collectMultiInputs = function(e, t) {
        flock.isIterable(e) || (e = e = fluid.makeArray(e));
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            flock.ugen.collectChannelsForInput(r, t);
        }
        return t;
    }, flock.ugen.collectChannelsForInput = function(e, t) {
        var n, r = flock.hasTag(e, "flock.ugen.multiChannelOutput") ? e.output : [ e.output ];
        for (n = 0; n < r.length; n++) t.push({
            rate: e.rate,
            output: r[n]
        });
        return t;
    }, flock.ugen.lastOutputValue = function(e, t) {
        return t[e - 1];
    }, flock.ugen.buffer = function(r) {
        r.onBufferInputChanged = function(e) {
            var t = r.model, n = r.inputs;
            t.bufDef === n.buffer && "buffer" !== e || (t.bufDef = n.buffer, flock.parse.bufferForDef(t.bufDef, r, r.enviro));
        }, r.setBuffer = function(e) {
            r.buffer = e, r.onBufferReady && r.onBufferReady(e);
        }, r.initBuffer = function() {
            r.buffer = r.model.bufDef = flock.bufferDesc({
                format: {
                    sampleRate: r.options.audioSettings.rates.audio
                },
                data: {
                    channels: [ new Float32Array(r.output.length) ]
                }
            });
        };
    }, flock.ugen.value = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.value = function() {
            return o.model.value;
        }, o.dynamicGen = function(e) {
            for (var t = o.output, n = o.model, r = 0; r < e; r++) t[r] = n.unscaledValue;
            o.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, t);
        }, o.onInputChanged = function() {
            var e = o.inputs;
            o.model.unscaledValue = e.value, "constant" !== o.rate ? o.gen = o.dynamicGen : o.gen = void 0, 
            flock.onMulAddInputChanged(o), o.dynamicGen(1);
        }, o.onInputChanged(), o;
    }, flock.ugenDefaults("flock.ugen.value", {
        rate: "control",
        inputs: {
            value: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: 1,
                value: 1
            },
            tags: [ "flock.ugen.valueType" ]
        }
    }), flock.ugen.silence = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.onInputChanged = function() {
            for (var e = 0; e < r.output.length; e++) r.output[e] = 0;
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.silence", {
        rate: "constant"
    }), flock.ugen.passThrough = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.gen = function(e) {
            var t, n, r = i.model, o = i.inputs.source.output, a = i.output;
            for (t = 0; t < o.length; t++) a[t] = n = o[t];
            for (;t < e; t++) a[t] = n = 0;
            r.unscaledValue = n, i.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, a);
        }, i.onInputChanged(), i;
    }, flock.ugenDefaults("flock.ugen.passThrough", {
        rate: "audio",
        inputs: {
            source: null,
            mul: null,
            add: null
        }
    }), flock.ugen.out = function(e, t, n) {
        var h = flock.ugen(e, t, n);
        return h.gen = function(e) {
            var t, n, r, o, a, i, u, l, s, c, f = h.model, d = h.multiInputs.sources, p = h.options.buses, m = h.inputs.bus.output[0], g = h.inputs.expand.output[0];
            if (t = d.length, n = Math.max(g, t), !(t < 1)) {
                for (r = 0; r < n; r++) {
                    for (i = (a = d[r % t]).rate, u = p[m + r], l = i === flock.rates.AUDIO ? 1 : 0, 
                    o = s = 0; o < e; o++, s += l) c = a.output[s], u[o] = u[o] + c;
                    h.mulAddFn(e, u, h.inputs.mul, h.inputs.add);
                }
                f.value = f.unscaledValue = c;
            }
        }, h.init = function() {
            h.sourceBuffers = [], h.onInputChanged();
        }, h.init(), h;
    }, flock.ugenDefaults("flock.ugen.out", {
        rate: "audio",
        inputs: {
            sources: null,
            bus: 0,
            expand: 2
        },
        ugenOptions: {
            tags: [ "flock.ugen.outputType" ],
            multiInputNames: [ "sources" ]
        }
    }), flock.ugen.valueOut = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.arraySourceGen = function() {
            var e, t = r.model, n = r.inputs.sources;
            for (e = 0; e < n.length; e++) t.value[e] = n[e].output[0];
        }, r.ugenSourceGen = function() {
            r.model.value = r.model.unscaledValue = r.inputs.sources.output[0];
        }, r.onInputChanged = function() {
            var e = r.model, t = r.inputs.sources;
            flock.isIterable(t) ? (r.gen = r.arraySourceGen, e.value = new Float32Array(t.length), 
            e.unscaledValue = e.value) : r.gen = r.ugenSourceGen;
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.valueOut", {
        rate: "control",
        inputs: {
            sources: null
        },
        ugenOptions: {
            model: {
                unscaledValue: null,
                value: null
            },
            tags: [ "flock.ugen.outputType", "flock.ugen.valueType" ]
        }
    }), flock.ugen.in = function(e, t, n) {
        var l = flock.ugen(e, t, n);
        return l.singleBusGen = function(e) {
            var t = l.model, n = l.output;
            flock.ugen.in.readBus(e, n, l.inputs.bus, l.options.buses), t.unscaledValue = flock.ugen.lastOutputValue(e, n), 
            l.mulAdd(e), t.value = flock.ugen.lastOutputValue(e, n);
        }, l.multiBusGen = function(e) {
            var t, n, r, o = l.model, a = l.inputs.bus, i = l.options.buses, u = l.output;
            for (t = 0; t < e; t++) {
                for (n = r = 0; n < a.length; n++) r += i[0 | a[n].output[0]][t];
                u[t] = r;
            }
            o.unscaledValue = r, l.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, u);
        }, l.onInputChanged = function() {
            l.gen = flock.isIterable(l.inputs.bus) ? l.multiBusGen : l.singleBusGen, flock.onMulAddInputChanged(l);
        }, l.onInputChanged(), l;
    }, flock.ugen.in.readBus = function(e, t, n, r) {
        var o, a = r[0 | n.output[0]];
        for (o = 0; o < e; o++) t[o] = a[o];
    }, flock.ugenDefaults("flock.ugen.in", {
        rate: "audio",
        inputs: {
            bus: 0,
            mul: null,
            add: null
        }
    }), flock.ugen.audioIn = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.gen = function(e) {
            var t, n, r = i.model, o = i.output, a = i.bus;
            for (t = 0; t < e; t++) o[t] = n = a[t];
            r.unscaledValue = n, i.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, o);
        }, i.onInputChanged = function() {
            flock.onMulAddInputChanged(i);
        }, i.init = function() {
            var e = i.enviro.audioSystem.inputDeviceManager.openAudioDevice(n);
            i.bus = i.options.buses[e], i.onInputChanged();
        }, i.init(), i;
    }, flock.ugenDefaults("flock.ugen.audioIn", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.blit = function(e) {
        var t;
        return 2 <= e ? 0 : 1 <= e ? .16666666666666666 * (t = 2 - e) * t * t : 0 <= e ? .6666666666666666 - (t = e * e) + .5 * t * e : -1 <= e ? .6666666666666666 - (t = e * e) - .5 * t * e : -2 <= e ? .16666666666666666 * (t = 2 + e) * t * t : 0;
    }, flock.blit.period = function(e, t) {
        var n = e / t;
        return n < 1 ? 1 : n;
    }, flock.blit.updatePeriodState = function(e, t) {
        e.freq = t < 1e-6 ? 1e-6 : t, e.d0 = flock.blit.period(e.sampleRate, e.freq);
    }, flock.ugen.blit = function(e, t, n) {
        var u = flock.ugen(e, t, n);
        return u.gen = function(e) {
            var t, n, r = u.model, o = u.output, a = u.inputs.freq.output[0], i = r.phase;
            for (t = 0; t < e; t++) (i -= 1) < -2 && (flock.blit.updatePeriodState(r, a), i += r.d0), 
            n = flock.blit(i), o[t] = n;
            r.phase = i, r.unscaledValue = n, u.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, o);
        }, u.init = function() {
            u.onInputChanged();
        }, u.init(), u;
    }, flock.ugenDefaults("flock.ugen.blit", {
        rate: "audio",
        inputs: {
            freq: 440,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: -2,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.saw = function(e, t, n) {
        var l = flock.ugen(e, t, n);
        return l.gen = function(e) {
            var t, n = l.model, r = l.output, o = l.inputs.freq.output[0], a = 1 - l.inputs.leakRate.output[0], i = n.phase, u = n.unscaledValue;
            for (void 0 === i && (flock.ugen.saw.updatePeriodState(n, o), i = n.d0 / 2), t = 0; t < e; t++) (i -= 1) < -2 && (flock.ugen.saw.updatePeriodState(n, o), 
            i += n.d0), r[t] = u = flock.blit(i) - n.dcOffset + a * u;
            n.phase = i, n.unscaledValue = u, l.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, l.init = function() {
            l.onInputChanged();
        }, l.init(), l;
    }, flock.ugen.saw.updatePeriodState = function(e, t) {
        flock.blit.updatePeriodState(e, t), e.dcOffset = 1 / e.d0;
    }, flock.ugenDefaults("flock.ugen.saw", {
        rate: "audio",
        inputs: {
            freq: 440,
            leakRate: .01,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: void 0,
                dcOffset: void 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.square = function(e, t, n) {
        var l = flock.ugen(e, t, n);
        return l.gen = function(e) {
            var t, n = l.model, r = l.output, o = l.inputs.freq.output[0], a = 1 - l.inputs.leakRate.output[0], i = n.phase, u = n.unscaledValue;
            for (void 0 === i && (flock.ugen.square.updatePeriodState(n, o), i = n.phaseResetValue), 
            t = 0; t < e; t++) r[t] = u = flock.blit(i) * n.sign + a * u, i < -2 && (flock.ugen.square.updatePeriodState(n, o), 
            i += n.phaseResetValue), i -= 1;
            n.phase = i, n.unscaledValue = u, l.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, l.init = function() {
            l.onInputChanged();
        }, l.init(), l;
    }, flock.ugen.square.updatePeriodState = function(e, t) {
        flock.blit.updatePeriodState(e, t), e.phaseResetValue = e.d0 / 2, e.sign *= -1;
    }, flock.ugenDefaults("flock.ugen.square", {
        rate: "audio",
        inputs: {
            freq: 440,
            leakRate: .01,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: void 0,
                unscaledValue: .5,
                value: .5,
                sign: 1
            }
        }
    }), flock.ugen.tri = function(e, t, n) {
        var c = flock.ugen(e, t, n);
        return c.gen = function(e) {
            var t, n, r = c.model, o = c.output, a = c.inputs.freq.output[0], i = 1 - c.inputs.leakRate.output[0], u = r.phase, l = r.unscaledValue, s = r.secondPrevVal;
            for (void 0 === u && (flock.ugen.tri.updatePeriodState(r, a), u = r.d0 / 4), t = 0; t < e; t++) s = n = (l = flock.blit(u) * r.sign + i * l) + i * s, 
            o[t] = n * r.ampScale, (u -= 1) < -2 && (flock.ugen.tri.updatePeriodState(r, a), 
            u += r.phaseResetValue);
            r.phase = u, r.unscaledValue = l, r.secondPrevVal = s, c.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, o);
        }, c.init = function() {
            c.onInputChanged();
        }, c.init(), c;
    }, flock.ugen.tri.updatePeriodState = function(e, t) {
        flock.blit.updatePeriodState(e, t), e.phaseResetValue = e.d0 / 2, e.ampScale = 2 / e.d0, 
        e.sign *= -1;
    }, flock.ugenDefaults("flock.ugen.tri", {
        rate: "audio",
        inputs: {
            freq: 440,
            leakRate: .01,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: void 0,
                value: .5,
                unscaledValue: .5,
                secondPrevVal: 0,
                sign: 1,
                ampScale: void 0,
                phaseResetValue: void 0
            }
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.playBuffer = function(y, e, t) {
        var k = flock.ugen(y, e, t);
        return k.defaultKrTriggerGen = function(e) {
            var t, n, r = k.model, o = k.output, a = k.inputs.channel.output[0], i = k.buffer.data.channels[a], u = r.idx, l = k.inputs.loop.output[0], s = y.trigger.output[0];
            for (0 < s && r.prevTrig <= 0 && (u = 0), r.prevTrig = s, t = 0; t < e; t++) {
                if (u > r.lastIdx) {
                    if (!(0 < l && 0 < s)) {
                        o[t] = n = 0;
                        continue;
                    }
                    u = 0;
                }
                n = k.interpolate(u, i), o[t] = n, u++;
            }
            r.idx = u, r.unscaledValue = n, k.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, o);
        }, k.otherwiseGen = function(e) {
            var t, n, r, o, a, i, u, l = k.model, s = k.output, c = k.inputs.channel.output[0], f = k.inputs.speed.output, d = k.buffer.data.channels[c], p = y.trigger.output, m = l.idx, g = k.inputs.loop.output[0], h = k.inputs.start.output[0] * l.lastIdx | 0, v = k.inputs.end.output[0] * l.lastIdx | 0;
            for (r = n = t = 0; t < e; t++, n += l.strides.trigger, r += l.strides.speed) {
                if (o = p[n], a = l.prevTrig, i = f[r], 0 < (l.prevTrig = o) && a <= 0) m = flock.ugen.playBuffer.resetIndex(i, h, v); else if (m < h || v < m) {
                    if (!(0 < g && 0 < o)) {
                        s[t] = u = 0;
                        continue;
                    }
                    m = flock.ugen.playBuffer.resetIndex(i, h, v);
                }
                u = k.interpolate(m, d), s[t] = u, m += l.stepSize * i;
            }
            l.idx = m, l.unscaledValue = u, k.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, s);
        }, k.onInputChanged = function(e) {
            var t = k.inputs, n = t.speed, r = t.start, o = t.end, a = t.trigger;
            k.onBufferInputChanged(e), k.gen = n.rate === flock.rates.CONSTANT && 1 === n.output[0] && r.rate === flock.rates.CONSTANT && 0 === r.output[0] && o.rate === flock.rates.CONSTANT && 1 === o.output[0] && a.rate !== flock.rates.AUDIO ? k.defaultKrTriggerGen : k.otherwiseGen, 
            k.calculateStrides(), flock.onMulAddInputChanged(k);
        }, k.onBufferReady = function() {
            var e = k.model, t = k.inputs.end.output[0], n = k.inputs.channel.output[0], r = k.buffer.data.channels[n].length;
            e.idx = t * r | 0, e.lastIdx = r - 1, e.stepSize = k.buffer.format.sampleRate / e.sampleRate;
        }, k.init = function() {
            flock.ugen.buffer(k), k.initBuffer(), k.onInputChanged();
        }, k.init(), k;
    }, flock.ugen.playBuffer.resetIndex = function(e, t, n) {
        return 0 < e ? t : n;
    }, flock.ugenDefaults("flock.ugen.playBuffer", {
        rate: "audio",
        inputs: {
            channel: 0,
            loop: 0,
            speed: 1,
            start: 0,
            end: 1,
            trigger: 1,
            buffer: null,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                finished: !1,
                unscaledValue: 0,
                value: 0,
                idx: 0,
                stepSize: 0,
                prevTrig: 0,
                channel: void 0
            },
            strideInputs: [ "trigger", "speed" ],
            interpolation: "linear"
        }
    }), flock.ugen.readBuffer = function(e, t, n) {
        var d = flock.ugen(e, t, n);
        return d.gen = function(e) {
            var t, n, r, o, a = d.model, i = a.strides.phase, u = d.output, l = d.inputs.channel.output[0], s = d.inputs.phase.output, c = d.buffer.data.channels[l], f = c.length;
            for (t = r = 0; t < e; t++, r += i) n = s[r] * f, o = d.interpolate(n, c), u[t] = o;
            a.unscaledValue = o, d.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, d.onInputChanged = function(e) {
            d.onBufferInputChanged(e), d.calculateStrides(), flock.onMulAddInputChanged(d);
        }, d.init = function() {
            flock.ugen.buffer(d), d.initBuffer(), d.onInputChanged();
        }, d.init(), d;
    }, flock.ugenDefaults("flock.ugen.readBuffer", {
        rate: "audio",
        inputs: {
            buffer: null,
            channel: 0,
            phase: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                channel: void 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "phase" ],
            interpolation: "linear"
        }
    }), flock.ugen.writeBuffer = function(e, t, n) {
        var y = flock.ugen(e, t, n);
        return y.gen = function(e) {
            var t, n, r, o = y.model, a = y.output, i = y.inputs, u = y.buffer, l = y.multiInputs.sources, s = l.length, c = u.data.channels, f = u.format.numSampleFrames, d = i.start.output[0], p = i.loop.output[0];
            for (o.prevStart !== d && (o.prevStart = d, o.writeIdx = Math.floor(d)), t = 0; t < s; t++) {
                var m = l[t].output, g = c[t], h = a[t];
                for (n = o.writeIdx, r = 0; r < e; r++) {
                    var v = m[r];
                    h && (h[r] = v), n < f ? g[n] = v : 0 < p && (g[n = Math.floor(d)] = v), n++;
                }
            }
            o.writeIdx = n, y.mulAdd(e);
        }, y.createBuffer = function(e, t) {
            var n, r = e.options, o = r.audioSettings, a = r.buffers, i = e.multiInputs.sources.length, u = Math.round(e.options.duration * o.rates.audio), l = new Array(i);
            for (n = 0; n < i; n++) l[n] = new Float32Array(u);
            var s = flock.bufferDesc(l, o.rates.audio, i);
            return t.id && (s.id = t.id, a[t.id] = s), s;
        }, y.setupBuffer = function(e) {
            var t;
            return (e = "string" == typeof e ? {
                id: e
            } : e).id && (t = y.options.buffers[e.id]), y.buffer = t || y.createBuffer(y, e), 
            y.buffer;
        }, y.onInputChanged = function(e) {
            e ? "sources" === e ? y.collectMultiInputs() : "buffer" === e && y.setupBuffer(y.inputs.buffer) : (y.collectMultiInputs(), 
            y.setupBuffer(y.inputs.buffer)), flock.onMulAddInputChanged(y);
        }, y.init = function() {
            y.onInputChanged();
        }, y.init(), y;
    }, flock.ugenDefaults("flock.ugen.writeBuffer", {
        rate: "audio",
        inputs: {
            sources: null,
            buffer: null,
            start: 0,
            loop: 0
        },
        ugenOptions: {
            model: {
                prevStart: void 0,
                writeIdx: 0
            },
            tags: [ "flock.ugen.multiChannelOutput" ],
            numOutputs: 2,
            multiInputNames: [ "sources" ],
            duration: 600
        }
    }), flock.ugen.bufferDuration = function(e, t, n) {
        var l = flock.ugen(e, t, n);
        return l.krGen = function(e) {
            var t, n = l.model, r = l.output, o = l.inputs.channel.output[0], a = l.buffer.data.channels[o], i = l.buffer.format.sampleRate, u = a.length / i;
            for (t = 0; t < e; t++) r[t] = u;
            n.unscaledValue = u, l.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, l.onInputChanged = function(e) {
            flock.onMulAddInputChanged(l), l.onBufferInputChanged(e);
        }, l.onBufferReady = function() {
            l.krGen(1);
        }, l.init = function() {
            var e = l.rate;
            l.gen = e === flock.rates.CONTROL || e === flock.rates.AUDIO ? l.krGen : void 0, 
            l.output[0] = 0, flock.ugen.buffer(l), l.initBuffer(), l.onInputChanged();
        }, l.init(), l;
    }, flock.ugenDefaults("flock.ugen.bufferDuration", {
        rate: "constant",
        inputs: {
            buffer: null,
            channel: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.bufferLength = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.krGen = function(e) {
            var t, n = i.model, r = i.output, o = i.inputs.channel.output[0], a = i.buffer.data.channels[o].length;
            for (t = 0; t < e; t++) r[t] = a;
            n.unscaledValue = a, i.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, i.onInputChanged = function(e) {
            flock.onMulAddInputChanged(i), i.onBufferInputChanged(e);
        }, i.onBufferReady = function() {
            i.krGen(1);
        }, i.init = function() {
            var e = i.rate;
            i.gen = e === flock.rates.CONTROL || e === flock.rates.AUDIO ? i.krGen : void 0, 
            i.output[0] = 0, flock.ugen.buffer(i), i.initBuffer(), i.onInputChanged();
        }, i.init(), i;
    }, flock.ugenDefaults("flock.ugen.bufferLength", {
        rate: "constant",
        inputs: {
            buffer: null,
            channel: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.bufferPhaseStep = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.krGen = function(e) {
            var t, n = i.model, r = i.output, o = n.unscaledValue;
            for (t = 0; t < e; t++) r[t] = o;
            i.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, i.onInputChanged = function(e) {
            i.onBufferInputChanged(e), flock.onMulAddInputChanged(i);
        }, i.onBufferReady = function(e) {
            var t = i.model, n = i.inputs.channel.output[0], r = e.data.channels[n], o = i.options.audioSettings.rates.audio, a = i.buffer.format.sampleRate || o;
            t.scale = a / o, i.output[0] = t.unscaledValue = 1 / (r.length * t.scale);
        }, i.init = function() {
            var e = i.rate;
            i.gen = e === flock.rates.CONTROL || e === flock.rates.AUDIO ? i.krGen : void 0, 
            i.output[0] = 0, flock.ugen.buffer(i), i.initBuffer(), i.onInputChanged();
        }, i.init(), i;
    }, flock.ugenDefaults("flock.ugen.bufferPhaseStep", {
        rate: "constant",
        inputs: {
            buffer: null,
            channel: 0
        },
        ugenOptions: {
            model: {
                scale: 1,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.sampleRate = function(e, t, n) {
        var r = flock.ugen(e, t, n), o = r.model;
        return r.output[0] = o.value = o.unscaledValue = r.options.audioSettings.rates.audio, 
        r;
    }, flock.ugenDefaults("flock.ugen.sampleRate", {
        rate: "constant",
        inputs: {}
    }), flock.ugen.triggerBuffers = function(e, t, n) {
        var O = flock.ugen(e, t, n);
        return O.gen = function(e) {
            var t, n, r, o, a, i, u, l, s, c, f = O.model, d = f.strides, p = O.output, m = O.inputs, g = O.buffers, h = g.length - 1, v = f.prevTrigger, y = f.maxVoices, k = f.activeVoices, b = f.freeVoices, x = m.trigger.output, S = d.trigger, w = 0, C = m.bufferIndex.output, A = d.bufferIndex, N = 0, T = m.speed.output, I = d.speed, M = 0, P = O.inputs.channel.output[0];
            for (t = 0; t < e; t++) {
                if (0 < (n = x[w]) && v <= 0 && k.length < y) {
                    if (o = Math.round(C[N] * h), o = Math.max(0, o), !(a = g[o = Math.min(o, h)])) continue;
                    (r = b.pop()).speed = T[M], r.currentIdx = 0, r.writePos = t, r.buffer = a.data.channels[P], 
                    k.push(r);
                }
                w += S, M += I, N += A, p[t] = 0, v = n;
            }
            for (i = 0; i < k.length; ) {
                for (u = (r = k[i]).buffer, l = Math.min(u.length - r.currentIdx, e), s = r.writePos; s < l; s++) c = O.interpolate ? O.interpolate(r.currentIdx, u) : u[0 | r.currentIdx], 
                p[s] += c, r.currentIdx += r.speed;
                r.currentIdx >= u.length ? (b.push(r), k.splice(i, 1)) : (r.writePos = 0, i++);
            }
            f.prevTrigger = v, f.unscaledValue = c, O.mulAdd(e), f.value = flock.ugen.lastOutputValue(e, p);
        }, O.init = function() {
            O.buffers = [], O.allocateVoices(), O.onInputChanged();
        }, O.allocateVoices = function() {
            for (var e = 0; e < O.model.maxVoices; e++) O.model.freeVoices.push({});
        }, O.onInputChanged = function() {
            var e, t, n = O.enviro.buffers, r = O.options.bufferIDs;
            for (e = O.buffers.length = 0; e < r.length; e++) t = n[r[e]], O.buffers.push(t);
            flock.onMulAddInputChanged(O), O.calculateStrides();
        }, O.init(), O;
    }, flock.ugenDefaults("flock.ugen.triggerBuffers", {
        inputs: {
            trigger: 0,
            bufferIndex: 0,
            speed: 1,
            channel: 0
        },
        ugenOptions: {
            model: {
                prevTrigger: 0,
                maxVoices: 128,
                activeVoices: [],
                freeVoices: [],
                channel: 0
            },
            bufferIDs: [],
            strideInputs: [ "trigger", "bufferIndex", "speed" ]
        }
    }), flock.ugen.chopBuffer = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return flock.ugen.buffer(r), r.gen = function(e) {
            var t = r.model, n = r.output;
            flock.ugen.chopBuffer.prepareVoices(r, e), flock.ugen.chopBuffer.generateSamplesForAllVoices(r, e), 
            t.unscaledValue = flock.ugen.lastOutputValue(e, n), r.mulAdd(e), t.value = flock.ugen.lastOutputValue(e, n);
        }, r.onInputChanged = function(e) {
            r.onBufferInputChanged(e), r.calculateStrides(), flock.onMulAddInputChanged(r);
        }, r.onBufferReady = function() {
            var e = r.model;
            e.stepSize = r.buffer.format.sampleRate / e.sampleRate, e.lastIdx = r.buffer.format.numSampleFrames - 1;
        }, r.init = function() {
            flock.ugen.chopBuffer.initVoices(r), r.initBuffer(), r.onInputChanged();
            var e = r.buffer.data.channels[r.inputs.channel.output[0]];
            r.model.lastIdx = e.length - 1;
        }, r.init(), r;
    }, flock.ugen.chopBuffer.initVoice = function() {
        return {
            currentStage: 4,
            samplesRemaining: 0,
            duration: 0,
            attackDur: 0,
            releaseDur: 0,
            hasTriggeredNextVoice: !1,
            idx: 0,
            stages: [ {
                samplesRemaining: 0
            }, {
                samplesRemaining: 0
            }, {
                samplesRemaining: 0
            }, {
                samplesRemaining: 0
            } ]
        };
    }, flock.ugen.chopBuffer.initVoices = function(e) {
        for (var t = e.model, n = 0; n < e.options.maxVoices; n++) {
            var r = flock.ugen.chopBuffer.initVoice(e);
            t.freeVoices[n] = r;
        }
    }, flock.ugen.chopBuffer.randomIndex = flock.randomValue, flock.ugen.chopBuffer.randomStartIndex = function(e) {
        var t = e.model, n = e.inputs, r = n.end.output[0] - t.inputState.numDurationSamps;
        return r = Math.max(0, r), flock.ugen.chopBuffer.randomIndex(n.start.output[0], r) * t.lastIdx;
    }, flock.ugen.chopBuffer.allocateVoice = function(e) {
        var t = e.model, n = t.stageSampleState;
        if (!(t.freeVoices.length < 1)) {
            var r = t.freeVoices.pop();
            t.activeVoices.push(r);
            for (var o = 0; o < n.length; o++) {
                r.stages[o].samplesRemaining = n[o];
            }
            return r.hasTriggeredNextVoice = !1, r.currentStage = flock.ugen.chopBuffer.stages.WAIT, 
            r.samplesRemaining = t.inputState.numDurationSamps + t.inputState.numGapSamps, r.idx = flock.ugen.chopBuffer.randomStartIndex(e), 
            r;
        }
    }, flock.ugen.chopBuffer.updateVoiceState = function(e, t) {
        for (var n = e.model, r = n.stageSampleState, o = n.inputState, a = t.currentStage; a < r.length; a++) {
            var i = t.stages[a], u = r[a];
            i.samplesRemaining > u && (i.samplesRemaining = u);
        }
        t.samplesRemaining > o.numDurationSamps && (t.samplesRemaining = o.numDurationSamps, 
        0 === t.currentStage && (t.samplesRemaining += o.numGapSamps));
    }, flock.ugen.chopBuffer.triggerNextVoice = function(e, t, n, r, o) {
        var a = t.samplesRemaining + o;
        a < n && (e.model.stageSampleState[0] = a, flock.ugen.chopBuffer.allocateVoice(e), 
        t.hasTriggeredNextVoice = !0);
    }, flock.ugen.chopBuffer.envLength = function(e, t, n) {
        return Math.floor((t < e ? t : e) * n);
    }, flock.ugen.chopBuffer.deactivateVoice = function(e, t) {
        var n = e.model, r = n.activeVoices.indexOf(t);
        -1 < r && n.activeVoices.splice(r, 1), n.freeVoices.push(t);
    }, flock.ugen.chopBuffer.prepareVoice = function(e, t, n) {
        flock.ugen.chopBuffer.updateVoiceState(e, t), t.currentStage < flock.ugen.chopBuffer.stages.DONE ? t.hasTriggeredNextVoice || flock.ugen.chopBuffer.triggerNextVoice(e, t, n) : flock.ugen.chopBuffer.deactivateVoice(e, t);
    }, flock.ugen.chopBuffer.durationSamples = function(e, t, n) {
        return 0 === t ? n.lastIdx : Math.floor(e / t * n.sampleRate);
    }, flock.ugen.chopBuffer.updateInputState = function(e, t) {
        var n = t.inputState, r = e.amount.output[0], o = e.minDuration.output[0], a = o / 2;
        return n.numDurationSamps = flock.ugen.chopBuffer.durationSamples(o, r, t), n.numAttackSamps = flock.ugen.chopBuffer.envLength(e.attack.output[0], a, t.sampleRate), 
        n.numReleaseSamps = flock.ugen.chopBuffer.envLength(e.release.output[0], a, t.sampleRate), 
        n.numSustainSamps = n.numDurationSamps - n.numAttackSamps - n.numReleaseSamps, n.numGapSamps = Math.floor(e.gap.output[0] * t.sampleRate), 
        n;
    }, flock.ugen.chopBuffer.prepareVoices = function(e, t) {
        var n = e.model;
        flock.ugen.chopBuffer.updateInputState(e.inputs, n), n.stageSampleState[0] = n.inputState.numGapSamps, 
        n.stageSampleState[1] = n.inputState.numAttackSamps, n.stageSampleState[3] = n.inputState.numReleaseSamps, 
        n.stageSampleState[2] = n.inputState.numSustainSamps;
        for (var r = 0; r < n.activeVoices.length; r++) {
            var o = n.activeVoices[r];
            flock.ugen.chopBuffer.prepareVoice(e, o, t);
        }
        0 === n.activeVoices.length && flock.ugen.chopBuffer.allocateVoice(e);
    }, flock.ugen.chopBuffer.generateSamplesForVoice = function(e, t, n) {
        for (var r = e.model, o = e.output, a = e.inputs, i = a.speed.output, u = e.buffer.data.channels[a.channel.output[0]], l = 0, s = 0; l < Math.min(n, t.samplesRemaining) && !(t.currentStage >= flock.ugen.chopBuffer.stages.DONE); l++, 
        s += r.strides.speed) {
            var c = r.stepSize * i[s], f = t.stages[t.currentStage];
            o[l] += e.interpolate(t.idx, u), t.samplesRemaining -= c, f.samplesRemaining -= c, 
            t.idx += c, f.samplesRemaining <= 0 && t.currentStage++;
        }
        t.samplesRemaining <= 0 && t.currentStage < flock.ugen.chopBuffer.stages.DONE && (t.currentStage = flock.ugen.chopBuffer.stages.DONE);
    }, flock.ugen.chopBuffer.generateSamplesForAllVoices = function(e, t) {
        var n = e.model;
        flock.clearBuffer(e.output);
        for (var r = n.activeVoices.length - 1; 0 <= r; r--) {
            var o = n.activeVoices[r];
            flock.ugen.chopBuffer.generateSamplesForVoice(e, o, t);
        }
    }, flock.ugen.chopBuffer.stages = {
        WAIT: 0,
        ATTACK: 1,
        SUSTAIN: 2,
        RELEASE: 3,
        DONE: 4
    }, flock.ugenDefaults("flock.ugen.chopBuffer", {
        rate: "audio",
        inputs: {
            buffer: null,
            channel: 0,
            start: 0,
            end: 1,
            speed: 1,
            amount: 1,
            minDuration: .1,
            attack: .01,
            release: .01,
            gap: 0
        },
        ugenOptions: {
            model: {
                stepSize: 1,
                activeVoices: [],
                freeVoices: [],
                stageSampleState: [ 0, 0, 0, 0 ],
                lastIdx: 0,
                inputState: {
                    numAttackSamps: 0,
                    numSustainSamps: 0,
                    numReleaseSamps: 0,
                    numDurationSamps: 0,
                    numGapSamps: 0
                }
            },
            interpolation: "linear",
            envelopeType: "linear",
            maxVoices: 2,
            strideInputs: [ "speed" ]
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.print = function(e, t, n) {
        var d = flock.ugen(e, t, n);
        return d.gen = function(e) {
            var t, n, r, o = d.inputs, a = d.output, i = d.model, u = i.label, l = o.channel, s = l ? o.source.output[l.output[0]] : o.source.output, c = o.trigger.output[0], f = o.freq.output[0];
            for (0 < c && i.prevTrig <= 0 && fluid.log(fluid.logLevel.IMPORTANT, u + s), i.freq !== f && (i.sampInterval = Math.round(i.sampleRate / f), 
            i.freq = f, i.counter = i.sampInterval), n = t = 0; t < e; t++, n += i.strides.source) i.counter >= i.sampInterval && (fluid.log(fluid.logLevel.IMPORTANT, u + s[n]), 
            i.counter = 0), i.counter++, a[t] = r = s[t];
            i.value = i.unscaledValue = r;
        }, d.init = function() {
            var e = d.options;
            d.model.label = e.label ? e.label + ": " : "", d.onInputChanged();
        }, d.init(), d;
    }, flock.ugenDefaults("flock.ugen.print", {
        rate: "audio",
        inputs: {
            source: null,
            trigger: 0,
            freq: 1
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                counter: 0
            },
            strideInputs: [ "source" ]
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.distortion = function(e, t, n) {
        var d = flock.ugen(e, t, n);
        return d.gen = function(e) {
            var t, n, r, o, a, i = d.model, u = d.output, l = d.inputs.source.output, s = i.strides.source, c = d.inputs.gain.output, f = i.strides.gain;
            for (r = o = a = 0; r < e; r++, o += s, a += f) n = 1.5 * (t = l[o] * c[a]) - .5 * t * t * t, 
            u[r] = n;
            i.unscaledValue = n, d.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, u);
        }, d.onInputChanged(), d;
    }, flock.ugenDefaults("flock.ugen.distortion", {
        rate: "audio",
        inputs: {
            source: null,
            gain: 1
        },
        ugenOptions: {
            strideInputs: [ "source", "gain" ]
        }
    }), flock.ugen.distortion.tanh = function(e, t, n) {
        var l = flock.ugen(e, t, n);
        return l.gen = function(e) {
            var t, n, r, o = l.model, a = l.output, i = l.inputs.source.output, u = o.strides.source;
            for (n = r = 0; n < e; n++, r += u) t = Math.tanh(i[r]), a[n] = t;
            o.unscaledValue = t, l.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, a);
        }, l.onInputChanged(), l;
    }, flock.ugenDefaults("flock.ugen.distortion.tanh", {
        rate: "audio",
        inputs: {
            source: null
        },
        ugenOptions: {
            strideInputs: [ "source" ]
        }
    }), flock.ugen.distortion.deJong = function(e, t, n) {
        var m = flock.ugen(e, t, n);
        return m.gen = function(e) {
            var t, n, r, o, a, i, u, l = m.model, s = m.output, c = m.inputs.source.output, f = l.strides.source, d = m.inputs.amount.output, p = l.strides.amount;
            for (a = i = u = 0; a < e; a++, i += f, u += p) t = c[i], n = d[u], o = t * ((r = Math.abs(t)) + n) / (t * t + (n - 1) * r + 1), 
            s[a] = o;
            l.unscaledValue = o, m.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, s);
        }, m.onInputChanged(), m;
    }, flock.ugenDefaults("flock.ugen.distortion.deJong", {
        rate: "audio",
        inputs: {
            source: null,
            amount: 2
        },
        ugenOptions: {
            strideInputs: [ "source", "amount" ]
        }
    }), flock.copyUGenDefinition("flock.ugen.distortion.deJong", "flock.ugen.distortion.deJonge"), 
    flock.ugen.distortion.tarrabiaDeJong = function(e, t, n) {
        var m = flock.ugen(e, t, n);
        return m.gen = function(e) {
            var t, n, r, o, a, i, u, l = m.model, s = m.output, c = m.inputs.source.output, f = l.strides.source, d = m.inputs.amount.output, p = l.strides.amount;
            for (o = a = i = 0; o < e; o++, a += f, i += p) t = c[a], 1 <= (n = d[i]) ? n = .9999999999999999 : n < -1 && (n = -1), 
            r = (1 + (u = 2 * n / (1 - n))) * t / (1 + u * Math.abs(t)), s[o] = r;
            l.unscaledValue = r, m.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, s);
        }, m.onInputChanged(), m;
    }, flock.ugenDefaults("flock.ugen.distortion.tarrabiaDeJong", {
        rate: "audio",
        inputs: {
            source: null,
            amount: 1
        },
        ugenOptions: {
            strideInputs: [ "source", "amount" ]
        }
    }), flock.copyUGenDefinition("flock.ugen.distortion.tarrabiaDeJong", "flock.ugen.distortion.tarrabiaDeJonge"), 
    flock.ugen.distortion.gloubiBoulga = function(e, t, n) {
        var m = flock.ugen(e, t, n);
        return m.gen = function(e) {
            var t, n, r, o, a, i, u, l = m.model, s = m.output, c = m.inputs.source.output, f = l.strides.source, d = m.inputs.gain.output, p = l.strides.gain;
            for (n = r = o = 0; n < e; n++, r += f, o += p) a = .686306 * (c[r] * d[o]), i = 1 + Math.exp(-.75 * Math.sqrt(Math.abs(a))), 
            t = ((u = Math.exp(a)) - Math.exp(-a * i)) / (u + Math.exp(-a)), s[n] = t;
            l.unscaledValue = t, m.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, s);
        }, m.onInputChanged(), m;
    }, flock.ugenDefaults("flock.ugen.distortion.gloubiBoulga", {
        rate: "audio",
        inputs: {
            source: null,
            gain: 1
        },
        ugenOptions: {
            strideInputs: [ "source", "gain" ]
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.normalize = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.gen = function() {
            var e = o.model, t = o.output, n = o.inputs.max.output[0], r = o.inputs.source.output;
            flock.normalize(r, n, t), e.value = e.unscaledValue = t[t.length - 1];
        }, o.onInputChanged(), o;
    }, flock.ugenDefaults("flock.ugen.normalize", {
        rate: "audio",
        inputs: {
            max: 1,
            source: null
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var a = fluid.registerNamespace("jQuery"), n = flock.requireModule("webarraymath", "ArrayMath");
    flock.envelope = {}, flock.envelope.makeCreator = function(r, o) {
        return function(e) {
            var t = flock.ugenDefaults(r), n = a.extend(!0, {}, t, e);
            return o(n);
        };
    }, flock.envelope.registerCreators = function(e, t) {
        var n, r;
        for (var o in t) n = fluid.pathUtil.composePath(e, o), r = t[o], flock.ugenDefaults(n, r.defaults), 
        fluid.setGlobalValue(n, flock.envelope.makeCreator(n, r.transformer));
    }, flock.envelope.creatorSpecs = {
        line: {
            transformer: function(e) {
                return {
                    levels: [ e.start, e.end ],
                    times: [ e.duration ]
                };
            },
            defaults: {
                start: 0,
                end: 1,
                duration: 1
            }
        },
        linear: {
            transformer: function(e) {
                return {
                    levels: [ 0, e.level, e.level, 0 ],
                    times: [ e.attack, e.sustain, e.release ]
                };
            },
            defaults: {
                level: 1,
                attack: .01,
                sustain: 1,
                release: 1
            }
        },
        tri: {
            transformer: function(e) {
                return {
                    levels: [ 0, e.level, 0 ],
                    times: [ e.duration, e.duration ]
                };
            },
            defaults: {
                level: 1,
                duration: 1
            }
        },
        sin: {
            transformer: function(e) {
                return {
                    levels: [ 0, e.level, 0 ],
                    times: [ e.duration, e.duration ],
                    curve: "sin"
                };
            },
            defaults: {
                level: 1,
                duration: 1
            }
        },
        asr: {
            transformer: function(e) {
                return {
                    levels: [ 0, e.sustain, 0 ],
                    times: [ e.attack, e.release ],
                    sustainPoint: 1,
                    curve: -4
                };
            },
            defaults: {
                sustain: 1,
                attack: .01,
                release: 1
            }
        },
        dadsr: {
            transformer: function(e) {
                var t = [ 0, 0, e.peak, e.peak * e.sustain, 0 ];
                return n.add(t, e.bias, t), {
                    levels: t,
                    times: [ e.delay, e.attack, e.decay, e.release ],
                    sustainPoint: 3,
                    curve: -4
                };
            },
            defaults: {
                delay: .1,
                attack: .01,
                decay: .3,
                sustain: .5,
                release: 1,
                peak: 1,
                bias: 0
            }
        },
        adsr: {
            transformer: function(e) {
                var t = [ 0, e.peak, e.peak * e.sustain, 0 ];
                return n.add(t, e.bias, t), {
                    levels: t,
                    times: [ e.attack, e.decay, e.release ],
                    sustainPoint: 2,
                    curve: -4
                };
            },
            defaults: {
                attack: .01,
                decay: .3,
                sustain: .5,
                release: 1,
                peak: 1,
                bias: 0
            }
        }
    }, flock.envelope.registerCreators("flock.envelope", flock.envelope.creatorSpecs), 
    flock.envelope.validate = function(e, t) {
        var n = e.levels, r = {};
        if (e.times ? !n || n.length < 2 ? r.levels = "An array containing at least two levels must be specified." : (flock.envelope.validate.times(e.times, n, r), 
        flock.envelope.validate.levels(n, r), flock.envelope.validate.curves(e.curve, n, r), 
        flock.envelope.validate.sustainPoint(e.sustainPoint, n, r)) : r.times = "An array containing at least one time value must be specified.", 
        !1 !== t) for (var o in r) flock.fail(r[o]);
        return r;
    }, flock.envelope.validate.times = function(e, t, n) {
        e.length !== t.length - 1 && (n.times = "The envelope specification should provide one fewer time value than the number of level values. times: " + e + " levels: " + t);
        for (var r = 0; r < e.length; r++) {
            var o = e[r];
            isNaN(o) && (n.times = "A NaN time value was specified at index " + r + ". times: " + e), 
            o < 0 && (n.times = "All times should be positive values. times: " + e);
        }
    }, flock.envelope.validate.levels = function(e, t) {
        for (var n = 0; n < e.length; n++) isNaN(e[n]) && (t.levels = "A NaN level value was specified at index " + n + ". levels: " + e);
    }, flock.envelope.validate.curves = function(t, e, n) {
        if (!t) return n;
        flock.isIterable(t) && (t.length !== e.length - 1 && (n.curve = "When curve is specified as an array, there should be one fewer curve value than the number of level values. curve: " + t + " levels: " + e), 
        fluid.each(t, function(e) {
            flock.lineGenerator(e) || (n.curve = "'" + e + "' is not a valid curve type. curve: " + t);
        })), flock.lineGenerator(t) || (n.curve = "'" + t + "' is not a valid curve type.");
    }, flock.envelope.validate.sustainPoint = function(e, t, n) {
        (e < 0 || e >= t.length) && (n.sustainPoint = "The specified sustainPoint index is out range for the levels array. sustainPoint: " + e + " levels: " + t);
    }, flock.envelope.expand = function(e) {
        var t = "string" == typeof e ? fluid.invokeGlobalFunction(e) : e.type ? fluid.invokeGlobalFunction(e.type, [ e ]) : e;
        if (t.curves && !t.curve && (t.curve = t.curves), !flock.isIterable(t.curve)) {
            var n = t.levels.length - 1;
            t.curve = flock.fillBufferWithValue(new Array(n), t.curve);
        }
        return flock.envelope.validate(t, !0), t;
    }, flock.fillBufferWithLine = function(e, t, n, r, o, a) {
        o = void 0 === o ? 0 : o;
        var i = (a = void 0 === a ? t.length : a) - o, u = flock.fillBufferWithLine.singletonModel;
        u.unscaledValue = n, u.destination = r, u.numSegmentSamps = i - 1, "number" == typeof e && (u.currentCurve = e, 
        e = "curve");
        var l = flock.line[e];
        return l || flock.fail("No line generator could be found for type " + e), l.init(u), 
        l.gen(i, o, t, u);
    }, flock.fillBufferWithLine.singletonModel = {
        unscaledValue: 0,
        value: 0,
        destination: 1
    }, flock.lineGenerator = function(e) {
        var t = typeof e;
        return "string" === t ? flock.line[e] : "number" === t ? flock.line.curve : flock.line.linear;
    }, flock.line = {
        constant: {
            init: function(e) {
                e.stepSize = 0;
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = t; a < e + t; a++) n[a] = o;
                return n;
            }
        },
        step: {
            init: function(e) {
                e.arrived = !1;
            },
            gen: function(e, t, n, r) {
                for (var o = t; o < e + t; o++) n[o] = r.unscaledValue, r.arrived || (r.arrived = !0, 
                r.unscaledValue = r.destination);
                return n;
            }
        },
        linear: {
            init: function(e) {
                e.stepSize = (e.destination - e.unscaledValue) / e.numSegmentSamps;
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.stepSize, i = t; i < e + t; i++) n[i] = o, o += a;
                return r.unscaledValue = o, n;
            }
        },
        exponential: {
            init: function(e) {
                0 === e.unscaledValue && (e.unscaledValue = 1e-16), e.stepSize = 0 === e.numSegmentSamps ? 0 : Math.pow(e.destination / e.unscaledValue, 1 / e.numSegmentSamps);
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.stepSize, i = t; i < e + t; i++) n[i] = o, o *= a;
                return r.unscaledValue = o, r.stepSize = a, n;
            }
        },
        curve: {
            init: function(e) {
                if (Math.abs(e.currentCurve) < .001) return flock.line.linear.init(e);
                var t = (e.destination - e.unscaledValue) / (1 - Math.exp(e.currentCurve));
                e.a2 = e.unscaledValue + t, e.b1 = t, e.stepSize = Math.exp(e.currentCurve / e.numSegmentSamps);
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.b1, i = t; i < e + t; i++) n[i] = o, a *= r.stepSize, 
                o = r.a2 - a;
                return r.unscaledValue = o, r.b1 = a, n;
            }
        },
        sin: {
            init: function(e) {
                var t = Math.PI / e.numSegmentSamps;
                e.a2 = .5 * (e.destination + e.unscaledValue), e.b1 = 2 * Math.cos(t), e.y1 = .5 * (e.destination - e.unscaledValue), 
                e.y2 = e.y1 * Math.sin(flock.HALFPI - t), e.unscaledValue = e.a2 - e.y1;
            },
            gen: function(e, t, n, r) {
                for (var o, a = r.unscaledValue, i = r.y1, u = r.y2, l = t; l < e + t; l++) n[l] = a, 
                o = r.b1 * i - u, a = r.a2 - o, u = i, i = o;
                return r.unscaledValue = a, r.y1 = i, r.y2 = u, n;
            }
        },
        welsh: {
            init: function(e) {
                var t = flock.HALFPI / e.numSegmentSamps, n = Math.cos(t);
                e.b1 = 2 * n, e.destination >= e.unscaledValue ? (e.a2 = e.unscaledValue, e.y1 = 0, 
                e.y2 = -Math.sin(t) * (e.destination - e.unscaledValue)) : (e.a2 = e.destination, 
                e.y1 = e.unscaledValue - e.destination, e.y2 = n * (e.unscaledValue - e.destination)), 
                e.unscaledValue = e.a2 + e.y1;
            },
            gen: function(e, t, n, r) {
                for (var o, a = r.unscaledValue, i = r.y1, u = r.y2, l = t; l < e + t; l++) n[l] = a, 
                o = r.b1 * i - u, u = i, i = o, a = r.a2 + o;
                return r.unscaledValue = a, r.y1 = i, r.y2 = u, n;
            }
        },
        squared: {
            init: function(e) {
                e.y1 = Math.sqrt(e.unscaledValue), e.y2 = Math.sqrt(e.destination), e.stepSize = (e.y2 - e.y1) / e.numSegmentSamps;
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.y1, i = t; i < e + t; i++) n[i] = o, o = (a += r.stepSize) * a;
                return r.y1 = a, r.unscaledValue = o, n;
            }
        },
        cubed: {
            init: function(e) {
                var t = .3333333333333333;
                e.y1 = Math.pow(e.unscaledValue, t), e.y2 = Math.pow(e.destination, t), e.stepSize = (e.y2 - e.y1) / e.numSegmentSamps;
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.y1, i = t; i < e + t; i++) n[i] = o, o = (a += r.stepSize) * a * a;
                return r.y1 = a, r.unscaledValue = o, n;
            }
        }
    }, flock.ugen.line = function(e, t, n) {
        var s = flock.ugen(e, t, n);
        return s.gen = function(e) {
            var t, n = s.model, r = n.stepSize, o = n.numSteps, a = e <= o ? e : o, i = e - a, u = n.level, l = s.output;
            for (t = 0; t < a; t++) l[t] = u, o--, u += r;
            if (0 < i) for (t = 0; t < i; t++) l[t] = u;
            n.level = n.unscaledValue = u, n.numSteps = o, s.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, l);
        }, s.onInputChanged = function() {
            var e = s.model;
            e.start = s.inputs.start.output[0], e.end = s.inputs.end.output[0], e.numSteps = Math.round(s.inputs.duration.output[0] * e.sampleRate), 
            0 === e.numSteps ? (e.stepSize = 0, e.level = e.end) : (e.stepSize = (e.end - e.start) / e.numSteps, 
            e.level = e.start), flock.onMulAddInputChanged(s);
        }, s.onInputChanged(), s;
    }, flock.ugenDefaults("flock.ugen.line", {
        rate: "control",
        inputs: {
            start: 0,
            end: 1,
            duration: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                start: 0,
                end: 1,
                numSteps: 0,
                stepSize: 0,
                level: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.xLine = function(e, t, n) {
        var s = flock.ugen(e, t, n);
        return s.gen = function(e) {
            var t, n = s.model, r = n.multiplier, o = n.numSteps, a = e <= o ? e : o, i = e - a, u = n.level, l = s.output;
            for (t = 0; t < a; t++) l[t] = u, o--, u *= r;
            if (0 < i) for (t = 0; t < i; t++) l[t] = u;
            n.level = n.unscaledValue = u, n.numSteps = o, s.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, l);
        }, s.onInputChanged = function() {
            var e = s.model;
            flock.onMulAddInputChanged(s), e.start = s.inputs.start.output[0], 0 === e.start && (e.start = 1e-101), 
            e.end = s.inputs.end.output[0], e.numSteps = Math.round(s.inputs.duration.output[0] * e.sampleRate), 
            e.multiplier = Math.pow(e.end / e.start, 1 / e.numSteps), e.level = e.start;
        }, s.onInputChanged(), s;
    }, flock.ugenDefaults("flock.ugen.xLine", {
        rate: "control",
        inputs: {
            start: 0,
            end: 1,
            duration: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                start: 0,
                end: 1,
                numSteps: 0,
                multiplier: 0,
                level: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.asr = function(e, t, n) {
        var m = flock.ugen(e, t, n);
        return m.gen = function(e) {
            var t, n, r = m.model, o = m.output, a = r.previousGate, i = m.inputs.gate.output[0], u = r.level, l = r.stage, s = l.currentStep, c = l.stepInc, f = l.numSteps, d = r.targetLevel, p = !1;
            for (a <= 0 && 0 < i ? (d = m.inputs.sustain.output[0], t = m.inputs.attack.output[0], 
            p = !0) : 0 <= a && i <= 0 && f <= s && (d = m.inputs.start.output[0], t = m.inputs.release.output[0], 
            p = !0), p && (c = 0 < (f = Math.round(t * r.sampleRate)) ? (d - u) / f : 0, s = 0, 
            f < 1 && (u = d)), n = 0; n < e; n++) o[n] = u, u = ++s < f ? u + c : s === f ? d : u;
            r.level = r.unscaledValue = u, r.targetLevel = d, r.previousGate = i, l.currentStep = s, 
            l.stepInc = c, l.numSteps = f, m.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, o);
        }, m.init = function() {
            var e = m.model;
            e.level = e.unscaledValue = m.inputs.start.output[0], e.targetLevel = m.inputs.sustain.output[0], 
            m.onInputChanged();
        }, m.init(), m;
    }, flock.ugenDefaults("flock.ugen.asr", {
        rate: "control",
        inputs: {
            start: 0,
            attack: .01,
            sustain: 1,
            release: 1,
            gate: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                level: 0,
                targetLevel: 0,
                previousGate: 0,
                unscaledValue: 0,
                value: 0,
                stage: {
                    currentStep: 0,
                    stepInc: 0,
                    numSteps: 0
                }
            }
        }
    }), flock.copyUGenDefinition("flock.ugen.asr", "flock.ugen.env.simpleASR"), flock.ugen.envGen = function(e, t, n) {
        var l = flock.ugen(e, t, n);
        return l.krGen = function(e) {
            var t, n = l.model, r = l.output, o = l.inputs, a = o.gate.output[0], i = o.timeScale.output[0], u = 0;
            for (flock.ugen.envGen.checkGate(l, a, i); u < e; ) t = Math.min(e - u, n.numSegmentSamps), 
            l.lineGen.gen(t, u, r, n), u += t, n.numSegmentSamps -= t, n.numSegmentSamps <= 0 && flock.ugen.envGen.nextStage(l, i);
            l.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, l.arGen = function(e) {
            var t, n = l.model, r = l.output, o = l.inputs, a = o.gate.output, i = o.timeScale.output[0];
            for (t = 0; t < e; t++) flock.ugen.envGen.checkGate(l, a[t], i), l.lineGen.gen(1, t, r, n), 
            n.numSegmentSamps--, n.numSegmentSamps <= 0 && flock.ugen.envGen.nextStage(l, i);
            l.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, l.onInputChanged = function(e) {
            e && "envelope" !== e || (l.envelope = flock.ugen.envGen.initEnvelope(l, l.inputs.envelope)), 
            e && "gate" !== e || (l.gen = l.inputs.gate.rate === flock.rates.AUDIO ? l.arGen : l.krGen), 
            flock.onMulAddInputChanged(l);
        }, l.onInputChanged(), l;
    }, flock.ugen.envGen.initEnvelope = function(e, t) {
        var n = e.model, r = flock.envelope.expand(t);
        return n.stage = 0, n.numStages = r.times.length, e.lineGen = flock.line.constant, 
        flock.ugen.envGen.lineGenForStage(e.inputs.timeScale.output[0], r, n), n.unscaledValue = r.levels[n.stage], 
        r;
    }, flock.ugen.envGen.checkGate = function(e, t, n) {
        var r = e.model, o = e.envelope;
        t !== r.previousGate && (0 < t && r.previousGate <= 0 ? (r.stage = 1, e.lineGen = flock.ugen.envGen.lineGenForStage(n, o, r)) : t <= 0 && 0 < r.previousGate && (r.stage = r.numStages, 
        e.lineGen = flock.ugen.envGen.lineGenForStage(n, o, r))), r.previousGate = t;
    }, flock.ugen.envGen.nextStage = function(e, t) {
        var n = e.model, r = e.envelope;
        n.stage === r.sustainPoint ? (e.lineGen = flock.line.constant, n.numSegmentSamps = 1 / 0, 
        n.destination = n.unscaledValue) : (n.stage++, e.lineGen = flock.ugen.envGen.lineGenForStage(t, r, n));
    }, flock.ugen.envGen.setupStage = function(e, t, n) {
        var r, o, a = t.levels[n.stage];
        0 === n.stage || n.stage > n.numStages ? o = 1 / 0 : (r = t.times[n.stage - 1] * e, 
        o = Math.max(1, Math.round(r * n.sampleRate))), n.numSegmentSamps = o, n.destination = a;
    }, flock.ugen.envGen.lineGenForStage = function(e, t, n) {
        var r, o, a = t.curve;
        return 0 === n.stage || n.stage > n.numStages ? r = flock.line.constant : (o = a[n.stage - 1], 
        n.currentCurve = o, r = flock.lineGenerator(o)), flock.ugen.envGen.setupStage(e, t, n), 
        r.init(n), r;
    }, flock.ugenDefaults("flock.ugen.envGen", {
        rate: "audio",
        inputs: {
            envelope: "flock.envelope.adsr",
            gate: 0,
            timeScale: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                previousGate: 0,
                stepSize: 0,
                destination: 0,
                numSegmentSamps: 1,
                unscaledValue: 0,
                value: 0,
                stage: 0,
                numStages: 0
            }
        }
    }), flock.ugen.phasor = function(e, t, n) {
        var s = flock.ugen(e, t, n);
        return s.gen = function(e) {
            var t, n, r, o = s.model, a = s.inputs, i = s.output, u = a.step.output, l = a.trigger.output;
            for (void 0 === o.unscaledValue && (o.unscaledValue = a.start.output[0]), r = n = t = 0; t < e; t++, 
            n += o.strides.trigger, r += o.strides.step) 0 < l[n] && o.prevTrig <= 0 && (o.unscaledValue = a.reset.output[0]), 
            o.prevTrig = l[n], o.unscaledValue >= a.end.output[0] && (o.unscaledValue = a.start.output[0]), 
            i[t] = o.unscaledValue, o.unscaledValue += u[r];
            s.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, s.onInputChanged(), s;
    }, flock.ugenDefaults("flock.ugen.phasor", {
        rate: "control",
        inputs: {
            start: 0,
            end: 1,
            reset: 0,
            step: .1,
            trigger: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: void 0,
                value: 0
            },
            strideInputs: [ "trigger", "step" ]
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var r = flock.requireModule("webarraymath", "Filter");
    flock.ugen.lag = function(e, t, n) {
        var d = flock.ugen(e, t, n);
        return d.gen = function(e) {
            var t, n, r, o, a = d.model, i = d.output, u = d.inputs, l = u.time.output[0], s = u.source.output, c = a.prevSamp, f = a.lagCoef;
            for (l !== a.prevTime && (a.prevtime = l, f = a.lagCoef = 0 === l ? 0 : Math.exp(flock.LOG001 / (l * a.sampleRate))), 
            t = n = 0; t < e; t++, n += a.strides.source) o = (r = s[n]) + f * (c - r), i[t] = c = o;
            a.prevSamp = c, d.mulAdd(e);
        }, d.onInputChanged(), d;
    }, flock.ugenDefaults("flock.ugen.lag", {
        rate: "audio",
        inputs: {
            source: null,
            time: .1
        },
        ugenOptions: {
            strideInputs: [ "source" ],
            model: {
                prevSamp: 0,
                lagCoef: 0,
                prevTime: 0
            }
        }
    }), flock.ugen.filter = function(e, t, n) {
        var a = flock.ugen(e, t, n);
        return a.gen = function() {
            var e = a.model, t = a.output, n = a.inputs, r = n.q.output[0], o = n.freq.output[0];
            e.prevFreq === o && e.prevQ === r || a.updateCoefficients(e, o, r), a.filterEngine.filter(t, a.inputs.source.output), 
            e.prevQ = r, e.prevFreq = o, e.value = e.unscaledValue = t[t.length - 1];
        }, a.init = function() {
            var e = a.options.recipe, t = "string" == typeof e ? flock.get(e) : e;
            if (!t) throw new Error("Can't instantiate a flock.ugen.filter() without specifying a filter coefficient recipe.");
            a.filterEngine = new r(t.sizes.b, t.sizes.a), a.model.coeffs = {
                a: a.filterEngine.a,
                b: a.filterEngine.b
            }, a.updateCoefficients = flock.get(t, a.options.type), a.onInputChanged();
        }, a.init(), a;
    }, flock.ugenDefaults("flock.ugen.filter", {
        rate: "audio",
        inputs: {
            freq: 440,
            q: 1,
            source: null
        }
    }), flock.ugen.filter.biquad = function(e, t, n) {
        var c = flock.ugen(e, t, n);
        return c.gen = function(e) {
            var t, n, r = c.model, o = c.inputs, a = c.output, i = r.coeffs, u = o.freq.output[0], l = o.q.output[0], s = o.source.output;
            for (r.prevFreq === u && r.prevQ === l || c.updateCoefficients(r, u, l), t = 0; t < e; t++) n = s[t] - i.a[0] * r.d0 - i.a[1] * r.d1, 
            a[t] = i.b[0] * n + i.b[1] * r.d0 + i.b[2] * r.d1, r.d1 = r.d0, r.d0 = n;
            r.prevQ = l, r.prevFreq = u, r.value = r.unscaledValue = flock.ugen.lastOutputValue(e, a);
        }, c.onInputChanged = function() {
            var e = c.options.type;
            c.updateCoefficients = "string" == typeof e ? flock.get(e) : e;
        }, c.init = function() {
            c.model.d0 = 0, c.model.d1 = 0, c.model.coeffs = {
                a: new Float32Array(2),
                b: new Float32Array(3)
            }, c.onInputChanged();
        }, c.init(), c;
    }, flock.ugenDefaults("flock.ugen.filter.biquad", {
        inputs: {
            freq: 440,
            q: 1,
            source: null
        }
    }), flock.ugen.filter.biquad.types = {
        hp: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.butterworth.highPass"
            }
        },
        rhp: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.rbj.highPass"
            }
        },
        lp: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.butterworth.lowPass"
            }
        },
        rlp: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.rbj.lowPass"
            }
        },
        bp: {
            inputDefaults: {
                freq: 440,
                q: 4
            },
            options: {
                type: "flock.coefficients.butterworth.bandPass"
            }
        },
        br: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.butterworth.bandReject"
            }
        }
    }, flock.aliasUGens("flock.ugen.filter.biquad", flock.ugen.filter.biquad.types), 
    flock.coefficients = {
        butterworth: {
            sizes: {
                a: 2,
                b: 3
            },
            lowPass: function(e, t) {
                var n = e.coeffs, r = 1 / Math.tan(Math.PI * t / e.sampleRate), o = r * r, a = flock.ROOT2 * r, i = 1 / (1 + a + o);
                n.b[0] = i, n.b[1] = 2 * i, n.b[2] = i, n.a[0] = 2 * (1 - o) * i, n.a[1] = (1 - a + o) * i;
            },
            highPass: function(e, t) {
                var n = e.coeffs, r = Math.tan(Math.PI * t / e.sampleRate);
                r === 1 / 0 && (r = 0);
                var o = r * r, a = flock.ROOT2 * r, i = 1 / (1 + a + o);
                n.b[0] = i, n.b[1] = -2 * i, n.b[2] = i, n.a[0] = 2 * (o - 1) * i, n.a[1] = (1 - a + o) * i;
            },
            bandPass: function(e, t, n) {
                var r = e.coeffs, o = t / n, a = 1 / Math.tan(Math.PI * o / e.sampleRate), i = 2 * Math.cos(flock.TWOPI * t / e.sampleRate), u = 1 / (1 + a);
                r.b[0] = u, r.b[1] = 0, r.b[2] = -u, r.a[0] = -a * i * u, r.a[1] = u * (a - 1);
            },
            bandReject: function(e, t, n) {
                var r = e.coeffs, o = t / n, a = Math.tan(Math.PI * o / e.sampleRate), i = 1 / (1 + a), u = -(2 * Math.cos(flock.TWOPI * t / e.sampleRate)) * i;
                r.b[0] = i, r.b[1] = u, r.b[2] = i, r.a[0] = u, r.a[1] = (1 - a) * i;
            }
        },
        rbj: {
            sizes: {
                a: 2,
                b: 3
            },
            lowPass: function(e, t, n) {
                var r = e.coeffs, o = flock.TWOPI * t / e.sampleRate, a = Math.cos(o), i = Math.sin(o) / (2 * n), u = 1 - a, l = 1 + i, s = u / 2 / l;
                r.b[0] = s, r.b[1] = u / l, r.b[2] = s, r.a[0] = -2 * a / l, r.a[1] = (1 - i) / l;
            },
            highPass: function(e, t, n) {
                var r = e.coeffs, o = flock.TWOPI * t / e.sampleRate, a = Math.cos(o), i = Math.sin(o) / (2 * n), u = 1 + a, l = 1 + i, s = u / 2 / l;
                r.b[0] = s, r.b[1] = -u / l, r.b[2] = s, r.a[0] = -2 * a / l, r.a[1] = (1 - i) / l;
            },
            bandPass: function(e, t, n) {
                var r = e.coeffs, o = flock.TWOPI * t / e.sampleRate, a = Math.cos(o), i = Math.sin(o) / (2 * n), u = 1 + i, l = n * i;
                r.b[0] = l / u, r.b[1] = 0, r.b[2] = -l / u, r.a[0] = -2 * a / u, r.a[1] = (1 - i) / u;
            },
            bandReject: function(e, t, n) {
                var r = e.coeffs, o = flock.TWOPI * t / e.sampleRate, a = Math.cos(o), i = Math.sin(o) / (2 * n), u = 1 + i, l = 1 / u, s = -2 * a / u;
                r.b[0] = l, r.b[1] = s, r.b[2] = l, r.a[0] = s, r.a[1] = (1 - i) / u;
            }
        }
    }, flock.ugen.filter.moog = function(e, t, n) {
        var S = flock.ugen(e, t, n);
        return S.gen = function(e) {
            var t, n, r, o, a, i, u, l = S.model, s = S.inputs, c = S.output, f = s.source.output, d = l.strides.source, p = s.resonance.output, m = l.strides.resonance, g = s.cutoff.output, h = l.strides.cutoff, v = l.f, y = l.fSq, k = l.fSqSq, b = l.oneMinusF, x = l.fb;
            for (t = n = r = o = 0; t < e; t++, n += d, r += m, o += h) a = g[o], i = p[r], 
            a !== l.prevCutoff && (a > l.nyquistRate && (a = l.nyquistRate), v = l.f = a / l.nyquistRate * 1.16, 
            y = l.fSq = v * v, k = l.fSqSq = y * y, b = l.oneMinusF = 1 - v, l.prevRes = void 0), 
            i !== l.prevRes && (4 < i ? i = 4 : i < 0 && (i = 0), x = l.fb = i * (1 - .15 * y)), 
            u = f[n] - l.out4 * x, u *= .35013 * k, l.out1 = u + .3 * l.in1 + b * l.out1, l.in1 = u, 
            l.out2 = l.out1 + .3 * l.in2 + b * l.out2, l.in2 = l.out1, l.out3 = l.out2 + .3 * l.in3 + b * l.out3, 
            l.in3 = l.out2, l.out4 = l.out3 + .3 * l.in4 + b * l.out4, l.in4 = l.out3, c[t] = l.out4;
            l.unscaledValue = l.out4, S.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, c);
        }, S.onInputChanged(), S;
    }, flock.ugenDefaults("flock.ugen.filter.moog", {
        rate: "audio",
        inputs: {
            cutoff: 3e3,
            resonance: 3.99,
            source: null
        },
        ugenOptions: {
            model: {
                in1: 0,
                in2: 0,
                in3: 0,
                in4: 0,
                out1: 0,
                out2: 0,
                out3: 0,
                out4: 0,
                prevCutoff: void 0,
                prevResonance: void 0,
                f: void 0,
                fSq: void 0,
                fSqSq: void 0,
                oneMinusF: void 0,
                fb: void 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "source", "cutoff", "resonance" ]
        }
    }), flock.ugen.delay = function(e, t, n) {
        var s = flock.ugen(e, t, n);
        return s.gen = function(e) {
            var t, n, r = s.model, o = s.inputs, a = s.output, i = o.source.output, u = o.time.output[0], l = s.delayBuffer;
            for (u !== r.time && (r.time = u, r.delaySamps = u * s.model.sampleRate), t = 0; t < e; t++) r.pos >= r.delaySamps && (r.pos = 0), 
            a[t] = n = l[r.pos], l[r.pos] = i[t], r.pos++;
            r.unscaledValue = n, s.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, a);
        }, s.onInputChanged = function(e) {
            if (flock.onMulAddInputChanged(s), !e || "maxTime" === e) {
                var t = s.model.sampleRate * s.inputs.maxTime.output[0];
                s.delayBuffer = new Float32Array(t);
            }
        }, s.onInputChanged(), s;
    }, flock.ugenDefaults("flock.ugen.delay", {
        rate: "audio",
        inputs: {
            maxTime: 1,
            time: 1,
            source: null
        },
        ugenOptions: {
            model: {
                pos: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.delay1 = function(e, t, n) {
        var l = flock.ugen(e, t, n);
        return l.gen = function(e) {
            var t, n, r = l.model, o = l.inputs, a = l.output, i = o.source.output, u = r.prevVal;
            for (t = 0; t < e; t++) a[t] = n = u, u = i[t];
            r.prevVal = u, r.unscaledValue = n, l.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, a);
        }, l.onInputChanged = function() {
            flock.onMulAddInputChanged(l);
        }, l.onInputChanged(), l;
    }, flock.ugenDefaults("flock.ugen.delay1", {
        rate: "audio",
        inputs: {
            source: null
        },
        ugenOptions: {
            model: {
                prevVal: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.freeverb = function(e, t, n) {
        var y = flock.ugen(e, t, n);
        return y.tunings = y.options.tunings, y.allpassTunings = y.options.allpassTunings, 
        y.gen = function(e) {
            var t, n, r, o = y.model, a = y.inputs, i = y.output, u = a.source.output, l = a.mix.output[0], s = 1 - l, c = .28 * a.room.output[0] + .7, f = .4 * a.damp.output[0], d = 1 - f;
            for (t = 0; t < e; t++) {
                var p = u[t], m = .015 * p;
                for (n = 0; n < y.buffers_a.length; n++) ++y.bufferindices_a[n] === y.allpassTunings[n] && (y.bufferindices_a[n] = 0), 
                y.readsamp_a[n] = y.buffers_a[n][y.bufferindices_a[n]];
                for (n = 0; n < y.buffers_c.length; n++) {
                    ++y.bufferindices_c[n] === y.tunings[n] && (y.bufferindices_c[n] = 0);
                    var g = y.bufferindices_c[n], h = y.buffers_c[n][g];
                    y.filterx_c[n] = d * y.filtery_c[n] + f * y.filterx_c[n], y.buffers_c[n][g] = m + c * y.filterx_c[n], 
                    y.filtery_c[n] = h;
                }
                var v = y.filtery_c[6] + y.filtery_c[7];
                y.buffers_a[3][y.bufferindices_a[3]] = .5 * y.filterx_a[3] + y.filtery_c[0] + (y.filtery_c[1] + y.filtery_c[2]) + (y.filtery_c[3] + y.filtery_c[4] + (y.filtery_c[5] + v)), 
                y.filterx_a[3] = y.readsamp_a[3], y.filtery_a[3] = y.filterx_a[3] - (y.filtery_c[0] + y.filtery_c[1] + (y.filtery_c[2] + y.filtery_c[3]) + (y.filtery_c[4] + y.filtery_c[5] + v)), 
                y.buffers_a[2][y.bufferindices_a[2]] = .5 * y.filterx_a[2] + y.filtery_a[3], y.filterx_a[2] = y.readsamp_a[2], 
                y.filtery_a[2] = y.filterx_a[2] - y.filtery_a[3], y.buffers_a[1][y.bufferindices_a[1]] = .5 * y.filterx_a[1] + y.filtery_a[2], 
                y.filterx_a[1] = y.readsamp_a[1], y.filtery_a[1] = y.filterx_a[1] - y.filtery_a[2], 
                y.buffers_a[0][y.bufferindices_a[0]] = .5 * y.filterx_a[0] + y.filtery_a[1], y.filterx_a[0] = y.readsamp_a[0], 
                y.filtery_a[0] = y.filterx_a[0] - y.filtery_a[1], r = s * p + l * y.filtery_a[0], 
                i[t] = r;
            }
            o.unscaledValue = r, y.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, y.initDelayLines = function() {
            y.buffers_c = new Array(8), y.bufferindices_c = new Int32Array(8), y.filterx_c = new Float32Array(8), 
            y.filtery_c = new Float32Array(8);
            var e, t, n = y.model.spread;
            for (e = 0; e < y.buffers_c.length; e++) for (y.buffers_c[e] = new Float32Array(y.tunings[e] + n), 
            y.bufferindices_c[e] = 0, y.filterx_c[e] = 0, t = y.filtery_c[e] = 0; t < y.tunings[e] + n; t++) y.buffers_c[e][t] = 0;
            for (y.buffers_a = new Array(4), y.bufferindices_a = new Int32Array(4), y.filterx_a = new Float32Array(4), 
            y.filtery_a = new Float32Array(4), y.readsamp_a = new Float32Array(4), e = 0; e < y.buffers_a.length; e++) {
                for (y.bufferindices_a[e] = 0, y.filterx_a[e] = 0, y.filtery_a[e] = 0, t = y.readsamp_a[e] = 0; t < y.allpassTunings.length; t++) y.allpassTunings[t] += n;
                for (y.buffers_a[e] = new Float32Array(y.allpassTunings[e]), t = 0; t < y.allpassTunings[e]; t++) y.buffers_a[e][t] = 0;
            }
        }, y.init = function() {
            y.initDelayLines(), y.onInputChanged();
        }, y.init(), y;
    }, flock.ugenDefaults("flock.ugen.freeverb", {
        rate: "audio",
        inputs: {
            source: null,
            mix: .33,
            room: .5,
            damp: .5
        },
        ugenOptions: {
            model: {
                spread: 0,
                unscaledValue: 0,
                value: 0
            },
            tunings: [ 1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617 ],
            allpassTunings: [ 556, 441, 341, 225 ]
        }
    }), flock.ugen.decay = function(e, t, n) {
        var l = flock.ugen(e, t, n);
        return l.gen = function(e) {
            var t, n, r = l.model, o = l.inputs, a = l.output, i = o.source.output, u = o.time.output[0];
            if (u !== r.time && (r.time = u, r.coeff = 0 === u ? 0 : Math.exp(flock.LOG001 / (u * l.model.sampleRate))), 
            0 === r.coeff) for (t = 0; t < e; t++) a[t] = n = i[t]; else for (t = 0; t < e; t++) r.lastSamp = i[t] + r.coeff * r.lastSamp, 
            a[t] = n = r.lastSamp;
            r.unscaledValue = n, l.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, a);
        }, l.onInputChanged(), l;
    }, flock.ugenDefaults("flock.ugen.decay", {
        rate: "audio",
        inputs: {
            source: null,
            time: 1
        },
        ugenOptions: {
            model: {
                time: 0,
                lastSamp: 0,
                coeff: 0,
                value: 0
            }
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.gate = function(e, t, n) {
        var h = flock.ugen(e, t, n);
        return h.gen = function(e) {
            var t, n, r, o, a = h.model, i = a.strides, u = h.output, l = h.inputs, s = l.source.output, c = l.sideChain.output, f = i.sideChain, d = l.threshold.output, p = i.threshold, m = h.options.holdLastValue, g = a.lastValue;
            for (t = n = r = 0; t < e; t++, n += f, r += p) c[n] >= d[r] ? u[t] = o = g = s[t] : u[t] = o = m ? g : 0;
            a.lastValue = g, a.unscaledValue = o, h.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, h.onInputChanged = function() {
            h.inputs.sideChain || (h.inputs.sideChain = h.inputs.source), flock.onMulAddInputChanged(h), 
            h.calculateStrides();
        }, h.onInputChanged(), h;
    }, flock.ugenDefaults("flock.ugen.gate", {
        rate: "audio",
        inputs: {
            source: null,
            sideChain: null,
            threshold: Number.MIN_VALUE,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                lastValue: 0
            },
            holdLastValue: !1,
            strideInputs: [ "sideChain", "threshold" ]
        }
    }), flock.ugen.timedGate = function(e, t, n) {
        var s = flock.ugen(e, t, n);
        return s.gen = function(e) {
            var t, n, r, o, a = s.model, i = s.output, u = s.inputs.trigger.output, l = s.inputs.duration.output[0];
            for (l !== a.duration && (a.duration = l, a.durationSamps = Math.floor(l * a.sampleRate)), 
            n = r = 0; n < e; n++, r += a.strides.trigger) 0 < (t = u[r]) && a.prevTrigger <= 0 ? (o = s.options.resetOnTrigger && 0 < a.sampsRemaining ? 0 : 1, 
            a.sampsRemaining = a.durationSamps) : o = 0 < a.sampsRemaining ? 1 : 0, i[n] = o, 
            a.sampsRemaining--, a.prevTrigger = t;
            a.unscaledValue = o, s.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, i);
        }, s.init = function() {
            s.onInputChanged();
        }, s.init(), s;
    }, flock.ugenDefaults("flock.ugen.timedGate", {
        rate: "audio",
        inputs: {
            trigger: 0,
            duration: 1
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                prevTrigger: 0,
                sampsRemaining: 0,
                durationSamps: 0,
                duration: 0
            },
            resetOnTrigger: !0,
            strideInputs: [ "trigger" ]
        }
    }), flock.ugen.latch = function(e, t, n) {
        var f = flock.ugen(e, t, n);
        return f.arGen = function(e) {
            var t, n, r, o, a = f.model, i = f.inputs, u = i.source.output, l = i.trigger, s = a.strides.source, c = f.output;
            for (void 0 === a.holdVal && (a.holdVal = u[0]), n = t = 0; t < e; t++, n += s) 0 < (r = l.output[t]) && a.prevTrig <= 0 && (a.holdVal = u[n]), 
            o = a.holdVal, c[t] = o, a.prevTrig = r;
            a.unscaledValue = o, f.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, c);
        }, f.krGen = function(e) {
            var t, n = f.model, r = f.output, o = f.inputs.trigger.output[0];
            for ((void 0 === n.holdVal || 0 < o && n.prevTrig <= 0) && (n.holdVal = f.inputs.source.output[0]), 
            n.prevTrig = o, t = 0; t < e; t++) r[t] = n.holdVal;
            n.unscaledValue = n.holdVal, f.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, f.onInputChanged = function() {
            f.calculateStrides(), f.gen = f.inputs.trigger.rate === flock.rates.AUDIO ? f.arGen : f.krGen, 
            flock.onMulAddInputChanged(f);
        }, f.onInputChanged(), f;
    }, flock.ugenDefaults("flock.ugen.latch", {
        rate: "audio",
        inputs: {
            source: null,
            trigger: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "source" ],
            model: {
                prevTrig: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.triggerGrains = function(e, t, n) {
        var A = flock.ugen(e, t, n);
        return A.gen = function(e) {
            var t, n, r, o, a, i, u, l = A.model, s = A.inputs, c = A.output, f = s.channel.output[0], d = A.buffer.data.channels[f], p = A.buffer.format.sampleRate, m = s.dur.output[0], g = s.amp.output, h = s.centerPos.output, v = s.trigger.output, y = s.speed.output, k = A.options.grainEnv, b = e - 1, x = 0, S = 0, w = 0, C = 0;
            for (t = 0; t < e; t++) {
                if (0 < v[S] && l.prevTrigger <= 0 && l.activeGrains.length < l.maxNumGrains) {
                    for ((o = l.freeGrains.pop()).numSamps = l.sampleRate * m, o.centerIdx = o.numSamps / 2 * l.stepSize, 
                    o.envScale = A.options.grainEnv.length / o.numSamps, o.sampIdx = 0, o.amp = g[w], 
                    a = h[x] * p - o.centerIdx; a < 0; ) a += d.length;
                    o.readPos = a, o.writePos = t, o.speed = y[C], l.activeGrains.push(o);
                }
                l.prevTrigger = v[S], c[t] = 0, x += l.strides.centerPos, S += l.strides.trigger, 
                w += l.strides.amp, C += l.strides.speed;
            }
            for (n = 0; n < l.activeGrains.length; ) {
                for (r = (o = l.activeGrains[n]).writePos; r < Math.min(r + (o.numSamps - o.sampIdx), e); r++) i = A.interpolate(o.readPos, d), 
                u = flock.interpolate.linear(o.sampIdx * o.envScale, k), c[r] += i * u * o.amp, 
                o.readPos = (o.readPos + l.stepSize * o.speed) % d.length, o.sampIdx++;
                o.sampIdx >= o.numSamps ? (l.freeGrains.push(o), l.activeGrains.splice(n, 1)) : (n++, 
                o.writePos = r % e);
            }
            l.unscaledValue = c[b], A.mulAdd(e), l.value = c[b];
        }, A.onBufferReady = function() {
            var e = A.model;
            e.stepSize = A.buffer.format.sampleRate / e.sampleRate;
        }, A.onInputChanged = function(e) {
            A.onBufferInputChanged(e), A.calculateStrides(), flock.onMulAddInputChanged(A);
        }, A.allocateGrains = function(e) {
            e = e || A.model.maxNumGrains;
            for (var t = 0; t < e; t++) A.model.freeGrains.push({
                numSamps: 0,
                centerIdx: 0,
                envScale: 0,
                sampIdx: 0,
                amp: 0,
                readPos: 0,
                writePos: 0,
                speed: 0
            });
        }, A.init = function() {
            flock.ugen.buffer(A), A.allocateGrains(), A.initBuffer(), A.onInputChanged();
        }, A.init(), A;
    }, flock.ugenDefaults("flock.ugen.triggerGrains", {
        rate: "audio",
        inputs: {
            centerPos: 0,
            channel: 0,
            amp: 1,
            dur: .1,
            speed: 1,
            trigger: 0,
            buffer: null,
            mul: null,
            add: null
        },
        ugenOptions: {
            grainEnv: flock.fillTable(8192, flock.tableGenerators.hann),
            model: {
                unscaledValue: 0,
                value: 0,
                maxNumGrains: 512,
                activeGrains: [],
                freeGrains: [],
                env: null,
                strides: {}
            },
            strideInputs: [ "centerPos", "trigger", "amp", "speed" ],
            interpolation: "cubic"
        }
    }), flock.ugen.granulator = function(e, t, n) {
        var k = flock.ugen(e, t, n);
        return k.gen = function(e) {
            var t, n, r, o, a, i, u, l = k.model, s = k.options, c = k.inputs, f = k.output, d = k.delayLine, p = c.grainDur.output[0], m = c.delayDur.output[0], g = c.numGrains.output[0], h = c.source.output, v = s.maxDelayDur, y = s.grainEnv;
            for (l.delayDur !== m && (v < (l.delayDur = m) && (m = v), l.delayLength = m * l.sampleRate | 0, 
            l.writePos = l.writePos % l.delayLength), l.grainDur !== p && (l.grainDur = p, l.grainLength = l.sampleRate * l.grainDur | 0, 
            l.envScale = y.length / l.grainLength), g = g > s.maxNumGrains ? s.maxNumGrains : Math.round(g), 
            t = 0; t < e; t++) {
                for (d[l.writePos] = h[t], l.writePos = ++l.writePos % l.delayLength, n = r = 0; n < g; n++) o = l.grainIdx[n], 
                a = l.delayLineIdx[n], o > l.grainLength && (o = 0, a = Math.random() * l.delayLength | 0), 
                i = d[a], u = o * l.envScale, r += i * flock.interpolate.linear(u, y), l.delayLineIdx[n] = ++a % l.delayLength, 
                l.grainIdx[n] = ++o;
                r /= g, f[t] = r;
            }
            l.unscaledValue = r, k.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, f);
        }, k.initGrains = function() {
            for (var e = k.model, t = 0; t < k.options.maxNumGrains; t++) e.grainIdx[t] = 0, 
            e.delayLineIdx[t] = Math.random() * e.delayLength;
        }, k.init = function() {
            var e = k.model, t = k.options, n = t.maxDelayDur * e.sampleRate | 0;
            k.delayLine = new Float32Array(n), e.delayLength = n, e.delayLineIdx = new Uint32Array(t.maxNumGrains), 
            e.grainIdx = new Uint32Array(t.maxNumGrains), k.initGrains(), k.onInputChanged();
        }, k.init(), k;
    }, flock.ugenDefaults("flock.ugen.granulator", {
        rate: "audio",
        inputs: {
            source: null,
            grainDur: .1,
            delayDur: 1,
            numGrains: 5,
            mul: null,
            add: null
        },
        ugenOptions: {
            maxNumGrains: 512,
            maxDelayDur: 30,
            grainEnv: flock.fillTable(8192, flock.tableGenerators.sinWindow),
            model: {
                unscaledValue: 0,
                value: 0,
                grainLength: 0,
                writePos: 0
            }
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.amplitude = function(e, t, n) {
        var m = flock.ugen(e, t, n);
        return m.gen = function(e) {
            var t, n, r, o = m.model, a = m.inputs.source.output, i = m.output, u = o.attackTime, l = m.inputs.attack.output[0], s = o.releaseTime, c = m.inputs.release.output[0], f = o.prevVal, d = o.attackCoef, p = o.releaseCoef;
            for (l !== u && (o.attackTime = l, d = o.attackCoef = 0 === l ? 0 : Math.exp(flock.LOG01 / (l * o.sampleRate))), 
            c !== s && (o.releaseTime = c, p = o.releaseCoef = 0 === c ? 0 : Math.exp(flock.LOG01 / (c * o.sampleRate))), 
            t = 0; t < e; t++) r = (n = Math.abs(a[t])) < f ? p : d, i[t] = f = n + (f - n) * r;
            o.unscaledValue = o.prevVal = f, m.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, m.onInputChanged(), m;
    }, flock.ugenDefaults("flock.ugen.amplitude", {
        rate: "audio",
        inputs: {
            source: null,
            attack: .01,
            release: .01,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                prevVal: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var u = flock.requireModule("webarraymath", "ArrayMath");
    flock.ugen.math = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.expandedRight = new Float32Array(i.options.audioSettings.blockSize), i.krSourceKrInputGen = function() {
            var e = i.model, t = i.activeInput, n = i.inputs[t], r = i.output, o = i.inputs.source.output[0], a = flock.fillBufferWithValue(i.expandedRight, n.output[0]);
            u[t](r, o, a), e.value = e.unscaledValue = r[r.length - 1];
        }, i.krSourceArInputGen = function() {
            var e = i.model, t = i.activeInput, n = i.inputs[t], r = i.output, o = i.inputs.source.output[0], a = n.output;
            u[t](r, o, a), e.value = e.unscaledValue = r[r.length - 1];
        }, i.arSourceKrInputGen = function() {
            var e = i.model, t = i.activeInput, n = i.inputs[t], r = i.output, o = i.inputs.source.output, a = flock.fillBufferWithValue(i.expandedRight, n.output[0]);
            u[t](r, o, a), e.value = e.unscaledValue = r[r.length - 1];
        }, i.arSourceArInputGen = function() {
            var e = i.model, t = i.activeInput, n = i.inputs[t], r = i.output, o = i.inputs.source.output, a = n.output;
            u[t](r, o, a), e.value = e.unscaledValue = r[r.length - 1];
        }, i.onInputChanged = function() {
            var e, t, n, r = Object.keys(i.inputs);
            for (e = 0; e < r.length; e++) if ("source" !== (t = r[e])) {
                i.activeInput = t, n = "audio" === i.inputs[t].rate, i.gen = "audio" === i.inputs.source.rate ? n ? i.arSourceArInputGen : i.arSourceKrInputGen : n ? i.krSourceArInputGen : i.krSourceKrInputGen;
                break;
            }
        }, i.init = function() {
            if (void 0 === u) throw new Error("ArrayMath is undefined. Please include webarraymath.js to use the flock.math unit generator.");
            i.onInputChanged();
        }, i.init(), i;
    }, flock.ugenDefaults("flock.ugen.math", {
        rate: "audio",
        inputs: {
            source: null
        }
    }), flock.ugen.sum = function(e, t, n) {
        var u = flock.ugen(e, t, n);
        return u.copyGen = function(e) {
            var t, n, r = u.model, o = u.output, a = u.inputs.sources.output;
            for (t = 0; t < e; t++) n = a[t], o[t] = n;
            r.unscaledValue = n, u.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, o);
        }, u.sumGen = function(e) {
            var t, n, r, o = u.model, a = u.inputs.sources, i = u.output;
            for (flock.clearBuffer(i), n = 0; n < a.length; n++) for (r = a[n].output, t = 0; t < e; t++) i[t] += r[t];
            o.unscaledValue = flock.ugen.lastOutputValue(e, i), u.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, u.onInputChanged = function() {
            "number" == typeof u.inputs.sources.length ? u.gen = u.sumGen : u.gen = u.copyGen, 
            flock.onMulAddInputChanged(u);
        }, u.onInputChanged(), u;
    }, flock.ugenDefaults("flock.ugen.sum", {
        rate: "audio",
        inputs: {
            sources: null
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.midiFreq = function(e, t, n) {
        var f = flock.ugen(e, t, n);
        return f.gen = function(e) {
            var t, n, r, o = f.model, a = o.a4, i = a.freq, u = a.noteNum, l = o.notesPerOctave, s = f.inputs.note.output, c = f.output;
            for (n = t = 0; t < e; t++, n += o.strides.note) c[t] = r = flock.midiFreq(s[n], i, u, l);
            o.unscaledValue = r, f.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, c);
        }, f.init = function() {
            f.model.octaveScale = 1 / f.model.notesPerOctave, f.onInputChanged();
        }, f.init(), f;
    }, flock.ugenDefaults("flock.ugen.midiFreq", {
        rate: "control",
        inputs: {
            note: 69
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                a4: {
                    noteNum: 69,
                    freq: 440
                },
                notesPerOctave: 12
            },
            strideInputs: [ "note" ]
        }
    }), flock.ugen.midiAmp = function(e, t, n) {
        var u = flock.ugen(e, t, n);
        return u.gen = function(e) {
            var t, n, r, o = u.model, a = u.inputs.velocity.output, i = u.output;
            for (n = t = 0; t < e; t++, n += o.strides.velocity) i[t] = r = a[n] / 127;
            o.unscaledValue = r, u.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, u.init = function() {
            u.onInputChanged();
        }, u.init(), u;
    }, flock.ugenDefaults("flock.ugen.midiAmp", {
        rate: "control",
        inputs: {
            velocity: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "velocity" ]
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.pan2 = function(e, t, n) {
        var p = flock.ugen(e, t, n);
        return p.gen = function(e) {
            var t, n, r, o, a = p.model, i = p.output, u = i[0], l = i[1], s = p.inputs, c = s.source.output, f = s.pan.output;
            for (n = t = 0; t < e; t++, n += a.strides.pan) r = c[t], o = .5 * f[n] + .5, l[t] = r * Math.sin(o * flock.HALFPI), 
            u[t] = r * Math.cos(o * flock.HALFPI);
            var d = e - 1;
            a.value[0] = i[0][d], a.value[1] = i[1][d];
        }, p.init = function() {
            p.onInputChanged(), p.model.unscaledValue = p.model.value;
        }, p.init(), p;
    }, flock.ugenDefaults("flock.ugen.pan2", {
        rate: "audio",
        inputs: {
            source: null,
            pan: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: [ 0, 0 ],
                value: [ 0, 0 ]
            },
            tags: [ "flock.ugen.multiChannelOutput" ],
            strideInputs: [ "pan" ],
            numOutputs: 2
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.osc = function(e, t, n) {
        var h = flock.ugen(e, t, n);
        return h.gen = function(e) {
            var t, n, r, o, a, i = h.model, u = h.inputs, l = u.freq.output, s = u.phase.output, c = u.table, f = i.tableLen, d = i.tableIncHz, p = i.tableIncRad, m = h.output, g = i.phase;
            for (r = n = t = 0; t < e; t++, n += i.strides.phase, r += i.strides.freq) f <= (o = g + s[n] * p) ? o -= f : o < 0 && (o += f), 
            m[t] = a = h.interpolate(o, c), f <= (g += l[r] * d) ? g -= f : g < 0 && (g += f);
            i.phase = g, i.unscaledValue = a, h.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, m);
        }, h.onInputChanged = function(e) {
            if (flock.ugen.osc.onInputChanged(h), !e || "table" === e) {
                var t = h.model, n = h.inputs.table;
                n.length < 1 && (n = h.inputs.table = flock.ugen.osc.emptyTable), t.tableLen = n.length, 
                t.tableIncHz = t.tableLen / t.sampleRate, t.tableIncRad = t.tableLen / flock.TWOPI;
            }
        }, h.onInputChanged(), h;
    }, flock.ugen.osc.emptyTable = new Float32Array([ 0, 0, 0 ]), flock.ugen.osc.onInputChanged = function(e) {
        e.calculateStrides(), flock.onMulAddInputChanged(e);
    }, flock.ugenDefaults("flock.ugen.osc", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            table: [],
            mul: null,
            add: null
        },
        ugenOptions: {
            interpolation: "linear",
            model: {
                phase: 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "freq", "phase" ]
        },
        tableSize: 8192
    }), flock.ugen.osc.define = function(e, a) {
        var t = e.lastIndexOf("."), n = e.substring(0, t), r = e.substring(t + 1);
        flock.get(n)[r] = function(e, t, n) {
            var r = flock.ugenDefaults("flock.ugen.osc"), o = fluid.merge(null, r, n).tableSize;
            return e.table = flock.fillTable(o, a), flock.ugen.osc(e, t, n);
        }, flock.ugenDefaults(e, flock.ugenDefaults("flock.ugen.osc"));
    }, flock.ugen.osc.define("flock.ugen.sinOsc", flock.tableGenerators.sin), flock.ugen.osc.define("flock.ugen.triOsc", flock.tableGenerators.tri), 
    flock.ugen.osc.define("flock.ugen.sawOsc", flock.tableGenerators.saw), flock.ugen.osc.define("flock.ugen.squareOsc", flock.tableGenerators.square), 
    flock.ugen.sin = function(e, t, n) {
        var f = flock.ugen(e, t, n);
        return f.gen = function(e) {
            var t, n, r, o, a = f.model, i = f.inputs.freq.output, u = f.inputs.phase.output, l = f.output, s = a.phase, c = a.sampleRate;
            for (r = n = t = 0; t < e; t++, n += a.strides.phase, r += a.strides.freq) l[t] = o = Math.sin(s + u[n]), 
            s += i[r] / c * flock.TWOPI;
            a.phase = s, a.unscaledValue = o, f.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, l);
        }, f.onInputChanged = function() {
            flock.ugen.osc.onInputChanged(f);
        }, f.onInputChanged(), f;
    }, flock.ugenDefaults("flock.ugen.sin", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "freq", "phase" ]
        }
    }), flock.ugen.lfSaw = function(e, t, n) {
        var c = flock.ugen(e, t, n);
        return c.gen = function(e) {
            var t, n, r, o = c.model, a = c.inputs.freq.output, i = c.output, u = o.scale, l = c.inputs.phase.output[0], s = o.phase;
            for (n = t = 0; t < e; t++, n += o.strides.freq) i[t] = r = s + l, 1 <= (s += a[n] * u) ? s -= 2 : s <= -1 && (s += 2);
            o.phase = s, o.unscaledValue = r, c.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, c.onInputChanged = function() {
            var e = c.model;
            e.freqInc = c.inputs.freq.rate === flock.rates.AUDIO ? 1 : 0, e.phase = 0, c.calculateStrides(), 
            flock.onMulAddInputChanged(c);
        }, c.init = function() {
            c.model.scale = 1 / c.options.sampleRate * 2, c.onInputChanged();
        }, c.init(), c;
    }, flock.ugenDefaults("flock.ugen.lfSaw", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0,
                freqInc: 1,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "freq" ]
        }
    }), flock.ugen.lfPulse = function(e, t, n) {
        var d = flock.ugen(e, t, n);
        return d.gen = function(e) {
            var t, n, r, o = d.inputs, a = d.model, i = o.freq.output, u = a.freqInc, l = o.width.output[0], s = d.output, c = a.scale, f = void 0 !== a.phase ? a.phase : o.phase.output[0];
            for (n = t = 0; t < e; t++, n += u) 1 <= f ? (f -= 1, s[t] = r = l < .5 ? 1 : -1) : s[t] = r = f < l ? 1 : -1, 
            f += i[n] * c;
            a.phase = f, a.unscaledValue = r, d.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, s);
        }, d.onInputChanged = function() {
            d.model.freqInc = d.inputs.freq.rate === flock.rates.AUDIO ? 1 : 0, flock.onMulAddInputChanged(d);
        }, d.init = function() {
            d.model.scale = 1 / d.options.sampleRate, d.onInputChanged();
        }, d.init(), d;
    }, flock.ugenDefaults("flock.ugen.lfPulse", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            width: .5,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0,
                freqInc: 1,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.impulse = function(e, t, n) {
        var d = flock.ugen(e, t, n);
        return d.gen = function(e) {
            var t, n, r, o = d.inputs, a = d.model, i = d.output, u = o.freq.output, l = a.strides.freq, s = o.phase.output[0], c = a.phase, f = a.scale;
            for (c += s, n = t = 0; t < e; t++, n += l) 1 <= c ? (c -= 1, r = 1) : r = 0, i[t] = r, 
            c += u[n] * f;
            a.phase = c - s, a.unscaledValue = r, d.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, i);
        }, d.onInputChanged = function() {
            d.calculateStrides(), flock.onMulAddInputChanged(d);
        }, d.init = function() {
            d.model.scale = 1 / d.model.sampleRate, d.onInputChanged();
        }, d.init(), d;
    }, flock.ugenDefaults("flock.ugen.impulse", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0,
                scale: 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "freq" ]
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var r = flock.requireModule("Random");
    flock.ugen.dust = function(s, e, t) {
        var c = flock.ugen(s, e, t);
        return c.gen = function(e) {
            var t, n, r, o, a, i = c.model, u = c.output, l = s.density.output[0];
            for (l !== i.density ? (i.density = l, t = i.threshold = l * i.sampleDur, n = i.scale = 0 < t ? 1 / t : 0) : (t = i.threshold, 
            n = i.scale), a = 0; a < e; a++) o = (r = Math.random()) < t ? r * n : 0, u[a] = o;
            i.unscaledValue = o, c.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, u);
        }, c.onInputChanged(), c;
    }, flock.ugenDefaults("flock.ugen.dust", {
        rate: "audio",
        inputs: {
            density: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                density: 0,
                scale: 0,
                threshold: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.whiteNoise = function(e, t, n) {
        var a = flock.ugen(e, t, n);
        return a.gen = function(e) {
            var t, n, r = a.model, o = a.output;
            for (t = 0; t < e; t++) o[t] = n = flock.randomAudioValue();
            r.unscaledValue = n, a.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, o);
        }, a.onInputChanged(), a;
    }, flock.ugenDefaults("flock.ugen.whiteNoise", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        }
    }), flock.ugen.pinkNoise = function(e, t, n) {
        var f = flock.ugen(e, t, n);
        return f.gen = function(e) {
            var t, n, r, o, a = f.model, i = a.state, u = f.a, l = f.p, s = a.offset, c = f.output;
            for (t = 0; t < e; t++) {
                for (n = o = 0; n < i.length; n++) r = Math.random(), i[n] = l[n] * (i[n] - r) + r, 
                o += u[n] * i[n];
                o = 2 * o - s, c[t] = o;
            }
            a.unscaledValue = o, f.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, c);
        }, f.init = function() {
            f.a = new Float32Array(f.options.coeffs.a), f.p = new Float32Array(f.options.coeffs.p), 
            f.model.state = new Float32Array(f.a.length);
            for (var e = 0; e < f.a.length; e++) f.model.offset += f.a[e];
            f.onInputChanged();
        }, f.init(), f;
    }, flock.ugenDefaults("flock.ugen.pinkNoise", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                state: 0,
                unscaledValue: 0,
                value: 0,
                offset: 0
            },
            coeffs: {
                a: [ .02109238, .07113478, .68873558 ],
                p: [ .319, .7756, .9613 ]
            }
        }
    }), flock.ugen.lfNoise = function(l, e, t) {
        var s = flock.ugen(l, e, t);
        return s.gen = function(e) {
            var t, n, r = s.model, o = l.freq.output[0], a = e, i = s.output, u = 0;
            o = .001 < o ? o : .001;
            do {
                for (r.counter <= 0 && (r.counter = r.sampleRate / o, r.counter = 1 < r.counter ? r.counter : 1, 
                "linear" === s.options.interpolation ? (r.start = r.unscaledValue = r.end, r.end = Math.random(), 
                r.ramp = r.ramp = (r.end - r.start) / r.counter) : (r.start = r.unscaledValue = Math.random(), 
                r.ramp = 0)), a -= t = a < r.counter ? a : r.counter, r.counter -= t, n = 0; n < t; n++) i[u] = r.unscaledValue, 
                r.unscaledValue += r.ramp, u++;
            } while (a);
            s.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, i);
        }, s.input = function() {
            s.model.end = Math.random(), s.onInputChanged();
        }, s.input(), s;
    }, flock.ugenDefaults("flock.ugen.lfNoise", {
        rate: "audio",
        inputs: {
            freq: 440,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                counter: 0,
                level: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.random = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.gen = function(e) {
            var t, n, r = i.model, o = i.generator, a = i.output;
            for (t = 0; t < e; t++) a[t] = n = o.uniform(-1, 1);
            r.unscaledValue = n, i.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, a);
        }, i.onInputChanged = function(e) {
            "seed" === e && i.initGenerator(), flock.onMulAddInputChanged(i);
        }, i.initGenerator = function() {
            var e = i.inputs.seed;
            i.generator = e ? new r(e) : new r();
        }, i.init = function() {
            i.initGenerator(), i.calculateStrides(), i.onInputChanged();
        }, i.init(), i;
    }, flock.ugenDefaults("flock.ugen.random", {
        rate: "audio",
        inputs: {
            seed: null,
            mul: null,
            add: null
        }
    }), flock.ugen.random.exponential = function(e, t, n) {
        var s = flock.ugen.random(e, t, n);
        return s.gen = function(e) {
            var t, n, r, o = s.model, a = s.generator, i = s.output, u = s.inputs.lambda.output, l = s.model.strides.lambda;
            for (t = n = 0; t < e; t++, n += l) i[t] = r = a.exponential(u[n]);
            o.unscaledValue = r, s.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, s;
    }, flock.ugenDefaults("flock.ugen.random.exponential", {
        rate: "audio",
        inputs: {
            seed: null,
            lambda: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "lambda" ]
        }
    }), flock.ugen.random.gamma = function(e, t, n) {
        var p = flock.ugen.random(e, t, n);
        return p.gen = function(e) {
            var t, n, r, o, a = p.model, i = p.inputs, u = p.generator, l = p.output, s = a.strides.alpha, c = i.alpha.output, f = a.strides.beta, d = i.beta.output;
            for (t = n = r = 0; t < e; t++, n += s, r += f) l[t] = o = u.gamma(c[n], d[r]);
            a.unscaledValue = o, p.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, l);
        }, p;
    }, flock.ugenDefaults("flock.ugen.random.gamma", {
        rate: "audio",
        inputs: {
            seed: null,
            alpha: 1,
            beta: 2,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "alpha", "beta" ]
        }
    }), flock.ugen.random.normal = function(e, t, n) {
        var p = flock.ugen.random(e, t, n);
        return p.gen = function(e) {
            var t, n, r, o, a = p.model, i = p.output, u = p.inputs, l = p.generator, s = a.strides.mu, c = u.mu.output, f = a.strides.sigma, d = u.sigma.output;
            for (t = n = r = 0; t < e; t++, n += s, r += f) i[t] = o = l.normal(c[n], d[r]);
            a.unscaledValue = o, p.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, i);
        }, p;
    }, flock.ugenDefaults("flock.ugen.random.normal", {
        rate: "audio",
        inputs: {
            seed: null,
            mu: 0,
            sigma: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "mu", "sigma" ]
        }
    }), flock.ugen.random.pareto = function(e, t, n) {
        var s = flock.ugen.random(e, t, n);
        return s.gen = function(e) {
            var t, n, r, o = s.model, a = s.generator, i = s.output, u = s.model.strides.alpha, l = s.inputs.alpha.output;
            for (t = n = 0; t < e; t++, n += u) i[t] = r = a.pareto(l[n]);
            o.unscaledValue = r, s.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, s;
    }, flock.ugenDefaults("flock.ugen.random.pareto", {
        rate: "audio",
        inputs: {
            seed: null,
            alpha: 5,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "alpha" ]
        }
    }), flock.ugen.random.triangular = function(e, t, n) {
        var s = flock.ugen.random(e, t, n);
        return s.gen = function(e) {
            var t, n, r, o = s.model, a = s.generator, i = s.output, u = s.model.strides.mode, l = s.inputs.mode.output;
            for (t = n = 0; t < e; t++, n += u) i[t] = r = a.triangular(-1, 1, l[n]);
            o.unscaledValue = r, s.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, s;
    }, flock.ugenDefaults("flock.ugen.random.triangular", {
        rate: "audio",
        inputs: {
            seed: null,
            mode: .5,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "mode" ]
        }
    }), flock.ugen.random.weibull = function(e, t, n) {
        var p = flock.ugen.random(e, t, n);
        return p.gen = function(e) {
            var t, n, r, o, a = p.model, i = p.inputs, u = p.generator, l = p.output, s = a.strides.alpha, c = i.alpha.output, f = a.strides.beta, d = i.beta.output;
            for (t = n = r = 0; t < e; t++, n += s, r += f) l[t] = o = u.weibull(c[n], d[r]);
            a.unscaledValue = o, p.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, l);
        }, p;
    }, flock.ugenDefaults("flock.ugen.random.weibull", {
        rate: "audio",
        inputs: {
            seed: null,
            alpha: 1,
            beta: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "alpha", "beta" ]
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.change = function(e, t, n) {
        var p = flock.ugen(e, t, n);
        return p.gen = function(e) {
            for (var t, n = p.model, r = p.inputs.initial.output, o = n.strides.initial, a = p.inputs.target.output, i = n.strides.target, u = p.output, l = n.samplesLeft, s = n.crossfadeLevel, c = 0, f = 0, d = 0; c < e; c++, 
            f += o, d += i) 0 < l ? (t = r[f], l--) : 0 < s ? (t = r[f] * s + a[d] * (1 - s), 
            s -= n.crossfadeStepSize) : t = a[d], u[c] = t;
            n.samplesLeft = l, n.crossfadeLevel = s, n.value = n.unscaledValue = t;
        }, p.onInputChanged = function(e) {
            var t = p.model, n = p.inputs;
            "time" !== e && e || (t.samplesLeft = Math.round(n.time.output[0] * t.sampleRate)), 
            "crossfade" !== e && e || (t.crossfadeStepSize = 1 / Math.round(n.crossfade.output[0] * t.sampleRate), 
            t.crossfadeLevel = 0 < n.crossfade.output[0] ? 1 : 0), p.calculateStrides();
        }, p.onInputChanged(), p;
    }, flock.ugenDefaults("flock.ugen.change", {
        rate: "audio",
        inputs: {
            initial: 0,
            target: 0,
            time: 0,
            crossfade: 0
        },
        ugenOptions: {
            model: {
                samplesLeft: 0,
                crossfadeStepSize: 0,
                crossfadeLevel: 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "initial", "target" ]
        }
    }), flock.ugen.listItem = function(e, t, n) {
        var c = flock.ugen(e, t, n);
        return c.gen = function(e) {
            var t, n, r, o, a = c.model, i = c.output, u = c.inputs.list, l = u.length - 1, s = c.inputs.index.output;
            for (r = t = 0; t < e; t++, r += a.strides.index) o = Math.round(s[r] * l), o = Math.max(0, o), 
            n = u[o = Math.min(o, l)], i[t] = n;
            a.unscaledValue = n, c.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, i);
        }, c.onInputChanged(), c;
    }, flock.ugenDefaults("flock.ugen.listItem", {
        rate: "control",
        inputs: {
            index: 0,
            list: [ 0 ]
        },
        ugenOptions: {
            strideInputs: [ "index" ]
        }
    }), flock.ugen.sequence = function(e, t, n) {
        var p = flock.ugen(e, t, n);
        return p.gen = function(e) {
            var t, n, r, o = p.inputs.values, a = p.inputs, i = a.freq.output, u = a.loop.output[0], l = p.model, s = l.scale, c = p.output, f = a.start ? Math.round(a.start.output[0]) : 0, d = a.end ? Math.round(a.end.output[0]) : o.length;
            for (void 0 === l.unscaledValue && (t = o[f], l.unscaledValue = void 0 === t ? 0 : t), 
            void 0 === l.nextIdx && (l.nextIdx = f), r = n = 0; n < e; n++, r += l.strides.freq) {
                if (l.nextIdx >= d) {
                    if (!(0 < u)) {
                        c[n] = l.unscaledValue;
                        continue;
                    }
                    l.nextIdx = f;
                }
                c[n] = l.unscaledValue = o[l.nextIdx], l.phase += i[r] * s, 1 <= l.phase && (l.phase = 0, 
                l.nextIdx++);
            }
            p.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, c);
        }, p.onInputChanged = function() {
            p.model.scale = p.rate !== flock.rates.DEMAND ? p.model.sampleDur : 1, p.inputs.values && 0 !== p.inputs.values.length || !p.inputs.list || (flock.log.warn("The 'list' input to flock.ugen.sequence is deprecated. Use 'values' instead."), 
            p.inputs.values = p.inputs.list), p.inputs.values || (p.inputs.values = []), p.calculateStrides(), 
            flock.onMulAddInputChanged(p);
        }, p.init = function() {
            p.onInputChanged();
        }, p.init(), p;
    }, flock.ugenDefaults("flock.ugen.sequence", {
        rate: "control",
        inputs: {
            start: 0,
            freq: 1,
            loop: 0,
            values: []
        },
        ugenOptions: {
            model: {
                unscaledValue: void 0,
                value: 0,
                phase: 0
            },
            strideInputs: [ "freq" ]
        }
    }), flock.ugen.sequencer = function(e, t, n) {
        var c = flock.ugen(e, t, n);
        return c.gen = function(e) {
            var t, n, r = c.model, o = c.options, a = o.resetOnNext, i = c.output, u = c.inputs.loop.output[0], l = c.inputs.durations, s = c.inputs.values;
            for (r.shouldValidateSequences && (r.shouldValidateSequences = !1, flock.ugen.sequencer.validateSequences(l, s)), 
            t = 0; t < e; t++) 0 !== s.length && 0 !== l.length ? (r.samplesRemaining <= 0 ? r.idx < l.length - 1 ? (r.idx++, 
            n = flock.ugen.sequencer.nextStage(l, s, a, r)) : 0 < u ? (r.idx = 0, n = flock.ugen.sequencer.nextStage(l, s, a, r)) : n = o.holdLastValue ? r.unscaledValue : 0 : (n = s[r.idx], 
            r.samplesRemaining--), i[t] = n) : i[t] = n = 0;
            r.unscaledValue = n, c.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, i);
        }, c.onInputChanged = function(e) {
            var t = c.model, n = c.inputs;
            "durations" !== e && n.durations === t.prevDurations || (t.idx = 0, flock.ugen.sequencer.calcDurationsSamps(n.durations, c.model), 
            flock.ugen.sequencer.validateInput("durations", c), t.prevDurations = n.durations), 
            "values" !== e && n.values === t.prevValues || (t.idx = 0, flock.ugen.sequencer.validateInput("values", c), 
            t.prevValues = n.values), c.model.shouldValidateSequences = !0, flock.onMulAddInputChanged(c);
        }, c.init = function() {
            c.onInputChanged();
        }, c.init(), c;
    }, flock.ugen.sequencer.validateInput = function(e, t) {
        var n = t.inputs[e];
        n && flock.isIterable(n) || flock.fail("No " + e + " array input was specified for flock.ugen.sequencer: " + fluid.prettyPrintJSON(t.options.ugenDef));
    }, flock.ugen.sequencer.validateSequences = function(e, t) {
        e.length !== t.length && flock.fail("Mismatched durations and values array lengths for flock.ugen.sequencer. Durations: " + fluid.prettyPrintJSON(e) + ", values: " + fluid.prettyPrintJSON(t));
    }, flock.ugen.sequencer.calcDurationsSamps = function(e, t) {
        t.samplesRemaining = Math.floor(e[t.idx] * t.sampleRate);
    }, flock.ugen.sequencer.nextStage = function(e, t, n, r) {
        return flock.ugen.sequencer.calcDurationsSamps(e, r), r.samplesRemaining--, n ? 0 : t[r.idx];
    }, flock.ugenDefaults("flock.ugen.sequencer", {
        rate: "audio",
        inputs: {
            durations: [],
            values: [],
            loop: 0
        },
        ugenOptions: {
            model: {
                idx: 0,
                samplesRemaining: 0,
                unscaledValue: 0,
                value: 0,
                prevDurations: [],
                prevValues: []
            },
            resetOnNext: !1,
            holdLastvalue: !1
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.valueChangeTrigger = function(e, t, n) {
        var u = flock.ugen(e, t, n);
        return u.gen = function(e) {
            var t, n, r, o = u.model, a = u.inputs.source.output, i = u.output;
            for (n = t = 0; t < e; t++, n += o.strides.source) r = a[n], i[t] = r !== o.prevVal ? 1 : 0, 
            o.prevVal = r;
            o.value = o.unscaledValue = r;
        }, u.onInputChanged = function(e) {
            u.calculateStrides(), "source" === e && u.options.triggerOnSetSameValue && (u.model.prevVal = null);
        }, u.calculateStrides(), u;
    }, flock.ugenDefaults("flock.ugen.valueChangeTrigger", {
        rate: "control",
        inputs: {
            source: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                prevVal: 0
            },
            triggerOnSetSameValue: !0,
            strideInputs: [ "source" ]
        }
    }), flock.ugen.inputChangeTrigger = function(e, t, n) {
        var p = flock.ugen(e, t, n);
        return p.gen = function(e) {
            var t, n, r, o, a, i = p.model, u = p.inputs.source.output, l = i.strides.source, s = p.inputs.duration.output, c = i.strides.duration, f = i.prevDur, d = p.output;
            for (t = n = r = 0; t < e; t++, n += l, r += c) o = u[n], (a = s[r]) !== f && (i.prevDur = a, 
            i.remainingOpenSamples = 0 < o ? 0 < a ? i.sampleRate * a : 1 : 0), 0 < i.remainingOpenSamples ? (d[t] = o, 
            i.remainingOpenSamples--) : d[t] = 0;
            i.value = i.unscaledValue = flock.ugen.lastOutputValue(e, d);
        }, p.onInputChanged = function(e) {
            p.calculateStrides(), "source" === e && (p.model.prevDur = null);
        }, p.calculateStrides(), p;
    }, flock.ugenDefaults("flock.ugen.inputChangeTrigger", {
        rate: "control",
        inputs: {
            source: 0,
            duration: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                prevDuration: 0,
                remainingOpenSamples: 0
            },
            strideInputs: [ "source", "duration" ]
        }
    }), flock.ugen.triggerCallback = function(e, t, n) {
        var b = flock.ugen(e, t, n);
        return b.gen = function(e) {
            var t, n, r, o, a, i = b.model, u = b.options, l = b.output, s = b.inputs, c = i.strides.trigger, f = i.strides.source, d = s.trigger.output, p = s.source.output, m = u.callback, g = m.func, h = m.args, v = m.this, y = i.lastArgIdx, k = i.prevTrig;
            for (t = n = r = 0; t < e; t++, n += c, r += f) o = d[n], a = p[r], 0 < o && k <= 0 && g && (h[y] = a, 
            g.apply(v, h)), l[t] = a, k = o;
            i.prevTrig = k, i.value = i.unscaledValue = a;
        }, b.onInputChanged = function() {
            var e = b.options, t = b.model, n = e.callback, r = n.funcName;
            if (r) n.func = fluid.getGlobalValue(r); else if (n.this && n.method) {
                if ("string" != typeof n.this) throw new Error("flock.ugen.triggerCallback doesn't support raw 'this' objects.Use a global key path instead.");
                n.this = "string" == typeof n.this ? fluid.getGlobalValue(n.this) : n.this, n.func = fluid.get(n.this, n.method);
            }
            t.lastArgIdx = n.args.length, b.calculateStrides();
        }, b.onInputChanged(), b;
    }, flock.ugenDefaults("flock.ugen.triggerCallback", {
        rate: "audio",
        inputs: {
            source: 0,
            trigger: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                funcName: void 0,
                lastArgIdx: 0
            },
            callback: {
                this: void 0,
                method: void 0,
                func: void 0,
                args: []
            },
            strideInputs: [ "source", "trigger" ]
        }
    }), flock.ugen.t2a = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.gen = function() {
            for (var e, t = i.model, n = i.inputs.source.output[0], r = 0 | i.inputs.offset.output[0], o = i.output, a = 0; a < o.length; a++) o[a] = e = 0;
            0 < n && t.prevTrig <= 0 && (o[r] = e = n), t.prevTrig = n, t.value = t.unscaledValue = e;
        }, i;
    }, flock.ugenDefaults("flock.ugen.t2a", {
        rate: "audio",
        inputs: {
            source: null,
            offset: 0
        },
        ugenOptions: {
            model: {
                prevTrig: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    });
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var o = fluid.registerNamespace("jQuery");
    fluid.registerNamespace("flock.view"), flock.view.scope = function(e, t) {
        var c = {
            model: t || {
                values: []
            },
            canvas: o(e)[0],
            refreshView: function() {
                var e, t, n, r = c.ctx, o = c.model.height, a = c.model.halfHeight, i = c.model.width, u = c.model.values, l = u.length, s = c.model.scaleX * (i / l);
                for (r.clearRect(0, 0, i, o), r.beginPath(), e = 0; e < l; e++) t = e * s, n = u[e] * c.model.scaleY * a + a, 
                r.lineTo(t, n);
                r.stroke();
            },
            init: function() {
                c.ctx = c.canvas.getContext("2d"), c.ctx.fillStyle = c.model.fill || c.ctx.fillStyle, 
                c.ctx.strokeStyle = c.model.strokeColor || c.ctx.strokeStyle, c.ctx.lineWidth = c.model.strokeWidth || c.ctx.lineWidth, 
                c.model.min = c.model.min || -1, c.model.max = c.model.max || 1, c.model.height = c.canvas.height, 
                c.model.halfHeight = c.model.height / 2, c.model.width = c.canvas.width, c.model.scaleX = c.model.scaleX || c.model.scale || 1, 
                c.model.scaleY = c.model.scaleY || c.model.scale || 1, c.refreshView();
            }
        };
        return c.init(), c;
    }, flock.view.drawBuffer = function(e, t) {
        (t = t || {}).height = t.height || 200, t.width = t.width || 1e3;
        var n = fluid.stringTemplate(flock.view.drawBuffer.markupTemplate, t), r = o(n);
        return flock.view.scope(r[0], {
            values: e
        }), r;
    }, flock.view.drawBuffer.markupTemplate = "<canvas height='%height' width='%width'></canvas>";
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var a = fluid.registerNamespace("jQuery");
    fluid.registerNamespace("flock.ugen"), flock.ugen.scope = function(e, t, n) {
        var u = flock.ugen(e, t, n);
        return u.gen = function(e) {
            var t, n = u.model, r = u.inputs.source.output, o = n.spf, a = n.bufIdx, i = n.scope.values;
            for (t = 0; t < e; t++) i[a] = r[t], a < o ? a += 1 : (a = 0, u.scopeView.refreshView());
            n.bufIdx = a, n.value = n.unscaledValue = flock.ugen.lastOutputValue(e, r);
        }, u.onInputChanged = function() {
            u.output = u.inputs.source.output;
        }, u.init = function() {
            u.model.spf = Math.round(u.model.sampleRate / u.options.fps), u.model.bufIdx = 0, 
            u.model.scope = u.options.styles, u.model.scope.values = new Float32Array(u.model.spf), 
            u.scopeView = flock.view.scope(u.options.canvas, u.model.scope), u.onInputChanged(), 
            u.scopeView.refreshView();
        }, u.init(), u;
    }, flock.ugenDefaults("flock.ugen.scope", {
        rate: "audio",
        inputs: {
            source: null
        },
        ugenOptions: {
            fps: 60,
            styles: {
                strokeColor: "#777777",
                strokeWidth: 1
            }
        }
    }), flock.ugen.mouse = {}, flock.ugen.mouse.cursor = function(e, t, n) {
        var f = flock.ugen(e, t, n);
        return f.exponentialGen = function(e) {
            var t, n, r = f.model, o = flock.ugen.mouse.cursor.normalize(f.target, r), a = r.movingAvg, i = f.inputs.lag.output[0], u = f.inputs.add.output[0], l = f.inputs.mul.output[0], s = r.lagCoef, c = f.output;
            for (i !== s && (s = 0 === i ? 0 : Math.exp(flock.LOG001 / (i * r.sampleRate)), 
            r.lagCoef = s), t = 0; t < e; t++) n = l + u, a = (o = Math.pow(n / u, o) * u) + s * (a - o), 
            c[t] = a;
            r.movingAvg = a, r.value = r.unscaledValue = a;
        }, f.linearGen = function(e) {
            var t, n = f.model, r = flock.ugen.mouse.cursor.normalize(f.target, n), o = n.movingAvg, a = f.inputs.lag.output[0], i = f.inputs.add.output[0], u = f.inputs.mul.output[0], l = n.lagCoef, s = f.output;
            for (a !== l && (l = 0 === a ? 0 : Math.exp(flock.LOG001 / (a * n.sampleRate)), 
            n.lagCoef = l), t = 0; t < e; t++) o = r + l * (o - r), s[t] = o * u + i;
            n.movingAvg = n.unscaledValue = o, n.value = flock.ugen.lastOutputValue(e, s);
        }, f.noInterpolationGen = function(e) {
            var t, n = f.model, r = f.output, o = flock.ugen.mouse.cursor.normalize(f.target, n);
            for (t = 0; t < e; t++) r[t] = o * f.inputs.mul.output[0] + f.inputs.add.output[0];
            n.value = n.unscaledValue = flock.ugen.lastOutputValue(e, r);
        }, f.moveListener = function(e) {
            var t = f.model;
            t.mousePosition = e[t.eventProp];
        }, f.overListener = function() {
            f.model.isWithinTarget = !0;
        }, f.outListener = function() {
            var e = f.model;
            e.isWithinTarget = !1, e.mousePosition = 0;
        }, f.downListener = function() {
            f.model.isMouseDown = !0;
        }, f.upListener = function() {
            var e = f.model;
            e.isMouseDown = !1, e.mousePosition = 0;
        }, f.moveWhileDownListener = function(e) {
            f.model.isMouseDown && f.moveListener(e);
        }, f.bindEvents = function() {
            var e = f.target, t = f.moveListener;
            f.options.onlyOnMouseDown && (e.mousedown(f.downListener), e.mouseup(f.upListener), 
            t = f.moveWhileDownListener), e.mouseover(f.overListener), e.mouseout(f.outListener), 
            e.mousemove(t);
        }, f.onInputChanged = function() {
            flock.onMulAddInputChanged(f);
            var e = f.options.interpolation;
            f.gen = "none" === e ? f.noInterpolationGen : "exponential" === e ? f.exponentialGen : f.linearGen;
        }, f.init = function() {
            var e = f.model, t = f.options, n = t.axis, r = a(t.target || window);
            "x" === n || "width" === n || "horizontal" === n ? (e.eventProp = "clientX", e.offsetProp = "left", 
            e.dimension = "width") : (e.eventProp = "clientY", e.offsetProp = "top", e.dimension = "height"), 
            f.target = r, e.mousePosition = 0, e.movingAvg = 0, f.bindEvents(), f.onInputChanged();
        }, f.init(), f;
    }, flock.ugen.mouse.cursor.normalize = function(e, t) {
        if (!t.isWithinTarget) return 0;
        var n = e.getClientRects ? e.offset() : void 0, r = t.mousePosition, o = e[t.dimension]();
        return n && (r -= n[t.offsetProp]), r / o;
    }, flock.ugenDefaults("flock.ugen.mouse.cursor", {
        rate: "control",
        inputs: {
            lag: .5,
            add: 0,
            mul: 1
        },
        ugenOptions: {
            axis: "x",
            interpolation: "linear",
            model: {
                mousePosition: 0,
                movingAvg: 0,
                value: 0
            }
        }
    }), flock.ugen.mouse.click = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.gen = function(e) {
            var t, n = o.output, r = o.model;
            for (t = 0; t < e; t++) n[t] = r.unscaledValue;
            o.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, n);
        }, o.mouseDownListener = function() {
            o.model.unscaledValue = 1;
        }, o.mouseUpListener = function() {
            o.model.unscaledValue = 0;
        }, o.init = function() {
            var e = o.model;
            e.target = o.options.target ? a(o.options.target) : a(window), e.target.mousedown(o.mouseDownListener), 
            e.target.mouseup(o.mouseUpListener), o.onInputChanged();
        }, o.onInputChanged = function() {
            flock.onMulAddInputChanged(o);
        }, o.init(), o;
    }, flock.ugenDefaults("flock.ugen.mouse.click", {
        rate: "control"
    }), flock.ugen.mediaIn = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.gen = function(e) {
            for (var t, n = i.model, r = i.output, o = i.bus, a = 0; a < e; a++) r[a] = t = o[a];
            n.unscaledValue = t, i.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, i.onInputChanged = function() {
            flock.onMulAddInputChanged(i);
        }, i.init = function() {
            var e = i.enviro.audioSystem.nativeNodeManager, t = a(i.options.element), n = e.createMediaElementInput(t[0]);
            i.bus = i.options.buses[n], i.onInputChanged(), flock.platform.browser.safari && flock.platform.browser.majorVersionNumber < 601 ? flock.log.warn("MediaElementSourceNode only works on Safari 9 or higher. For more information, see https://bugs.webkit.org/show_bug.cgi?id=84743 and https://bugs.webkit.org/show_bug.cgi?id=125031") : flock.platform.isAndroid && flock.log.warn("MediaElementSourceNode does not work on Android. For more information, see https://code.google.com/p/chromium/issues/detail?id=419446");
        }, i.init(), i;
    }, flock.ugenDefaults("flock.ugen.mediaIn", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        },
        ugenOptions: {
            element: "audio"
        }
    });
}();